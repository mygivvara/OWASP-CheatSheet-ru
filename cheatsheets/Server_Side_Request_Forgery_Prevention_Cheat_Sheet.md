# Шпаргалка по предотвращению подделки запросов на стороне сервера (SSRF)

## Введение

Цель шпаргалки - предоставить рекомендации по защите от [подделки запросов на стороне сервера](https://www.acunetix.com/blog/articles/server-side-request-forgery-vulnerability/) (SSRF) атаки.

Эта шпаргалка будет посвящена защитной точке зрения и не будет объяснять, как выполнять эту атаку. Это [выступление](../assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_Orange_Tsai_Talk.pdf) от исследователя безопасности [Orange Tsai](https://twitter.com/orange_8361 ), а также этот [документ](../assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Bible.pdf) содержат методы проведения такого рода атак.

## Контекст

SSRF - это вектор атаки, который использует приложение для взаимодействия с внутренней/внешней сетью или самим компьютером. Одним из факторов, способствующих этому вектору, является неправильное использование URL-адресов, как показано в следующих примерах:

- Изображение на внешнем сервере (*например,* пользователь вводит URL-адрес изображения своего аватара, чтобы приложение могло загрузить и использовать его).
- Пользовательский [WebHook](https://en.wikipedia.org/wiki/Webhook) (пользователи должны указать обработчики Webhook или URL-адреса обратного вызова).
- Внутренние запросы на взаимодействие с другим сервисом для выполнения определенной функциональности. В большинстве случаев пользовательские данные отправляются на обработку, и при неправильной обработке могут быть использованы для выполнения специфических атак путем внедрения.

## Обзор общего потока SSRF

![SSRF Common Flow](../assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Common_Flow.png)

*Примечания:*

- SSRF не ограничивается протоколом HTTP. Как правило, первым запросом является HTTP, но в тех случаях, когда приложение само выполняет второй запрос, оно может использовать другие протоколы (*например,* FTP, SMB, SMTP и т.д.) и схемы (*например, * `file://`, `phar://`, `gopher://`, `data://`, `dict://` и т.д.).
- Если приложение уязвимо для [внедрения внешнего объекта XML (XXE)] (https://portswigger.net/web-security/xxe), то оно может быть использовано для выполнения [SSRF-атаки](https://portswigger.net/web-security/xxe#exploiting-xxe-to-perform-ssrf-attacks), ознакомьтесь с [шпаргалкой по XXE](XML_External_Entity_Prevention_Cheat_Sheet.md), чтобы узнать, как предотвратить воздействие XXE.

## Случаи

В зависимости от функциональности и требований приложения, существует два основных случая, в которых может произойти SSRF:

- Приложение может отправлять запросы только в **идентифицированные и надежные приложения**: В случае, если доступен метод [allowlist](https://en.wikipedia.org/wiki/Whitelisting).
- Приложение может отправлять запросы на **ЛЮБОЙ внешний IP-адрес или доменное имя**: В случае, если метод [allowlist](https://en.wikipedia.org/wiki/Whitelisting) недоступен.

Поскольку эти два случая сильно отличаются друг от друга, в этой шпаргалке будут отдельно описаны способы защиты от них.

### Случай 1 - Приложение может отправлять запросы только идентифицированным и надежным приложениям

Иногда приложению требуется выполнить запрос к другому приложению, часто расположенному в другой сети, для выполнения определенной задачи. В зависимости от бизнес-ситуации для работы функциональности требуется ввод данных пользователем.

#### Пример

 > Рассмотрим пример веб-приложения, которое получает и использует личную информацию от пользователя, такую как его имя, фамилия, дата рождения и т.д. для создания профиля во внутренней системе управления персоналом. По замыслу, это веб-приложение должно взаимодействовать с использованием протокола, понятного системе управления персоналом для обработки этих данных.
 > В принципе, пользователь не может связаться с системой управления персоналом напрямую, но, если веб-приложение, отвечающее за получение пользовательской информации, уязвимо для SSRF, пользователь может использовать его для доступа к системе управления персоналом.
 > Пользователь использует веб-приложение в качестве посредника для системы управления персоналом.

Подход с использованием списка разрешений является приемлемым вариантом, поскольку внутреннее приложение, вызываемое уязвимым приложением, четко идентифицируется в техническом/бизнес-потоке. Можно утверждать, что требуемые вызовы будут осуществляться только между этими идентифицированными и надежными приложениями.

#### Доступные средства защиты

На уровнях **приложения** и **сети** возможно несколько защитных мер. Для применения принципа **глубокой защиты** оба уровня будут защищены от подобных атак.

##### Прикладной уровень

Первый уровень защиты, который приходит на ум, - это [Проверка ввода](Input_Validation_Cheat_Sheet.md).

Исходя из этого, возникает следующий вопрос: *Как выполнить эту проверку ввода?*

Как [Orange Tsai](https://twitter.com/orange_8361 ) показывает в своем [talk](../assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_Orange_Tsai_Talk.pdf), что в зависимости от используемого языка программирования синтаксическими анализаторами можно злоупотреблять. Одной из возможных мер противодействия является применение подхода [allowlist](Input_Validation_Cheat_Sheet.md#allow-list-vs-block-list) при проверке ввода, поскольку в большинстве случаев формат информации, ожидаемой от пользователя, известен во всем мире.

Запрос, отправленный во внутреннее приложение, будет основан на следующей информации:

- Строка, содержащая бизнес-данные.
- IP-адрес (V4 или V6).
- Доменное имя.
- URL.

**Примечание:** Отключите поддержку следующего [перенаправления](https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections) в вашем веб-клиенте, чтобы предотвратить обход проверки ввода, описанной в разделе "Приемы использования > Обход ограничений > Проверка ввода > Небезопасное перенаправление` этого [документа](../assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Bible.pdf).

###### Строка

В контексте SSRF можно добавить проверки, чтобы убедиться, что входная строка соответствует ожидаемому деловому/техническому формату.

A [регулярное выражение](https://www.regular-expressions.info /) может использоваться для обеспечения достоверности полученных данных с точки зрения безопасности, если входные данные имеют простой формат (токен, почтовый индекс и т.д.). В противном случае проверка должна проводиться с использованием библиотек, доступных из "строки` возражаю, потому что регулярные выражения для сложных форматов сложны в обслуживании и очень подвержены ошибкам.

Предполагается, что вводимые пользователем данные не связаны с сетью и состоят из личной информации пользователя.

Пример:

```java
//Проверка регулярных выражений для данных, имеющих простой формат
if(Pattern.matches("[a-zA-Z0-9\\s\\-]{1,50}", userInput)){
    //Продолжайте обработку, поскольку входные данные являются действительными
}else{
    //Остановите обработку и отклоните запрос
}
```

###### IP адресс

IВ контексте SRF существует 2 возможных способа проверки:

1. Убедитесь, что предоставленные данные являются действительным адресом IPV4 или V6.
2. Убедитесь, что указанный IP-адрес принадлежит одному из IP-адресов идентифицированных и надежных приложений.

Первый уровень проверки может быть применен с использованием библиотек, которые обеспечивают безопасность формата IP-адреса на основе используемой технологии (здесь предлагается вариант библиотеки, позволяющий делегировать управление форматом IP-адреса и использовать проверенную в боях функцию проверки).:

> Была проведена проверка предлагаемых библиотек на предмет использования обходных кодировок (шестнадцатеричных, восьмеричных, Word, URL и смешанных кодировок), описанных в этой [статье](https://medium.com/@vickieli/bypassing-ssrf-protection-e111ae70727b).

- **JAVA:** Метод [InetAddressValidator.isValid](http://commons.apache.org/proper/commons-validator/apidocs/org/apache/commons/validator/routines/InetAddressValidator.html#isValid(java.lang.String)) из библиотеки [Apache Commons Validator](http://commons.apache.org/proper/commons-validator/).
    - **Его невозможно обойти**, используя шестнадцатеричную, восьмеричную, Dword, URL и смешанную кодировку.
- **.NET**: Метод [IPAddress.TryParse](https://docs.microsoft.com/en-us/dotnet/api/system.net.ipaddress.tryparse?view=netframework-4.8) из пакета SDK.
    - **Его можно обойти**, используя шестнадцатеричную, восьмеричную, Dword и смешанную кодировку, но не кодировку URL.
    - Поскольку здесь используется список разрешенных адресов, любая предварительная попытка обхода будет заблокирована при сравнении с разрешенным списком IP-адресов.
- **JavaScript**: Библиотека [ip-адрес](https://www.npmjs.com/package/ip-address).
    - **Его невозможно обойти**, используя шестнадцатеричную, восьмеричную, Dword, URL и смешанную кодировку.
- **Ruby**: Класс [IPAddr](https://ruby-doc.org/stdlib-2.0.0/libdoc/ipaddr/rdoc/IPAddr.html) из SDK.
    - **Его невозможно обойти**, используя шестнадцатеричную, восьмеричную, Dword, URL и смешанную кодировку.

> **Используйте выходное значение метода/библиотеки в качестве IP-адреса для сравнения со списком разрешений.**

После проверки достоверности входящего IP-адреса применяется второй уровень проверки. После определения всех IP-адресов (v4 и v6 во избежание обходов) идентифицированных и надежных приложений создается список разрешений. Действительный IP-адрес сверяется с этим списком, чтобы обеспечить его связь с внутренним приложением (строгое сравнение строк с учетом регистра).

###### Доменное имя

При попытке проверки доменных имен, очевидно, необходимо выполнить разрешение DNS для проверки существования домена. В целом, это неплохая идея, но она открывает приложение для атак в зависимости от конфигурации, используемой в отношении DNS-серверов, используемых для разрешения доменных имен:

- Он может передавать информацию внешним распознавателям DNS.
- Он может быть использован злоумышленником для привязки законного доменного имени к внутреннему IP-адресу. Смотрите раздел `Приемы использования > Обход ограничений > Проверка ввода данных > Закрепление DNS` этого [документа](../assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Bible.pdf).
- Злоумышленник может использовать его для доставки вредоносной полезной нагрузки внутренним преобразователям DNS и API (SDK или сторонним), используемым приложением для обработки DNS-сообщений, а затем, возможно, активировать уязвимость в одном из этих компонентов.

В контексте SSRF необходимо выполнить две проверки:

1. Убедитесь, что предоставленные данные соответствуют действительному доменному имени.
2. Убедитесь, что указанное доменное имя принадлежит одному из доменных имен идентифицированных и надежных приложений (здесь вступает в действие список разрешений).

Аналогично проверке IP-адреса, первый уровень проверки может быть применен с использованием библиотек, которые обеспечивают безопасность формата доменного имени на основе используемой технологии (здесь предлагается опция библиотеки, чтобы делегировать управление форматом доменного имени и использовать проверенную временем функцию проверки).:

> Была проведена проверка предлагаемых библиотек, чтобы убедиться, что предлагаемые функции не выполняют никаких запросов разрешения DNS.

- **JAVA:** Метод [DomainValidator.isValid](https://commons.apache.org/proper/commons-validator/apidocs/org/apache/commons/validator/routines/DomainValidator.html#isValid(java.lang.String)) из библиотеки [Apache Commons Validator](http://commons.apache.org/proper/commons-validator/).
- **.NET**: Метод [Uri.CheckHostName](https://docs.microsoft.com/en-us/dotnet/api/system.uri.checkhostname?view=netframework-4.8) из пакета SDK.
- **JavaScript**: Библиотека [is-valid-domain](https://www.npmjs.com/package/is-valid-domain).
- **Python**: модуль [validators.domain](https://validators.readthedocs.io/en/latest/#module-validators.domain).
- **Ruby**: Не найден допустимый выделенный gem.
    - [domainator](https://github.com/mhuggins/domainator), [public_suffix](https://github.com/weppos/publicsuffix-ruby) и [addressable](https://github.com/sporkmonger/addressable) были протестированы, но, к сожалению, все они рассматривают `<script>alert(1)</script>.owasp.org` как допустимое доменное имя.
    - Это регулярное выражение, взятое из [здесь](https://stackoverflow.com/a/26987741), можно использовать: `^(((?!-))(xn--|_{1,1})?[a-z0-9-]{0,61}[a-z0-9]{1,1}\.)*(xn--)?([a-z0-9][a-z0-9\-]{0,60}|[a-z0-9-]{1,30}\.[a-z]{2,})$`

Пример выполнения предложенного регулярного выражения для Ruby:

```ruby
domain_names = ["owasp.org","owasp-test.org","doc-test.owasp.org","doc.owasp.org",
                "<script>alert(1)</script>","<script>alert(1)</script>.owasp.org"]
domain_names.each { |domain_name|
    if ( domain_name =~ /^(((?!-))(xn--|_{1,1})?[a-z0-9-]{0,61}[a-z0-9]{1,1}\.)*(xn--)?([a-z0-9][a-z0-9\-]{0,60}|[a-z0-9-]{1,30}\.[a-z]{2,})$/ )
        puts "[i] #{domain_name} is VALID"
    else
        puts "[!] #{domain_name} is INVALID"
    end
}
```

```bash
$ ruby test.rb
[i] owasp.org is VALID
[i] owasp-test.org is VALID
[i] doc-test.owasp.org is VALID
[i] doc.owasp.org is VALID
[!] <script>alert(1)</script> is INVALID
[!] <script>alert(1)</script>.owasp.org is INVALID
```

После проверки правильности входящего доменного имени применяется второй уровень проверки:

1. Создайте список разрешений, содержащий все доменные имена всех идентифицированных и надежных приложений.
2. Убедитесь, что полученное доменное имя является частью этого списка разрешений (строгое сравнение строк с учетом регистра).

К сожалению, приложение по-прежнему уязвимо для обхода `DNS-привязки`, упомянутого в этом [документе](../assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Bible.pdf). Действительно, разрешение DNS будет выполнено, когда будет выполнен бизнес-код. Для решения этой проблемы необходимо выполнить следующие действия в дополнение к проверке доменного имени:

1. Убедитесь, что домены, входящие в состав вашей организации, разрешены вашим внутренним DNS-сервером первыми в цепочках распознавателей DNS.
2. Следите за списком разрешенных доменов, чтобы определить, когда какой-либо из них разрешен как a/an:
   - Локальный IP-адрес (версии 4 + 6).
   - Внутренний IP-адрес вашей организации (ожидается, что он будет находиться в частных диапазонах IP-адресов) для домена, который не является частью вашей организации.

Следующий скрипт на Python3 может быть использован в качестве отправной точки для мониторинга, упомянутого выше:

```python
# Зависимости: pip устанавливает ip-адрес dnspython
import ipaddress
import dns.resolver

# Настройте список разрешений для проверки
DOMAINS_ALLOWLIST = ["owasp.org", "labslinux"]

# Настройте распознаватель DNS, который будет использоваться для всех DNS-запросов
DNS_RESOLVER = dns.resolver.Resolver()
DNS_RESOLVER.nameservers = ["1.1.1.1"]

def verify_dns_records(domain, records, type):
    """
    Проверьте, не является ли одна из записей DNS непубличным IP-адресом.
    Возвращает логическое значение, указывающее, была ли обнаружена какая-либо ошибка.
    """
    error_detected = False
    if records is not None:
        for record in records:
            value = record.to_text().strip()
            try:
                ip = ipaddress.ip_address(value)
                # See https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address.is_global
                if not ip.is_global:
                    print("[!] DNS record type '%s' for domain name '%s' resolve to
                    a non public IP address '%s'!" % (type, domain, value))
                    error_detected = True
            except ValueError:
                error_detected = True
                print("[!] '%s' is not valid IP address!" % value)
    return error_detected

def check():
    """
    Выполните проверку списка разрешенных доменов.
    Верните логическое значение, указывающее, была ли обнаружена какая-либо ошибка.
    """
    error_detected = False
    for domain in DOMAINS_ALLOWLIST:
        # Получите IP-адреса текущего домена
        # Смотрите https://en.wikipedia.org/wiki/List_of_DNS_record_types
        try:
            # A = Запись IPv4-адреса
            ip_v4_records = DNS_RESOLVER.query(domain, "A")
        except Exception as e:
            ip_v4_records = None
            print("[i] Cannot get A record for domain '%s': %s\n" % (domain,e))
        try:
            # AAAA = Запись IPv6-адреса
            ip_v6_records = DNS_RESOLVER.query(domain, "AAAA")
        except Exception as e:
            ip_v6_records = None
            print("[i] Cannot get AAAA record for domain '%s': %s\n" % (domain,e))
        # Проверка полученных IP-адресов
        if verify_dns_records(domain, ip_v4_records, "A")
        or verify_dns_records(domain, ip_v6_records, "AAAA"):
            error_detected = True
    return error_detected

if __name__== "__main__":
    if check():
        exit(1)
    else:
        exit(0)
```

###### URL

Не принимайте полные URL-адреса от пользователя, потому что URL-адреса трудно проверить, а анализатором можно злоупотреблять в зависимости от используемой технологии, как показано в следующем [talk](../assets/server_side_request_forgery_prevention_cheat_sheet_orange_tsai.pdf) из [Orange Tsai](https://twitter.com/orange_8361 ).

Если вам действительно нужна информация, связанная с сетью, то принимайте только действительный IP-адрес или доменное имя.

##### Сетевой уровень

Цель безопасности сетевого уровня - предотвратить выполнение *уязвимым приложением* вызовов произвольных приложений. Для этого приложения будут доступны только разрешенные *маршруты*, чтобы ограничить его доступ к сети только теми, с которыми оно должно взаимодействовать.

Компонент брандмауэра, как отдельное устройство или с использованием того, которое предоставляется в операционной системе, будет использоваться здесь для определения допустимых потоков.

В приведенной ниже схеме компонент брандмауэра используется для ограничения доступа приложения и, в свою очередь, для ограничения воздействия приложения, уязвимого для SSRF:

![Случай 1 для защиты сетевого уровня от потоков, которых мы хотим избежать](../assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_Case1_NetworkLayer_PreventFlow.png)

[Сетевая сегрегация](https://www.mwrinfosecurity.com/our-thinking/making-the-case-for-network-segregation) (посмотрите на этот набор [рекомендаций по внедрению](https://www.cyber.gov.au/acsc/view-all-content/publications/implementing-network-segmentation-and-segregation) также может быть использован и **настоятельно рекомендуется для того, чтобы блокировать незаконные вызовы непосредственно на сетевом уровне**.

### Случай 2 - Приложение может отправлять запросы на любой внешний IP-адрес или доменное имя

Это происходит, когда пользователь может управлять URL-адресом **внешнего** ресурса, и приложение отправляет запрос на этот URL-адрес (например, в случае [WebHooks](https://en.wikipedia.org/wiki/Webhook)). Здесь нельзя использовать разрешенные списки, поскольку список IP-адресов/доменов часто заранее неизвестен и динамически меняется.

В этом случае *Внешний* относится к любому IP-адресу, который не принадлежит внутренней сети, и должен быть доступен через общедоступный Интернет.

Таким образом, вызов из *уязвимого приложения*:

- **НЕ** нацелен ни на один из IP-адресов/доменов, расположенных внутри глобальной сети компании.
- Использует соглашение, установленное между *уязвимым приложением* и ожидаемым IP-адресом/доменом, чтобы *доказать*, что вызов был инициирован законным образом.

#### Проблемы с блокировкой URL-адресов на прикладном уровне

Исходя из бизнес-требований вышеупомянутых приложений, подход с использованием разрешенных списков не является приемлемым решением. Несмотря на то, что мы знаем, что подход с использованием запрещенных списков не является непробиваемой стеной, в данном случае это лучшее решение. Он информирует приложение о том, чего ему **не** следует делать.

Вот почему фильтрация URL-адресов на прикладном уровне является сложной задачей:

- Это означает, что приложение должно быть способно определять на уровне кода, что указанный IP (версии 4 + 6) не входит в официальные [диапазоны частных сетей].(https://en.wikipedia.org/wiki/Private_network ), включая также адреса *localhost* и *IPv4/v6 Link-Local*. Не каждый SDK предоставляет встроенную функцию для такого рода проверки, и разработчику остается разобраться во всех ее подводных камнях и возможных значениях, что делает ее сложной задачей.
- То же самое касается доменного имени: Компания должна вести список всех внутренних доменных имен и предоставлять централизованный сервис, позволяющий приложению проверять, является ли предоставленное доменное имя внутренним. Для этой проверки приложение может запросить внутренний DNS-распознаватель, но этот внутренний DNS-распознаватель не должен разрешать внешние доменные имена.

#### Доступные средства защиты

Принимая во внимание то же предположение в следующем [примере](Server_Side_Request_Forgery_Prevention_Cheat_Sheet.md#example) для следующих разделов.

##### Прикладной уровень

Как и в случае с [n°1](Server_Side_Request_Forgery_Prevention_Cheat_Sheet.md#case-1-application-can-send-request-only-to-identified-and-trusted-applications), предполагается, что для создания запроса, который будет отправлен в *Целевое приложение*, требуется `IP-адрес` или `доменное имя`.

Первая проверка входных данных, представленных в случае [n°1](Server_Side_Request_Forgery_Prevention_Cheat_Sheet.md#application-layer) для 3 типов данных, будет одинаковой для этого случая, **но вторая проверка будет отличаться**. Действительно, здесь мы должны использовать подход, основанный на блок-листе.

> **Что касается подтверждения законности запроса**: *Целевое приложение*, которое получит запрос, должно сгенерировать случайный токен (например, буквенно-цифровой из 20 символов), который, как ожидается, будет передан вызывающей стороной (в теле запроса через параметр, для которого имя также определяется самим приложением и разрешать только набор символов `[a-z]{1,10}`) для выполнения допустимого запроса. Принимающая конечная точка должна принимать только HTTP POST-запросы.

**Процесс проверки (если один из этапов проверки не выполняется, запрос отклоняется):**

1. Приложение получит IP-адрес или доменное имя *целевого приложения* и применит первую проверку к входным данным, используя библиотеки/регулярные выражения, упомянутые в этом [разделе] (Server_Side_Request_Forgery_Prevention_Cheat_Sheet.md#прикладной уровень).
2. Вторая проверка будет применена к IP-адресу или доменному имени *целевого приложения* с использованием следующего подхода к блокировке списков:
   - Для IP-адреса:
     - Приложение проверит, является ли оно общедоступным (смотрите подсказку, приведенную в следующем абзаце с примером кода на python).
   - Для доменного имени:
        1. Приложение проверит, является ли оно общедоступным, попытавшись разрешить доменное имя с помощью средства распознавания DNS, которое разрешит только внутреннее доменное имя. Здесь оно должно вернуть ответ, указывающий на то, что оно не знает указанный домен, поскольку полученное ожидаемое значение должно быть общедоступным доменом.
        2. Чтобы предотвратить атаку `закрепления DNS (DNS pinning)`, описанную в этом [документе](../assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Bible.pdf), приложение извлекает все IP-адреса, указанные в указанном доменном имени (используя записи *A* + *AAAA* для IPv4 + IPv6), и применяет ту же проверку, что и описанная выше. в предыдущем пункте говорилось об IP-адресах.
3. Приложение получит протокол, который будет использоваться для запроса, через специальный входной параметр, значение которого оно сверит с разрешенным списком протоколов (`HTTP` или `HTTPS`).
4. Приложение получит имя параметра для токена, который будет передан в *TargetedApplication*, через специальный входной параметр, для которого разрешено использовать только символы `[a-z]{1,10}`.
5. Приложение само получит токен через специальный входной параметр, для которого оно разрешит использовать только символы `[a-zA-Z0-9]{20}`.
6. Приложение будет получать и проверять (с точки зрения безопасности) любые бизнес-данные, необходимые для выполнения корректного вызова.
7. Приложение создаст HTTP POST-запрос, **используя только проверенную информацию**, и отправит его (*не забудьте отключить поддержку [перенаправления](https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections) в используемом веб-клиенте*).

##### Сетевой уровень

Аналогично следующему [разделу](Server_Side_Request_Forgery_Prevention_Cheat_Sheet.md#сетевой уровень).

## IMDSv2 в AWS

В облачных средах SSRF часто используется для доступа и кражи учетных данных и токенов доступа из служб метаданных (например, службы метаданных экземпляров AWS, службы метаданных экземпляров Azure, сервера метаданных GCP).

[IMDSv2](https://aws.amazon.com/blogs/security/defense-in-depth-open-firewalls-reverse-proxies-ssrf-vulnerabilities-ec2-instance-metadata-service/ ) - это дополнительный механизм глубокой защиты AWS, который устраняет некоторые проблемы, связанные с SSRF.

Чтобы усилить эту защиту, перейдите на IMDSv2 и отключите старый IMDSv1. Более подробную информацию смотрите в [документации AWS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html).

## Правила Semgrep

[Semgrep] (https://semgrep.dev/) - это инструмент командной строки для автономного статического анализа. Используйте готовые или пользовательские правила для обеспечения соблюдения кода и стандартов безопасности в вашей кодовой базе.
Ознакомьтесь с правилом Semgrep для SSRF, чтобы выявить/исследовать уязвимости SSRF в Java
[https://semgrep.dev/salecharohit:owasp_java_ssrf](https://semgrep.dev/salecharohit:owasp_java_ssrf)

## Ссылки на литерутуру

Онлайн-версия Библии [SSRF](https://docs.google.com/document/d/1v1TkWZtrhzRLy0bYXBcdLUedXGb9njTNIJXa3u9akHM) (в этой шпаргалке использована версия в формате PDF).

Статья о [обходе защиты CSRF](https://medium.com/@vickieli/bypassing-ssrf-protection-e111ae70727b).

Статьи о SSRF-атаках: [Часть 1](https://medium.com/poka-techblog/server-side-request-forgery-ssrf-attacks-part-1-the-basics-a42ba5cc244a), [часть 2](https://medium.com/poka-techblog/server-side-request-forgery-ssrf-attacks-part-2-fun-with-ipv4-addresses-eb51971e476d) и [часть 3](https://medium.com/poka-techblog/server-side-request-forgery-ssrf-part-3-other-advanced-techniques-3f48cbcad27e).

Статья о [IMDSv2](https://aws.amazon.com/blogs/security/defense-in-depth-open-firewalls-reverse-proxies-ssrf-vulnerabilities-ec2-instance-metadata-service/)

## Инструменты и код, используемые для создания схем

- [Mermaid Online Editor](https://mermaidjs.github.io/mermaid-live-editor) и [Mermaid documentation](https://mermaidjs.github.io/).
- [Draw.io Online Editor](https://www.draw.io/).

Код Mermaid для SSRF common flow (print screen используется для захвата изображения в формате PNG, вставленного в эту шпаргалку):

```text
sequenceDiagram
    participant Attacker
    participant VulnerableApplication
    participant TargetedApplication
    Attacker->>VulnerableApplication: Crafted HTTP request
    VulnerableApplication->>TargetedApplication: Request (HTTP, FTP...)
    Note left of TargetedApplication: Use payload included<br>into the request to<br>VulnerableApplication
    TargetedApplication->>VulnerableApplication: Response
    VulnerableApplication->>Attacker: Response
    Note left of VulnerableApplication: Include response<br>from the<br>TargetedApplication
```

Draw.io XML-код схемы для схемы "[Случай 1 для защиты сетевого уровня от потоков, которых мы хотим избежать](../assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_Case1_NetworkLayer_PreventFlow.xml)" (printscreen используется для захвата изображения в формате PNG, вставленного в эту шпаргалку). 
