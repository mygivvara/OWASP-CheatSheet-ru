# Шпаргалка по защите от внедрения команд операционной системы

## Вступление

Внедрение команд (или внедрение команд операционной системы) - это тип внедрения, при котором программное обеспечение, создающее системную команду с использованием вводимых извне данных, неправильно нейтрализует вводимые данные от специальных элементов, которые могут изменить первоначально предназначенную команду.

Например, если указанное значение равно:

``` shell
calc
```

при вводе в командной строке Windows отображается приложение *Калькулятор*.

Однако, если введенное значение было изменено, и теперь оно:

``` shell
calc & echo "test"
```

при выполнении оно изменяет значение первоначально заданного значения.

Теперь отображаются как приложение "Калькулятор", так и значение "тест".:

![CommandInjection](../assets/OS_Command_Injection_Defense_Cheat_Sheet_CmdInjection.png)

Проблема усугубляется, если скомпрометированный процесс не соответствует принципу наименьших привилегий, и команды, управляемые злоумышленником, в конечном итоге запускаются со специальными системными привилегиями, которые увеличивают размер ущерба.

### Инъекция аргумента

Каждое внедрение команды операционной системы также является введением аргумента. В этом типе атак пользовательский ввод может передаваться в качестве аргументов при выполнении определенной команды.

Например, если пользовательский ввод передается через функцию экранирования для экранирования определенных символов, таких как `&`, `|`, `;`, и т.д.

```php
system("curl " . escape($url));
```

что помешает злоумышленнику выполнить другие команды.

Однако, если строка, контролируемая злоумышленником, содержит дополнительный аргумент команды `curl`:

```
system("curl " . escape("--help"))
```

Теперь, когда приведенный выше код будет выполнен, он покажет выходные данные `curl --help`.

В зависимости от используемой системной команды последствия атаки с использованием аргументов могут варьироваться от **Раскрытия информации** до критического **Удаленного выполнения кода**.

## Основные варианты защиты

### Вариант защиты 1: Избегайте прямого вызова команд операционной системы

Основная защита заключается в том, чтобы избегать прямого вызова команд операционной системы. Встроенные библиотечные функции являются очень хорошей альтернативой командам операционной системы, поскольку ими нельзя манипулировать для выполнения задач, отличных от тех, для которых они предназначены.

Например, используйте `mkdir()` вместо `system("mkdir /dir_name")`.

Если для используемого вами языка имеются доступные библиотеки или API-интерфейсы, это предпочтительный метод.

### Вариант защиты 2: Экранирующие значения, добавленные к командам операционной системы, специфичным для каждой операционной системы

**TODO: To enhance.**

Примеры смотрите в [escapeshellarg()](https://www.php.net/manual/en/function.escapeshellarg.php) в PHP.

`escapeshellarg()` заключает пользовательский ввод в одинарные кавычки, поэтому, если неправильно сформированный пользовательский ввод - это что-то вроде `& echo "hello"`, конечный результат будет похож на `calc '& echo "hello"", который будет проанализирован как единственный аргумент команды `calc`.

Несмотря на то, что `escapeshellarg()` предотвращает внедрение команды операционной системы, злоумышленник все равно может передать команде один аргумент.

### Вариант защиты 3: Параметризация в сочетании с проверкой входных данных

Если невозможно избежать вызова системной команды, которая включает пользовательскую, в программном обеспечении следует использовать следующие два уровня защиты для предотвращения атак:

#### Слой 1

**Параметризация:** Если это возможно, используйте структурированные механизмы, которые автоматически обеспечивают разделение между данными и командой. Эти механизмы могут помочь обеспечить соответствующие кавычки и кодировку.

#### Слой 2

**Проверка вводимых данных:** Значения команд и соответствующие аргументы должны быть проверены. Существуют различные степени проверки для самой команды и ее аргументов:

- Когда дело доходит до используемых **команд**, они должны быть сверены со списком разрешенных команд.
- Что касается **аргументов**, используемых для этих команд, то они должны быть проверены с помощью следующих параметров:
    - **Проверка ввода Positive или allowlist**: Где явно определены разрешенные аргументы.
    - **Регулярное выражение Allowlist**: Содержит список допустимых символов и максимальную длину строки. Убедитесь, что метасимволы, подобные указанным в `примечании A`, и пробелы не являются частью регулярного выражения. Например, следующее регулярное выражение допускает использование только строчных букв и цифр и не содержит метасимволов. Длина также ограничена 3-10 символами: `^[a-z0-9]{3,10}$`
- В соответствии с **Руководящим принципом 10** этого [POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html), *Первый аргумент --, который не является аргументом option-, должен приниматься в качестве разделителя, указывающего на конец списка options. Любые следующие аргументы следует рассматривать как операнды, даже если они начинаются с символа "-".* Например, "curl -- $url" предотвратит ввод аргумента, даже если "$url" неправильно сформирован и содержит дополнительный аргумент.

**Примечание А:**

```text
& |  ; $ > < ` \ ! ' " ( )
```

## Дополнительные средства защиты

В дополнение к основным средствам защиты, параметризации и проверке вводимых данных мы также рекомендуем использовать все эти дополнительные средства защиты для обеспечения всесторонней защиты.

Эти дополнительные средства защиты:

- Приложения должны запускаться с минимальными привилегиями, необходимыми для выполнения необходимых задач.
- Если возможно, создайте изолированные учетные записи с ограниченными привилегиями, которые используются только для выполнения одной задачи.

## Примеры кода

### Java

В Java используйте [ProcessBuilder](https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html), и команда должна быть отделена от ее аргументов.

*Обратите внимание на поведение метода Java `Runtime.exec`:*

Есть много сайтов, которые расскажут вам, что `Runtime.exec` в Java точно такая же, как и системная функция `C`. Это не так. Обе они позволяют вызывать новую программу/процесс.

Однако системная функция `C` передает свои аргументы командной строке (`/bin/sh`) для анализа, тогда как `Runtime.exec' пытается разбить строку на массив слов, затем выполняет первое слово в массиве с остальными словами в качестве параметров.

**`Runtime.exec` ни в коем случае не пытается вызвать оболочку и не поддерживает метасимволы оболочки**.

Ключевое отличие заключается в том, что большая часть функциональных возможностей, предоставляемых оболочкой, которые могли бы быть использованы во вред (объединение команд в цепочку с помощью `&`, `&&`, `|`, `||`, и т.д., перенаправление ввода и вывода), просто в конечном итоге будут переданы в качестве параметра первой команде , что, вероятно, приведет к синтаксической ошибке или будет выброшено как недопустимый параметр.

*Код для проверки приведенного выше примечания:*

``` java
String[] specialChars = new String[]{"&", "&&", "|", "||"};
String payload = "cmd /c whoami";
String cmdTemplate = "java -version %s " + payload;
String cmd;
Process p;
int returnCode;
for (String specialChar : specialChars) {
    cmd = String.format(cmdTemplate, specialChar);
    System.out.printf("#### TEST CMD: %s\n", cmd);
    p = Runtime.getRuntime().exec(cmd);
    returnCode = p.waitFor();
    System.out.printf("RC    : %s\n", returnCode);
    System.out.printf("OUT   :\n%s\n", IOUtils.toString(p.getInputStream(),
                      "utf-8"));
    System.out.printf("ERROR :\n%s\n", IOUtils.toString(p.getErrorStream(),
                      "utf-8"));
}
System.out.printf("#### TEST PAYLOAD ONLY: %s\n", payload);
p = Runtime.getRuntime().exec(payload);
returnCode = p.waitFor();
System.out.printf("RC    : %s\n", returnCode);
System.out.printf("OUT   :\n%s\n", IOUtils.toString(p.getInputStream(),
                  "utf-8"));
System.out.printf("ERROR :\n%s\n", IOUtils.toString(p.getErrorStream(),
                  "utf-8"));
```

*Результат теста:*

```text
##### TEST CMD: java -version & cmd /c whoami
RC    : 0
OUT   :

ERROR :
java version "1.8.0_31"

##### TEST CMD: java -version && cmd /c whoami
RC    : 0
OUT   :

ERROR :
java version "1.8.0_31"

##### TEST CMD: java -version | cmd /c whoami
RC    : 0
OUT   :

ERROR :
java version "1.8.0_31"

##### TEST CMD: java -version || cmd /c whoami
RC    : 0
OUT   :

ERROR :
java version "1.8.0_31"

##### TEST PAYLOAD ONLY: cmd /c whoami
RC    : 0
OUT   :
mydomain\simpleuser

ERROR :
```

*Неправильное использование:*

```java
ProcessBuilder b = new ProcessBuilder("C:\DoStuff.exe -arg1 -arg2");
```

В этом примере команда вместе с аргументами передается в виде одной строки, что упрощает манипулирование этим выражением и внедрение вредоносных строк.

*Правильное использование:*

Вот пример, который запускает процесс с измененным рабочим каталогом. Команда и каждый из аргументов передаются отдельно. Это упрощает проверку каждого условия и снижает риск вставки вредоносных строк.

``` java
ProcessBuilder pb = new ProcessBuilder("TrustedCmd", "TrustedArg1", "TrustedArg2");

Map<String, String> env = pb.environment();

pb.directory(new File("TrustedDir"));

Process p = pb.start();
```

### .Net

Смотрите соответствующие подробности в [Шпаргалке по безопасности DotNet](DotNet_Security_Cheat_Sheet.md#os-injection).

### PHP

В PHP используйте [escapeshellarg()](https://www.php.net/manual/en/function.escapeshellarg.php) или [escapeshellcmd()](https://www.php.net/manual/en/function.escapeshellcmd.php) вместо [exec()](https://www.php.net/manual/en/function.exec.php), [system()](https://www.php.net/manual/en/function.system.php), [passthru()](https://www.php.net/manual/en/function.passthru.php).

## Статьи по теме

### Описание уязвимости при внедрении команд

- OWASP [Command Injection](https://owasp.org/www-community/attacks/Command_Injection).

### Как избежать уязвимостей

- Кодирование на C: [Не вызывайте system()](https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177).

### Как просмотреть код

- OWASP [Проверка кода для внедрения в операционную систему](https://wiki.owasp.org/index.php/Reviewing_Code_for_OS_Injection).

### Как протестировать

- [Руководство по тестированию OWASP](https://owasp.org/www-project-web-security-testing-guide/) статья о [тестировании для команд Injection](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/12-Testing_for_Command_Injection.html).

### Внешние ссылки

- [CWE Entry 77 on Command Injection](https://cwe.mitre.org/data/definitions/77.html).
