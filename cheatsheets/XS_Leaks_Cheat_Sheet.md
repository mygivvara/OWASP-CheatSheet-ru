# Шпаргалка по межсайтовым утечкам

## Вступление

В этой статье описаны примеры атак и средств защиты от уязвимости, связанной с межсайтовыми утечками (XS Leaks). Поскольку эта уязвимость основана на основном механизме современных веб-браузеров, ее также называют атакой по стороннему каналу браузера. Атаки XS-Leaks направлены на использование, казалось бы, незначительной информации, которой обмениваются в ходе межсайтовых коммуникаций между сайтами. Эта информация содержит ответы на ранее заданные вопросы об учетной записи пользователя жертвы. Пожалуйста, ознакомьтесь с примерами, представленными ниже:

- Залогинин ли пользователь в данный момент?
- Идентификатор пользователя 1337?
- Является ли пользователь администратором?
- Есть ли у пользователя в списке контактов человек с определенным адресом электронной почты?

На основе таких вопросов злоумышленник может попытаться получить ответы в зависимости от контекста приложения. В большинстве случаев ответы будут в двоичной форме ("да" или "нет"). Воздействие этой уязвимости сильно зависит от профиля риска приложения. Несмотря на это, утечки данных XS могут представлять реальную угрозу конфиденциальности и анонимности пользователей.

## Вектор атаки

![Вектор атаки XS-утечек](../assets/XS_Attack_Vector.png)

- Вся атака выполняется на стороне браузера жертвы - так же, как и XSS-атака
- В некоторых случаях жертва должна оставаться на сайте злоумышленника дольше, чтобы атака была успешной.

## Same Origin Policy (SOP) Политика одинакового происхождения 

Прежде чем описывать атаки, полезно разобраться с одним из наиболее важных механизмов безопасности в браузерах - политикой одинакового источника. Несколько ключевых аспектов:

- Два URL-адреса считаются ** одного происхождения**, если их **протокол**, **порт** и **хост** совпадают
- Любой источник может отправить запрос другому источнику, но из-за политики того же источника они не смогут прочитать ответ напрямую
- Политика того же источника может быть смягчена с помощью [Совместного использования ресурсов разных источников Cross Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).

| Происхождение A            | Происхождение B                 | Того же происхождения?                 |
| -------------         | -------------             | -------------                  |
| `https://example.com` | `http://sub.example.com`  | Нет, разные хосты             |
| `https://example.com` | `https://example.com:443` | Да! Неявный порт в Происхождении A|

Хотя принцип SOP защищает нас от доступа к информации при передаче данных из одного источника в другой, атаки XS-Leaks, основанные на остаточных данных, могут вывести некоторую информацию.

## Кукки с атрибутом SameSite

Атрибут SameSite в файле cookie сообщает браузеру, должен ли он включать файл cookie в запрос с другого сайта. Атрибут SameSite принимает следующие значения:

- `None` - cookie будет прикреплен к запросу с другого сайта, но он должен быть отправлен по защищенному каналу HTTPS
- `Lax` - cookie будет добавлен к запросу с другой страницы, если методом запроса является GET и запрос выполняется для навигации верхнего уровня (т.е. при навигации изменяется адрес в верхней строке браузера).
- `Strict` - cookie никогда не будет отправлен с другого сайта

Здесь стоит упомянуть отношение браузеров на базе Chromium, в которых файлы cookie без того же атрибута сайта, установленного по умолчанию, рассматриваются как Lax.

SameSite атрибут куки это мощный механизм **углубленной защиты** от **некоторых**  классов утечек XS и [CSRF атак](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html), что может значительно сократить площадь атаки, но не может полностью ее сократить (см., например, [window-based XS Leak](https://soheilkhodayari.github.io/same-site-wiki/docs/attacks/xs-leaks.html) атаки, такие как [frame counting](https://xsleaks.dev/docs/attacks/frame-counting/) и [navigation](https://xsleaks.dev/docs/attacks/navigations/)).

### Откуда мы знаем, что два сайта - это один и тот же сайт?

![Объяснение утечек XS в eTLD](../assets/XS_Leaks_eTLD.png)

В контексте того же атрибута сайта мы рассматриваем сайт как комбинацию TLD (домена верхнего уровня) и доменного имени, стоящего перед ним. Например:

| Полный URL                                      | Сайт (eTLD+1)             |
| --------------------------------------------  | ------------------------  |
| `https://example.com:443/data?query=test`     | `example.com`             |

Почему мы говорим о eTLD+1, а не только о TLD+1? Это из-за таких доменов, как ".github.io` или `.eu.org`. Такие части недостаточно атомарны, чтобы их можно было хорошо сравнивать. По этой причине был создан список "действующих" доменов верхнего уровня (TLD), с которым можно ознакомиться [здесь](https://publicsuffix.org/list/public_suffix_list.dat).

Сайты, имеющие один и тот же eTLD+1, считаются одним и тем же сайтом, примеры:

| Происхождение А           | Происхождение B            | SameSite?                    |
| ------------------------- | -------------------------- | ---------------------        |
| `https://example.com`     | `http://example.com`       | Да, схемы не имеют значения    |
| `https://evil.net`        | `https://example.com`      | Нет, другой eTLD+1          |
| `https://sub.example.com` | `https://data.example.com` | Да, поддомены не имеют значения |

Для получения дополнительной информации об этом сайте смотрите отличную статью [Понимание понятия "same-site"](https://web.dev/same-site-same-origin/).

## Атаки с использованием атрибута element ID

Элементы в DOM могут иметь атрибут ID, который является уникальным в пределах документа. Например:

```html
<button id="pro">Pro account</button>
```

Браузер автоматически сфокусируется на элементе с заданным идентификатором, если мы добавим хэш к URL, например, `https://example.com#pro`. Более того, запускается JavaScript [focus event](https://developer.mozilla.org/en-US/docs/Web/API/Element/focus_event). Злоумышленник может попытаться внедрить приложение в iframe с определенным источником на своей собственной контролируемой странице:

![XS-Leaks-ID](../assets/XS_Leaks_ID.png)

Затем добавьте прослушиватель в основной документ для [blur event](https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event) (противоположность фокусу). Когда жертва посещает сайт злоумышленников, запускается событие размытия. Злоумышленник сможет сделать вывод, что у жертвы есть учетная запись pro.

### Защита

#### Защита кадра

Если вам не нужны другие источники для встраивания вашего приложения во фрейм, вы можете рассмотреть возможность использования одного из двух механизмов:

- **Content Security Policy предки фрейма** директива. [Узнайте больше о синтаксисе](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-src).
- **X-Frame-Options** - в основном, если вы хотите поддерживать старые браузеры.

Настройка защиты от фрейминга эффективно блокирует возможность встраивания вашего приложения во фрейм в источнике, контролируемом злоумышленником, и защищает от других атак, таких как [Clickjacking](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html).

#### Выборка метаданных (Sec-Fetch-Dest)

Заголовок Sec-Fetch-Dest предоставляет нам информацию о том, какова конечная цель запроса. Этот заголовок автоматически включается браузером и является одним из заголовков в стандарте Fetch Metadata.

С помощью Sec-Fetch-Dest вы можете создавать эффективные собственные политики изоляции ресурсов, например:

```javascript
app.get('/', (req, res) => {
    if (req.get('Sec-Fetch-Dest') === 'iframe') {
        return res.sendStatus(403);
    }
    res.send({
        message: 'Hello!'
    });
});
```

![XS утечки Sec-Fetch-Dest](../assets/XS_Leaks_Sec_Fetch_Dest.png)

Если вы хотите использовать заголовки из стандарта Fetch Metadata, убедитесь, что браузеры ваших пользователей поддерживают этот стандарт (вы можете проверить это [здесь](https://caniuse.com/?search=sec-fetch)).  Кроме того, подумайте об использовании соответствующего резервного варианта в коде, если заголовок Sec-Fetch-* не включен в запрос.

## Атаки, основанные на событиях ошибки

Использование ресурсов из других источников, как правило, разрешено. Например, вы можете вставить изображение из другого источника или даже сценарий на свою страницу. Что запрещено, так это чтение ресурсов из разных источников из-за политики SOP.

Когда браузер отправляет запрос на ресурс, сервер обрабатывает запрос и принимает решение об ответе, например (200 ОК или 404 НЕ НАЙДЕНО). Браузер получает HTTP-ответ, и на основании этого запускается соответствующее событие JavaScript (onload или onerror).

Таким образом, мы можем попытаться загрузить ресурсы и, основываясь на статусе ответа, определить, существуют они или нет в контексте жертвы, вошедшей в систему. Давайте рассмотрим следующую ситуацию:

- `GET /api/user/1234` - 200 OK - в настоящее время зарегистрированный пользователь - 1234, потому что мы успешно загрузили ресурс ([onload](https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload) event fired)
- `GET /api/user/1235` - 401 Unauthorized  - 1235 - это не идентификатор текущего пользователя, вошедшего в систему ([onerror](https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror) event will be triggered)

Учитывая приведенный выше пример, злоумышленник может использовать JavaScript в своем контролируемом источнике, чтобы угадать идентификатор жертвы, перебирая все значения в простом цикле.

```javascript
function checkId(id) {
    const script = document.createElement('script');
    script.src = `https://example.com/api/users/${id}`;
    script.onload = () => {
        console.log(`Logged user id: ${id}`);
    };
    document.body.appendChild(script);
}

// Generate array [0, 1, ..., 40]
const ids = Array(41)
    .fill()
    .map((_, i) => i + 0);

for (const id of ids) {
    checkId(id);
}
```

Обратите внимание, что злоумышленник в данном случае не заботится о чтении текста ответа, даже если он не смог бы этого сделать из-за надежных механизмов изоляции в браузерах, таких как [Cross-Origin Resource Blocking](https://www.chromium.org/Home/chromium-security/corb-for-developers). Все, что ему нужно - это информация об успешном завершении, которую он получает, когда срабатывает событие `onload`.

### Защита

#### Защита субресурсов

В некоторых случаях для защиты наших конфиденциальных конечных точек может быть реализован механизм специальных уникальных токенов.

```
/api/users/1234?token=be930b8cfb5011eb9a030242ac130003
```

- Токен должен быть длинным и уникальным
- Серверная часть должна правильно подтвердить токен, переданный в запросе

Несмотря на то, что это довольно эффективное решение, при его правильной реализации возникают значительные накладные расходы.

#### Извлечение метаданных (Sec-Fetch-Site)

Этот заголовок указывает, откуда был отправлен запрос, и принимает следующие значения:

- `cross-site`
- `same-origin`
- `same-site`
- `none` - пользователь напрямую перешел на страницу

Как и Sec-Fetch-Dest, этот заголовок автоматически добавляется браузером к каждому запросу и является частью стандарта Fetch Metadata. Пример использования:

```javascript
app.get('/api/users/:id', authorization, (req, res) => {
    if (req.get('Sec-Fetch-Site') === 'cross-site') {
        return res.sendStatus(403);
    }

    // ... more code

    return res.send({ id: 1234, name: 'John', role: 'admin' });
});
```

#### Cross-Origin-Resource-Policy (CORP) Политика в отношении перекрестного происхождения ресурсов

Если сервер вернет этот заголовок с соответствующим значением, браузер не будет загружать ресурсы с нашего сайта или источника (даже статические изображения) в другое приложение. Возможные значения:

- `same-site`
- `same-origin`
- `cross-origin`

Узнайте больше о CORP [здесь](https://resourcepolicy.fyi/).

## Атаки на почтовые сообщения

Иногда в контролируемых ситуациях нам хотелось бы, несмотря на SOP, обмениваться информацией между разными источниками. Мы можем использовать механизм почтовых сообщений. Смотрите пример ниже:

```javascript
// Origin: http://example.com
const site = new URLSearchParams(window.location.search).get('site'); // https://evil.com
const popup = window.open(site);
popup.postMessage('secret message!', '*');

// Origin: https://evil.com
window.addEventListener('message', e => {
    alert(e.data) // secret message! - leak
});
```

### Защита

#### Укажите строгий целевой параметр Origin

Чтобы избежать ситуаций, подобных описанной выше, когда злоумышленнику удается получить ссылку на окно для получения сообщения, всегда указывайте точный `targetOrigin` в postMessage. Переход к подстановочному знаку `targetOrigin` `*` приводит к тому, что сообщение получает любой источник.

```javascript
// Origin: http://example.com
const site = new URLSearchParams(window.location.search).get('site'); // https://evil.com
const popup = window.open(site);
popup.postMessage('secret message!', 'https://sub.example.com');

// Origin: https://evil.com
window.addEventListener('message', e => {
    alert(e.data) // no data!
});
```

## Атаки с подсчетом кадров

Информация о количестве загруженных кадров в окне может быть источником утечки. Возьмем, к примеру, приложение, которое загружает результаты поиска во фрейм, если результаты пустые, то фрейм не отображается.

![XS-Leaks-Frame-Counting](../assets/XS_Leaks_Frame_Counting.png)

Злоумышленник может получить информацию о количестве загруженных кадров в окне, подсчитав количество кадров в объекте `window.frames`.

Таким образом, злоумышленник может получить список адресов электронной почты и, используя простой цикл, открывать последующие окна и подсчитывать количество кадров. Если количество кадров в открывшемся окне равно 1, электронное письмо находится в клиентской базе данных приложения, используемого жертвой.

### Защита

#### Cross-Origin-Opener-Policy (COOP) Политика перекрестного доступа

Установка этого заголовка предотвратит открытие документов из разных источников в одной и той же группе контекстов просмотра. Это решение гарантирует, что документ А, открывающий другой документ, не будет иметь доступа к объекту `window`. Возможные значения:

- `unsafe-none`
- `same-origin-allow-popups`
- `same-origin`

В случае, если сервер возвращает, например, COOP заголовок `same-origin` атака завершается неудачей:

```javascript
const win = window.open('https://example.com/admin/customers?search=john%40example.com');
console.log(win.frames.length) // Cannot read property 'length' of null
```

## Атаки с использованием кэша браузера

Кэш браузера помогает значительно сократить время, необходимое для загрузки страницы при повторном просмотре. Однако он также может создавать риск утечки информации. Если злоумышленник сможет определить, был ли ресурс загружен из кэша по истечении времени загрузки, он сможет сделать на его основе некоторые выводы.

Принцип прост, ресурс, загруженный из кэш-памяти, будет загружаться несравнимо быстрее, чем с сервера.

![Атака на утечку кэша XS](../assets/XS_Leaks_Cache_Attack.png)

Злоумышленник может внедрить на свой сайт ресурс, доступный только пользователю с ролью администратора. Затем, используя JavaScript, считывает время загрузки определенного ресурса и, основываясь на этой информации, определяет, находится ли ресурс в кэше или нет.

```javascript
    // Threshold above which we consider a resource to have loaded from the server
    // const THRESHOLD = ...

    const adminImagePerfEntry = window.performance
        .getEntries()
        .filter((entry) => entry.name.endsWith('admin.svg'));

    if (adminImagePerfEntry.duration < THRESHOLD) {
        console.log('Image loaded from cache!')
    }
```

### Защита

#### Непредсказуемые токены для изображений

Этот метод эффективен, когда пользователь хочет, чтобы ресурсы по-прежнему оставались в кэше, в то время как злоумышленник не сможет узнать об этом.

```
/avatars/admin.svg?token=be930b8cfb5011eb9a030242ac130003
```

- Токены должны быть уникальными в контексте каждого пользователя
- Если злоумышленник не сможет угадать этот токен, он не сможет определить, был ли ресурс загружен из кэша

#### Использование заголовка Cache-Control 

Вы можете отключить механизм кэширования, если согласны с ухудшением производительности, связанным с необходимостью перезагрузки ресурсов с сервера при каждом посещении сайта пользователем. Чтобы отключить кэширование ресурсов, которые вы хотите защитить, задайте заголовок ответа `Cache-Control: no-store`.

## Краткие рекомендации

- Если ваше приложение использует файлы cookie, обязательно установите соответствующий [атрибут SameSite](#samesite-cookies).
- Подумайте, действительно ли вы хотите, чтобы ваше приложение было встроено во фреймы. Если нет, рассмотрите возможность использования механизмов, описанных в разделе [защита от фрейминга] (#framing-protection).
- Чтобы усилить изоляцию вашего приложения от других источников, используйте заголовки [Политика использования ресурсов разных источников] (#cross-origin-resource-policy-corp) и [Политика использования ресурсов разных источников] (#cross-origin-opener-policy-coop) с соответствующими значениями.
- Используйте заголовки, доступные в метаданных Fetch, чтобы создать свою собственную политику изоляции ресурсов.

## Рекомендации

### Утечки XS

- [XS Leaks Wiki](https://xsleaks.dev/)
- [XS Leaks Attacks & Prevention](https://www.appsecmonkey.com/blog/xs-leaks)

### Извлечение метаданных

- [Извлечение метаданных и политики изоляции](https://www.appsecmonkey.com/blog/fetch-metadata)
- [Защитите свои ресурсы от атак с помощью извлечения метаданных](https://web.dev/fetch-metadata/)

### Защита кадра

- [Предотвращение формирования структуры с помощью политик](https://pragmaticwebsecurity.com/articles/securitypolicies/preventing-framing-with-policies.html)
- [Политика CSP "фрейм-предки"](https://content-security-policy.com/frame-ancestors/)

### SameSite

- [Объясненные SamaSite cookie](https://web.dev/samesite-cookies-explained/)
- [Словарь SameSite cookies recipes](https://web.dev/samesite-cookie-recipes/)

### Заголовки COOP и CORP 

- [Сделать ваш сайт "изолированным от других источников"](https://web.dev/coop-coep/)
- [Веб-документы MDN о CORP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cross-Origin_Resource_Policy_%28CORP%29)
