# Шпаргалка для хранения паролей

## Вступление

В этой шпаргалке вы найдете рекомендации по надлежащим методам хранения паролей для аутентификации. Когда пароли хранятся, они должны быть защищены от злоумышленников, даже если приложение или база данных скомпрометированы. К счастью, большинство современных языков и платформ предоставляют встроенные функции, помогающие безопасно хранить пароли.

Однако, как только злоумышленник заполучит сохраненные хэши паролей, он всегда сможет взломать их в автономном режиме. Защитники могут замедлить атаки в автономном режиме, выбрав максимально ресурсоемкие алгоритмы хэширования.

Подводя итог нашим рекомендациям:

- **Используйте [Argon 2 id](#argon2id) с минимальной конфигурацией в 19 Мб памяти, числом итераций 2 и степенью параллелизма 1.**
- **Если [Argon2id](#argon2id) недоступен, используйте [scrypt](#scrypt) с параметром минимальной стоимости процессора/памяти, равным (2^17), минимальным размером блока 8 (1024 байта) и параметром распараллеливания, равным 1.**
- **Для устаревших систем, использующих [bcrypt](#bcrypt), используйте коэффициент полезного действия, равный 10 или более, и ограничение по паролю в 72 байта.**
- **Если требуется соответствие стандарту FIPS-140, используйте [PBKDF2](#pbkdf2) с рабочим коэффициентом 600 000 или более и настройте его с помощью внутренней хэш-функции HMAC-SHA-256.**
- **Рассмотрите возможность использования [pepper] (#перчинка) для обеспечения дополнительной глубокой защиты (хотя само по себе оно не обеспечивает дополнительных защитных характеристик).**

## Бэкграунд

### Хэширование против шифрования

Хэширование и шифрование могут обеспечить безопасность конфиденциальных данных, но почти при любых обстоятельствах **пароли следует хэшировать, а не шифровать.**

Поскольку **хэширование - это односторонняя функция** (т.е. невозможно "расшифровать" хэш и получить исходное текстовое значение), это наиболее подходящий подход для проверки пароля. Даже если злоумышленник получит хэшированный пароль, он не сможет использовать его для входа в систему в качестве жертвы.

Поскольку **шифрование является двусторонней функцией**, злоумышленники могут извлечь исходный открытый текст из зашифрованных данных. Его можно использовать для хранения таких данных, как адрес пользователя, поскольку эти данные отображаются в виде открытого текста в профиле пользователя. Хеширование их адреса привело бы к искажению информации.

 Шифрование паролей следует использовать только в крайних случаях, когда необходимо получить исходный текстовый пароль. Это может быть необходимо, если приложению необходимо использовать пароль для аутентификации в другой системе, которая не поддерживает современный способ программного предоставления доступа, такой как OpenID Connect (OIDC). Везде, где это возможно, следует использовать альтернативную архитектуру, чтобы избежать необходимости хранить пароли в зашифрованном виде.

Дополнительные указания по шифрованию приведены в [Шпаргалке по криптографическому хранилищу](Cryptographic_Storage_Cheat_Sheet.md).

### Когда Хэши Паролей Могут Быть Взломаны

**Взломать надежные пароли, сохраненные с использованием современных алгоритмов хеширования и лучших практик в области хеширования, злоумышленнику практически невозможно.** Выбор современного алгоритма хеширования является вашей ответственностью как владельца приложения.

Однако существуют некоторые ситуации, когда злоумышленник может "взломать" хэши при определенных обстоятельствах, выполнив следующие действия:

- Выбор пароля, который, по вашему мнению, выбрала жертва (например, "пароль 1!")
- Вычисление хэша
- Сравнение вычисленного вами хэша с хэшем жертвы. Если они совпадают, вы правильно "взломали" хэш и теперь знаете текстовое значение их пароля.

Обычно злоумышленник повторяет этот процесс со списком из большого количества потенциальных паролей-кандидатов, таких как:

- Списки паролей, полученных с других взломанных сайтов
- Перебор (перебор всех возможных вариантов)
- Словари или списки словосочетаний для распространенных паролей

Несмотря на то, что количество перестановок может быть огромным, при наличии высокоскоростного оборудования (такого как графические процессоры) и облачных сервисов с большим количеством арендуемых серверов затраты злоумышленника на успешный взлом паролей относительно невелики, особенно если не соблюдаются рекомендации по хешированию.

## Методы улучшения хранения паролей

### Salting

Соль (Salt) - это уникальная, случайно сгенерированная строка, которая добавляется к каждому паролю в процессе хэширования. Поскольку соль уникальна для каждого пользователя, злоумышленнику приходится взламывать хэши по одному, используя соответствующую соль, а не вычислять хэш один раз и сравнивать его с каждым сохраненным хэшем. Это значительно усложняет взлом большого количества хэшей, поскольку требуемое время растет прямо пропорционально количеству хэшей.

Соление также защищает от предварительного вычисления хэшей злоумышленником с использованием радужных таблиц или поиска в базе данных. Наконец, соление означает, что невозможно определить, есть ли у двух пользователей один и тот же пароль, не взломав хэши, поскольку разные соли приведут к разным хэшам, даже если пароли совпадают.

[Современные алгоритмы хэширования](#password-hashing-algorithms), такие как Argon 2 id, bcrypt и PBKDF2, автоматически преобразуют пароли в соль, поэтому при их использовании не требуется никаких дополнительных действий.

### Peppering

В дополнение к солению можно использовать [papper](https://www.ietf.org/archive/id/draft-ietf-kitten-password-storage-04.html#section-4.2), чтобы обеспечить дополнительный слой защиты. Это лишает злоумышленника возможности взломать любой из хэшей, если у него есть доступ только к базе данных, например, если он воспользовался уязвимостью SQL-инъекции или получил резервную копию базы данных. Стратегии перчинга никоим образом не влияют на функцию хэширования паролей.

Например, одна из стратегий peppering заключается в обычном хэшировании паролей (с использованием алгоритма хэширования паролей), а затем в использовании HMAC (например, HMAC-SHA256, HMAC-SHA512, в зависимости от желаемой длины вывода) для исходного хэша пароля перед сохранением хэша пароля в базе данных, при этом pepper выполняет функцию pepper. как ключ HMAC.

- Pepper **используется совместно между сохраненными паролями**, а не является *уникальным*, как salt.
- В отличие от salt для паролей, pepper **не должен храниться в базе данных**.
- Peppers являются секретными и должны храниться в "хранилищах секретов" или HSM (аппаратных модулях безопасности). Смотрите [Шпаргалку по управлению секретами](Secrets_Management_Cheat_Sheet.md) для получения дополнительной информации о безопасном хранении секретов.
- Как и в случае с любым другим криптографическим ключом, следует учитывать стратегию ротации pepper.

### Использование рабочих факторов

 Коэффициент полезного действия - это количество итераций алгоритма хэширования, которые выполняются для каждого пароля (обычно это "2 ^ рабочие" итерации). Коэффициент полезного действия обычно сохраняется в выходных данных хэша. Это делает вычисление хэша более затратным с точки зрения вычислений, что, в свою очередь, снижает скорость и/или увеличивает затраты, за которые злоумышленник может попытаться взломать хэш пароля.

Выбирая коэффициент полезного действия, соблюдайте баланс между безопасностью и производительностью. Хотя более высокие коэффициенты полезного действия затрудняют взлом хэшей злоумышленником, они замедляют процесс проверки попытки входа в систему. Если коэффициент полезного действия слишком высок, производительность приложения может снизиться, что может быть использовано злоумышленником для проведения атаки типа "отказ в обслуживании", изматывающей центральный процессор сервера большим количеством попыток входа в систему.

Не существует золотого правила для определения оптимального коэффициента полезного действия - он будет зависеть от производительности сервера и количества пользователей в приложении. Определение оптимального коэффициента полезного действия потребует экспериментов на конкретных серверах, используемых приложением. Как правило, вычисление хэша должно занимать менее одной секунды.

#### Повышение коэффициента полезного действия

Одним из ключевых преимуществ наличия коэффициента полезного действия является то, что он может быть увеличен с течением времени по мере того, как оборудование становится более мощным и дешевым.

Наиболее распространенный подход к обновлению work factor заключается в том, чтобы дождаться следующей аутентификации пользователя, а затем повторно использовать его пароль с новым work factor. Разные хэши будут иметь разные рабочие факторы, и хэши могут никогда не обновляться, если пользователь не выполнит повторный вход в приложение. В зависимости от приложения может оказаться целесообразным удалить старые хэши паролей и потребовать от пользователей сбросить свои пароли при следующем входе в систему, чтобы избежать сохранения старых и менее безопасных хэшей.

## Алгоритмы хэширования паролей

Некоторые современные алгоритмы хеширования были специально разработаны для безопасного хранения паролей. Это означает, что они должны быть медленными (в отличие от таких алгоритмов, как MD5 и SHA-1, которые были разработаны как быстрые), и вы можете изменить их скорость, изменив коэффициент полезного действия.

Вам не нужно скрывать, какой алгоритм хэширования паролей используется приложением. Если вы используете современный алгоритм хэширования паролей с надлежащими параметрами конфигурации, должно быть безопасно публично указывать, какие алгоритмы хэширования паролей используются, и указывать их [здесь](https://pulse.michalspacek.cz/passwords/storages).

Три алгоритма хеширования, которые следует учитывать:

### Argon2id

[Argon 2](https://en.wikipedia.org/wiki/Argon 2) стал победителем конкурса 2015 года [по хэшированию паролей](https://en.wikipedia.org/wiki/Password_Hashing_Competition). Из трех версий Argon 2 используйте вариант Argon2id, поскольку он обеспечивает сбалансированный подход к защите как от атак по сторонним каналам, так и от атак на основе графического процессора.

В отличие от других алгоритмов, Argon2id имеет три различных параметра, которые можно настроить: базовый минимум минимального объема памяти (m), минимальное количество итераций (t) и степень параллелизма (p). Мы рекомендуем использовать следующие параметры конфигурации:

- m=47104 (46 MiB), t=1, p=1 (Do not use with Argon2i)
- m=19456 (19 MiB), t=2, p=1 (Do not use with Argon2i)
- m=12288 (12 MiB), t=3, p=1
- m=9216 (9 MiB), t=4, p=1
- m=7168 (7 MiB), t=5, p=1

Эти параметры конфигурации обеспечивают одинаковый уровень защиты, и единственное различие заключается в балансе между использованием процессора и оперативной памяти.

### scrypt

[script](http://www.tarsnap.com/scrypt/scrypt.pdf) - это функция получения ключа на основе пароля, созданная [Колином Персивалем](https://twitter.com/cperciva). В то время как [Argon2id](#argon2id) должен быть лучшим выбором для хэширования паролей, [scrypt](#scrypt) следует использовать, когда первый недоступен.

Как и [Argon2id](#argon2id), scrypt имеет три различных параметра, которые можно настроить: параметр минимальной стоимости процессора/памяти (N), размер блока (r) и степень параллелизма (p). Используйте одну из следующих настроек:

- N=2^17 (128 MiB), r=8 (1024 bytes), p=1
- N=2^16 (64 MiB), r=8 (1024 bytes), p=2
- N=2^15 (32 MiB), r=8 (1024 bytes), p=3
- N=2^14 (16 MiB), r=8 (1024 bytes), p=5
- N=2^13 (8 MiB), r=8 (1024 bytes), p=10

Эти параметры конфигурации обеспечивают одинаковый уровень защиты. Единственное различие заключается в соотношении использования процессора и оперативной памяти.

### bcrypt

Функция хэширования паролей [bcrypt](https://en.wikipedia.org/wiki/bcrypt) должна быть наилучшим выбором для хранения паролей в устаревших системах или если для обеспечения соответствия требованиям FIPS-140 требуется PBKDF2.

Коэффициент полезного действия должен быть настолько большим, насколько позволяет производительность сервера верификации, но не менее 10.

#### Ограничения на ввод данных в bcrypt

максимальная длина ввода в bcrypt составляет 72 байта [для большинства случаев implementations](https://security.stackexchange.com/questions/39849/does-bcrypt-have-a-maximum-password-length), поэтому вам следует установить максимальную длину пароля в 72 байта (или меньше, если используемая реализация bcrypt имеет меньшие ограничения).

#### Предварительное хэширование паролей с помощью bcrypt

Альтернативный подход заключается в предварительном хэшировании введенного пользователем пароля с помощью быстрого алгоритма, такого как SHA-256, а затем в хэшировании полученного хэша с помощью bcrypt (т.е. `bcrypt(base64(hmac-sha256(данные:$пароль, ключ:$перец)), $соль, $стоимость)`). Это опасная (но распространенная) практика, которой ** следует избегать ** из-за [смены пароля] (https://www.youtube.com/watch?v=OQD3qDYMyYQ) и других проблем при [объединении bcrypt с другими хэш-функциями](https://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html).

### PBKDF2

Поскольку [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2) рекомендован [NIST](https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver) и имеет реализации, подтвержденные FIPS-140, он должен быть предпочтительным алгоритмом, когда они требуются.

Алгоритм PBKDF2 требует, чтобы вы выбрали внутренний алгоритм хэширования, такой как HMAC, или множество других алгоритмов хэширования. HMAC-SHA-256 широко поддерживается и рекомендован NIST.

Коэффициент полезного действия для PBKDF2 реализуется с помощью счетчика итераций, который должен устанавливаться по-разному в зависимости от используемого внутреннего алгоритма хеширования.

- PBKDF2-HMAC-SHA1: 1,300,000 iterations
- PBKDF2-HMAC-SHA256: 600,000 iterations
- PBKDF2-HMAC-SHA512: 210,000 iterations

### Parallel PBKDF2

- PPBKDF2-SHA512: cost 2
- PPBKDF2-SHA256: cost 5
- PPBKDF2-SHA1: cost 10

Эти параметры конфигурации эквивалентны по защите, которую они обеспечивают. ([Количество по состоянию на декабрь 2022 года, основано на тестировании графических процессоров RTX 4000](https://tobtu.com/minimum-password-settings/))

#### PBKDF2 Pre-Hashing

Когда PBKDF2 используется с HMAC, а длина пароля превышает размер блока хэш-функции (64 байта для SHA-256), пароль будет автоматически предварительно хэширован. Например, пароль "Длина этого пароля превышает 512 бит, что соответствует размеру блока SHA-256" преобразуется в хэш-значение (в шестнадцатеричном формате): `fa91498c139805af73f7ba275cca071e78d78675027000c99a9925e2ec92eedd`.

Хорошие реализации PBKDF2 выполняют предварительное хэширование перед дорогостоящей итерационной фазой хэширования. Однако некоторые реализации выполняют преобразование на каждой итерации, что может сделать хэширование длинных паролей значительно более дорогостоящим, чем хэширование коротких паролей. Когда пользователи вводят очень длинные пароли, может возникнуть потенциальная уязвимость типа "отказ в обслуживании", подобная той, что была опубликована в [Django](https://www.djangoproject.com/weblog/2013/sep/15/security/) в 2013 году. Предварительная промывка вручную может снизить этот риск, но требует добавления [соли] (#засолки) на этапе подготовки к окрошке.

## Обновление устаревших хэшей

Старые приложения, использующие менее безопасные алгоритмы хэширования, такие как MD5 или SHA-1, могут быть обновлены до современных алгоритмов хэширования паролей, как описано выше. Когда пользователи вводят свой пароль (обычно путем аутентификации в приложении), этот ввод должен быть повторно хэширован с использованием нового алгоритма. Защитники должны истечь срок действия текущего пароля пользователя и потребовать от него ввести новый, чтобы любые старые (менее защищенные) хэши их пароля больше не были полезны злоумышленнику.

Однако это означает, что старые (менее защищенные) хэши паролей будут храниться в базе данных до тех пор, пока пользователь не войдет в систему. Вы можете воспользоваться одним из двух подходов, чтобы избежать этой дилеммы.

Способ обновления первый: истечение срока действия и удаление хэшей паролей пользователей, которые были неактивны в течение длительного периода времени, и требуется, чтобы они сбросили свои пароли для повторного входа в систему. Несмотря на безопасность, этот подход не особенно удобен для пользователя. Истечение срока действия паролей многих пользователей может вызвать проблемы у сотрудников службы поддержки или может быть истолковано пользователями как признак взлома.

Второй способ обновления: Используйте существующие хэши паролей в качестве входных данных для более безопасного алгоритма. Например, если приложение изначально хранило пароли как `md5($password)`, его можно легко обновить до `bcrypt(md5($password))`. Разбивка хэшей на уровни позволяет избежать необходимости знать исходный пароль, однако это может упростить взлом хэшей. Эти хэши следует заменить прямыми хэшами паролей пользователей при следующем входе в систему.

Помните, что как только вы выберете метод хэширования паролей, в будущем его необходимо будет обновить, поэтому убедитесь, что обновление алгоритма хэширования будет максимально простым. В течение переходного периода используйте как старые, так и новые алгоритмы хэширования. Использование комбинации алгоритмов хэширования упрощается, если алгоритм хэширования пароля и коэффициент полезного действия хранятся вместе с паролем в стандартном формате, например, [модульный формат строк PHC](https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md).

### Международные символы

Ваша библиотека хэширования должна быть способна принимать широкий спектр символов и должна быть совместима со всеми кодовыми обозначениями Unicode, чтобы пользователи могли использовать весь спектр символов, доступных на современных устройствах, особенно на мобильных клавиатурах. Они должны уметь выбирать пароли на разных языках и включать пиктограммы. Перед хэшированием энтропия пользовательской записи не должна уменьшаться, и библиотеки хэширования паролей должны иметь возможность использовать входные данные, которые могут содержать нулевой байт.
