# Шпаргалка по аутентификации

## Введение

**Аутентификация** (**AuthN**) — это процесс проверки того, что человек, сущность или веб-сайт являются тем, кем или чем они заявляют, путем определения подлинности одного или нескольких аутентификаторов (таких как пароли, отпечатки пальцев или токены безопасности), используемых для подтверждения этого утверждения.

**Цифровая идентификация** — это уникальное представление субъекта, участвующего в онлайн-транзакции. Цифровая идентификация всегда уникальна в контексте цифровой услуги, но не обязательно должна отслеживаться до конкретного субъекта в реальной жизни.

**Подтверждение личности** устанавливает, что субъект действительно является тем, за кого себя выдает. Эта концепция связана с KYC (Know Your Customer, «Знай своего клиента») и направлена на связывание цифровой идентификации с реальным человеком.

**Управление сессией** — это процесс, с помощью которого сервер поддерживает состояние сущности, взаимодействующей с ним. Это необходимо для того, чтобы сервер "запомнил", как реагировать на последующие запросы в течение всей транзакции. Сессии поддерживаются на сервере с помощью идентификатора сессии, который может передаваться между клиентом и сервером при отправке и получении запросов. Сессии должны быть уникальны для каждого пользователя и вычислительно сложными для предсказания. В [Шпаргалке по управлению сессиями](Session_Management_Cheat_Sheet.md) содержатся дополнительные рекомендации по лучшим практикам в этой области.

## Общие рекомендации по аутентификации

### Идентификаторы пользователей

Основная функция идентификатора пользователя — уникально идентифицировать пользователя в системе. В идеале, идентификаторы пользователей должны генерироваться случайным образом, чтобы предотвратить создание предсказуемых или последовательных идентификаторов, что может представлять угрозу безопасности, особенно в системах, где идентификаторы пользователей могут быть раскрыты или выведены из внешних источников.

### Имена пользователей

Имена пользователей — это легко запоминающиеся идентификаторы, выбираемые пользователем и используемые для идентификации при входе в систему или сервис. Термины «идентификатор пользователя» (User ID) и «имя пользователя» (username) могут использоваться взаимозаменяемо, если имя пользователя, выбранное пользователем, также служит его уникальным идентификатором в системе.

Пользователям должно быть разрешено использовать свой адрес электронной почты в качестве имени пользователя при условии, что этот адрес проверяется при регистрации. Кроме того, они должны иметь возможность выбрать имя пользователя, отличное от адреса электронной почты. Для информации о проверке адресов электронной почты, пожалуйста, посетите [Шпаргалку по проверке ввода](Input_Validation_Cheat_Sheet.md#email-address-validation).

### Решения по аутентификации и чувствительные учетные записи

- **НЕ** разрешайте вход с использованием чувствительных учетных записей (например, учетных записей, которые могут использоваться внутри решения, таких как доступ к бэкенду / промежуточному ПО / БД) через любой пользовательский интерфейс на фронтенде.
- **НЕ** используйте одно и то же решение для аутентификации (например, IDP / AD), используемое внутри компании, для незащищенного доступа (например, общедоступный доступ / DMZ).

### Реализуйте надлежащие требования к сложности паролей

Основная задача при использовании паролей для аутентификации — обеспечить их достаточную сложность. Политика "сильного" пароля делает его трудным или даже маловероятным для угадывания как вручную, так и автоматически. Следующие характеристики определяют сильный пароль:

- Длина пароля
    - **Минимальная** длина пароля должна **принудительно** устанавливаться приложением. Пароли короче **8 символов** считаются слабыми ([NIST SP800-63B](https://pages.nist.gov/800-63-3/sp800-63b.html)).
    - **Максимальная** длина пароля должна быть **не менее 64 символов** для поддержки использования фраз-паролей ([NIST SP800-63B](https://pages.nist.gov/800-63-3/sp800-63b.html)). Обратите внимание, что некоторые реализации алгоритмов хеширования могут привести к [отказу в обслуживании из-за длинного пароля](https://www.acunetix.com/vulnerabilities/web/long-password-denial-of-service/).
- Не обрезайте пароли молча. [Шпаргалка по хранению паролей](Password_Storage_Cheat_Sheet.md#maximum-password-lengths) предоставляет дополнительные рекомендации по обработке паролей, которые длиннее максимальной длины.
- Разрешайте использование **всех** символов, включая юникод и пробелы. Не должно быть правил составления паролей, ограничивающих типы разрешенных символов.
- Обеспечьте смену учетных данных при утечке пароля или при идентификации компрометации.
- Включите измеритель силы пароля, чтобы помочь пользователям создать более сложный пароль, и блокируйте использование распространенных и ранее скомпрометированных паролей:
    - Для этой цели можно использовать библиотеку [zxcvbn-ts](https://github.com/zxcvbn-ts/zxcvbn).
    - [Pwned Passwords](https://haveibeenpwned.com/Passwords) — это сервис, где пароли можно проверить на предмет их предыдущей компрометации. Вы можете использовать его самостоятельно или воспользоваться [API](https://haveibeenpwned.com/API/v3#PwnedPasswords).

#### Для получения более подробной информации, ознакомьтесь с:

- [ASVS v4.0 Password Security Requirements](https://github.com/OWASP/ASVS/blob/master/4.0/en/0x11-V2-Authentication.md#v21-password-security-requirements)
- [Passwords Evolved: Authentication Guidance for the Modern Era](https://www.troyhunt.com/passwords-evolved-authentication-guidance-for-the-modern-era/)

### Реализуйте безопасный механизм восстановления пароля

Для приложения часто требуется механизм, предоставляющий пользователю способ получить доступ к своей учетной записи в случае, если он забыл пароль. Подробности об этой функции смотрите в [Шпаргалке по восстановлению пароля](Forgot_Password_Cheat_Sheet.md)

### Храните пароли в безопасном виде

Крайне важно, чтобы приложение хранило пароль с использованием правильной криптографической техники. Подробности об этой функции смотрите в [Шпаргалке по хранению паролей](Password_Storage_Cheat_Sheet.md) for details on this feature.

### Сравнивайте хеши паролей с использованием безопасных функций

Если возможно, пароль, введенный пользователем, должен сравниваться с хешем пароля, хранящимся в системе, с использованием безопасной функции сравнения паролей, предоставляемой языком программирования или фреймворком, например, функции [password_verify()](https://www.php.net/manual/en/function.password-verify.php) в PHP. Если это невозможно, убедитесь, что функция сравнения:

- Имеет максимальную длину ввода для защиты от атак типа "отказ в обслуживании" с использованием очень длинных входных данных.
- Явно задает типы обеих переменных для защиты от атак, связанных с путаницей типов, таких как [Magic Hashes](https://www.whitehatsec.com/blog/magic-hashes/) в PHP.
- Возвращает результат в постоянное время для защиты от атак по времени.

### Функция смены пароля

При разработке функции смены пароля убедитесь в следующем:

- Пользователь прошел аутентификацию и имеет активную сессию.
- Проверка текущего пароля. Это необходимо для того, чтобы убедиться, что пароль меняет именно законный пользователь. Возможный случай злоупотребления: законный пользователь использует публичный компьютер для входа в систему и забывает выйти. Затем другой человек использует этот публичный компьютер. Если не проверять текущий пароль, этот другой человек сможет изменить пароль.

### Передача паролей только через TLS или другой надежный транспорт

Смотрите: [Шпаргалка по Transport Layer Security (TLS)](Transport_Layer_Security_Cheat_Sheet.md)

Страница входа и все последующие страницы, требующие аутентификации, должны быть доступны исключительно через TLS или другой надежный транспорт. Невыполнение этого требования для страницы входа позволяет злоумышленнику изменить действие формы входа, в результате чего учетные данные пользователя могут быть отправлены в произвольное место. Невыполнение этого требования для страниц, требующих аутентификации после входа, позволяет злоумышленнику просматривать нешифрованный идентификатор сессии и компрометировать аутентифицированную сессию пользователя.

### Требовать повторную аутентификацию для чувствительных функций

Для снижения рисков атак CSRF и перехвата сессий важно требовать текущие учетные данные для учетной записи перед обновлением чувствительной информации, такой как пароль или адрес электронной почты пользователя, или перед выполнением чувствительных транзакций, таких как доставка покупки на новый адрес. Без этой меры противодействия злоумышленник может выполнить чувствительные транзакции через CSRF или XSS-атаку, не зная текущих учетных данных пользователя. Кроме того, злоумышленник может временно получить физический доступ к браузеру пользователя или украсть его идентификатор сессии, чтобы захватить сессию пользователя.

### Рассмотрите использование сильной аутентификации для транзакций

Некоторые приложения должны использовать второй фактор для проверки того, может ли пользователь выполнять чувствительные операции. Для получения дополнительной информации смотрите [Шпаргалку по авторизации транзакций](Transaction_Authorization_Cheat_Sheet.md).

#### Аутентификация клиента через TLS

Аутентификация клиента через TLS, также известная как двусторонняя аутентификация TLS, включает отправку соответствующих TLS-сертификатов как сервером, так и браузером во время процесса рукопожатия TLS. Так же как можно проверить подлинность сервера, используя сертификат и запросив авторитетный центр сертификации (CA), сервер может аутентифицировать пользователя, получив сертификат от клиента и проверив его в стороннем CA или своем собственном CA. Для этого сервер должен предоставить пользователю сертификат, созданный специально для него, присвоив значения полю «субъект», чтобы можно было определить, для какого пользователя предназначен сертификат. Пользователь устанавливает сертификат в браузере и использует его для работы с веб-сайтом.

Рекомендуется использовать этот метод в следующих случаях:

- Когда допустимо (или даже предпочтительно), чтобы пользователь имел доступ к веб-сайту только с одного компьютера/браузера.
- Пользователь не пугается процесса установки TLS-сертификатов в браузере или есть кто-то (например, сотрудник технической поддержки), кто сделает это за пользователя.
- Веб-сайт требует дополнительного шага безопасности.
- Также это хорошо использовать, если веб-сайт предназначен для интранета компании или организации.

В общем, этот метод не рекомендуется использовать для общедоступных веб-сайтов, рассчитанных на среднестатистического пользователя. Например, не стоит внедрять это для сайта, подобного Facebook. Хотя эта техника может предотвратить необходимость ввода пароля (таким образом защищая от кражи среднестатистическим кейлоггером), все же рекомендуется использовать как пароль, так и аутентификацию клиента через TLS в сочетании.

Кроме того, если клиент находится за корпоративным прокси-сервером, выполняющим дешифрование SSL/TLS, это нарушит аутентификацию сертификата, если сайт не разрешен на прокси.

Для получения дополнительной информации смотрите: [Рукопожатие TLS с аутентификацией клиента](https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake)

### Аутентификация и сообщения об ошибках

Неправильно реализованные сообщения об ошибках в функциональности аутентификации могут быть использованы для перебора идентификаторов пользователей и паролей. Приложение должно отвечать (как на уровне HTTP, так и HTML) стандартным образом.

#### Ответы при аутентификации

При использовании любых механизмов аутентификации (вход в систему, сброс пароля или восстановление пароля) приложение должно отвечать стандартным сообщением об ошибке независимо от того:

- Был ли введен неверный идентификатор пользователя или пароль.
- Существует ли учетная запись.
- Заблокирована или отключена учетная запись.

Также следует учитывать функцию регистрации учетной записи и применять тот же подход использования стандартного сообщения об ошибке в случае, если пользователь уже существует.

Целью является предотвращение создания [фактора несоответствия](https://cwe.mitre.org/data/definitions/204.html), который позволит злоумышленнику провести атаку на перебор пользователей против приложения.

Интересно отметить, что сама бизнес-логика может привести к возникновению фактора несоответствия, связанного со временем обработки. В действительности, в зависимости от реализации время обработки может существенно различаться в зависимости от случая (успех или неудача), что позволяет злоумышленнику осуществить [атаку, основанную на времени](https://en.wikipedia.org/wiki/Timing_attack) (например, разница в несколько секунд).

Пример, использующий псевдокод для функции входа:

- Первая реализация, использующая подход "быстрого выхода":

```text
IF USER_EXISTS(username) THEN
    password_hash=HASH(password)
    IS_VALID=LOOKUP_CREDENTIALS_IN_STORE(username, password_hash)
    IF NOT IS_VALID THEN
        RETURN Error("Invalid Username or Password!")
    ENDIF
ELSE
   RETURN Error("Invalid Username or Password!")
ENDIF
```

Здесь четко видно, что если пользователь не существует, приложение сразу выдаст ошибку. В противном случае, когда пользователь существует, а пароль нет, очевидно, что перед ошибкой произойдет больше обработки. В результате время отклика будет различным для одной и той же ошибки, позволяя злоумышленнику различать неверное имя пользователя и неверный пароль.

- Вторая реализация без использования подхода "быстрого выхода":

```text
password_hash=HASH(password)
IS_VALID=LOOKUP_CREDENTIALS_IN_STORE(username, password_hash)
IF NOT IS_VALID THEN
   RETURN Error("Invalid Username or Password!")
ENDIF
```

Этот код будет выполнять один и тот же процесс независимо от того, что введено в поле пользователя или пароля, позволяя приложению возвращать ответ с примерно одинаковым временем отклика.

Проблема с возвратом стандартного сообщения об ошибке для пользователя заключается в удобстве использования (UX). Законный пользователь может запутаться из-за стандартных сообщений, что усложнит использование приложения, и после нескольких попыток он может покинуть приложение из-за его сложности. Решение о возврате *стандартного сообщения об ошибке* можно принимать в зависимости от критичности приложения и его данных. Например, для критически важных приложений команда может решить, что в случае неудачи пользователя всегда будут перенаправлять на страницу поддержки, а *стандартное сообщение об ошибке* будет возвращаться.

Что касается перебора пользователей, защита от [атак методом перебора](#protect-against-automated-attacks) также является эффективной, поскольку она не позволяет злоумышленнику проводить перебор в широком масштабе. Использование [CAPTCHA](https://en.wikipedia.org/wiki/CAPTCHA) может быть применено для функции, для которой нельзя вернуть *стандартное сообщение об ошибке*, так как необходимо сохранить *удобство использования*.

##### Примеры правильных и неправильных ответов

###### Авторизация

Неправильные ответы:

- "Авторизация для Пользователя foo: неверный пароль."
- "Ошибка авторизации: неверный ID пользователя."
- "Ошибка авторизации: аккаунт пользователя отключён"
- "Ошибка авторизации: данный аккаунт неактивен"

Правильный ответ:

- "Ошибка авторизации: неверный логин или пароль"

###### Восстановление пароля

Неправильные ответы:

- "Мы прямо сейчас отправили вам письмо на почту с ссылкой для восстановления пароля."
- "Данный email отсутствует в нашей базе данных"

Правильный ответ:

- "Если данный email есть в нашей базе данных, мы отправим письмо с инструкциями по восстановлению пароля"

###### Создание аккаунта

Неправильные ответы:

- "Данное имя пользователя уже используется."
- "Добро пожаловать! Вы успешно зарегистрировались."

Правильный ответ:

- "Мы отправили Вам ссылку для активации аккаунта на указанный email"

##### Коды ошибок и URL

Приложение может возвращать другой [HTTP код ошибки](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status) в зависимости от ответа на попытку аутентификации. Например, оно может отвечать кодом 200 в случае положительного результата и 403 в случае отрицательного. Даже если пользователю показывается стандартная страница ошибки, HTTP-код ответа может различаться, что может раскрыть информацию о том, является ли учетная запись действительной.

Раскрытие информации об ошибках также может использоваться в качестве фактора несоответствия; ознакомьтесь со [Шпаргалкой по обработке ошибок](Error_Handling_Cheat_Sheet.md) для глобального управления различными ошибками в приложении.

### Защита от автоматизированных атак

Существует множество различных типов автоматизированных атак, которые злоумышленники могут использовать для попыток компрометации учетных записей пользователей. Ниже перечислены наиболее распространенные типы:

| Тип атаки                  | Описание атаки                                                                          |
|----------------------------|-----------------------------------------------------------------------------------------|
| Перебор паролей            | Проверка множества паролей из словаря или другого источника для одной учетной записи.   |
| Подстановка учетных данных | Проверка пар "имя пользователя/пароль", полученных в результате утечки на другом сайте. |
| Password Spraying          | Проверка одного слабого пароля для большого числа различных учетных записей.            |

Для защиты от этих атак можно реализовать различные механизмы защиты. Во многих случаях эти средства защиты не обеспечивают полной защиты, но при использовании их в комплексе с подходом глубокой защиты можно добиться приемлемого уровня безопасности.

В следующих разделах основное внимание будет уделено предотвращению атак методом перебора, хотя эти меры могут быть эффективными и против других типов атак. Для получения дополнительной информации по защите от подстановки учетных данных и атак типа "password spraying" смотрите [Шпаргалку по предотвращению подстановки учётных данных](Credential_Stuffing_Prevention_Cheat_Sheet.md).

#### Многофакторная аутентификация

Многофакторная аутентификация (MFA) является, безусловно, лучшей защитой от большинства атак, связанных с паролями, включая атаки методом перебора. Анализ Microsoft показывает, что она могла бы предотвратить [99,9% компрометаций учетных записей](https://techcommunity.microsoft.com/t5/Azure-Active-Directory-Identity/Your-Pa-word-doesn-t-matter/ba-p/731984). Поэтому она должна быть реализована везде, где это возможно; однако, в зависимости от целевой аудитории приложения, внедрение MFA может быть непрактичным или невыполнимым.

Дополнительные рекомендации по внедрению MFA можно найти в [Шпаргалке по многофакторной аутентификации](Multifactor_Authentication_Cheat_Sheet.md).

#### Ограничение частоты входов

Ограничение частоты входов — это протокол, используемый для предотвращения слишком большого количества попыток подбора пароля с использованием нормальных интерактивных средств. Оно включает:

- Максимальное количество попыток.

##### Блокировка учетной записи

Наиболее распространенная защита от этих атак — реализация блокировки учетной записи, которая предотвращает дальнейшие попытки входа на определенный период времени после определенного количества неудачных попыток входа.

Счетчик неудачных попыток входа должен быть связан непосредственно с учетной записью, а не с IP-адресом источника, чтобы предотвратить возможность злоумышленника попытаться войти с большого количества различных IP-адресов. При реализации политики блокировки учетной записи необходимо учитывать ряд различных факторов, чтобы найти баланс между безопасностью и удобством использования:

- Количество неудачных попыток до блокировки учетной записи (порог блокировки).
- Временной интервал, в течение которого должны произойти эти попытки (окно наблюдения).
- Длительность блокировки учетной записи (продолжительность блокировки).

Вместо реализации фиксированной продолжительности блокировки (например, 10 минут), некоторые приложения используют экспоненциальную блокировку, когда длительность блокировки начинается с очень короткого периода (например, одна секунда), но удваивается после каждой неудачной попытки входа.

- Время задержки после каждой блокировки учетной записи (максимум 2-3, затем постоянная блокировка учетной записи).

При проектировании системы блокировки учетной записи следует позаботиться о том, чтобы ее нельзя было использовать для организации отказа в обслуживании путем блокировки учетных записей других пользователей. Один из способов предотвратить это — разрешить пользователю входить в систему с помощью функции восстановления пароля, даже если учетная запись заблокирована.

#### CAPTCHA

Использование эффективной CAPTCHA может помочь предотвратить автоматизированные попытки входа в учетные записи. Однако многие реализации CAPTCHA имеют уязвимости, которые позволяют решать их с использованием автоматизированных техник или передавать их для решения специализированным сервисам. Поэтому использование CAPTCHA следует рассматривать как защиту в глубину, чтобы сделать атаки методом перебора более длительными и дорогостоящими, а не как превентивную меру.

Более удобным для пользователя может быть требование решения CAPTCHA только после нескольких неудачных попыток входа, а не с самого первого входа.

#### Секретные вопросы и запоминаемые слова

Добавление секретного вопроса или запоминаемого слова также может помочь защититься от автоматизированных атак, особенно когда пользователя просят ввести несколько случайно выбранных символов из слова. Следует отметить, что это **не** является многофакторной аутентификацией, так как оба фактора одинаковы (то, что вы знаете). Более того, секретные вопросы часто бывают слабыми и имеют предсказуемые ответы, поэтому их нужно тщательно выбирать. В [Шпаргалке по выбору и использованию секретных вопросов](Choosing_and_Using_Security_Questions_Cheat_Sheet.md) содержатся дополнительные рекомендации по этому вопросу.

## Логирование и мониторинг

Включите логирование и мониторинг функций аутентификации для обнаружения атак/сбоев в режиме реального времени:

- Убедитесь, что все неудачные попытки входа регистрируются и проверяются.
- Убедитесь, что все ошибки паролей регистрируются и проверяются.
- Убедитесь, что все блокировки учетных записей регистрируются и проверяются.

## Использование протоколов аутентификации, не требующих пароля

Хотя аутентификация с помощью комбинации имени пользователя, пароля и многофакторной аутентификации считается в целом безопасной, существуют случаи, когда это не считается лучшим вариантом или даже безопасным. Примеры таких случаев включают сторонние приложения, которые желают подключаться к веб-приложению, будь то с мобильного устройства, другого веб-сайта, настольного компьютера или в других ситуациях. В таких случаях НЕ считается безопасным позволять стороннему приложению хранить комбинацию имени пользователя и пароля, так как это расширяет поверхность атаки за пределы вашего контроля. Для этого и других случаев использования существуют несколько протоколов аутентификации, которые могут защитить вас от раскрытия данных ваших пользователей злоумышленникам.

### OAuth

Open Authorization (OAuth)  — это протокол, который позволяет приложению аутентифицироваться на сервере от имени пользователя без необходимости использования паролей или стороннего сервера, который действует как поставщик идентификации. Он использует токен, сгенерированный сервером, и определяет, каким образом должны происходить потоки авторизации, чтобы клиент, такой как мобильное приложение, мог сообщить серверу, какой пользователь использует сервис.

Рекомендуется использовать и внедрять OAuth 1.0a или OAuth 2.0, поскольку было обнаружено, что самая первая версия (OAuth 1.0) уязвима к фиксации сессии.

OAuth 2.0 полагается на HTTPS для обеспечения безопасности и в настоящее время используется и внедряется API таких компаний, как Facebook, Google, Twitter и Microsoft. OAuth 1.0a сложнее в использовании, так как требует использования криптографических библиотек для цифровых подписей. Однако, поскольку OAuth 1.0a не зависит от HTTPS для обеспечения безопасности, он может быть более подходящим для транзакций с высоким уровнем риска.

### OpenId

OpenId — это протокол, основанный на HTTP, который использует поставщиков идентификации для проверки того, что пользователь является тем, кем он себя называет. Это очень простой протокол, который позволяет осуществлять единый вход (SSO) по инициативе поставщика услуг. Это позволяет пользователю повторно использовать одну и ту же идентификацию, выданную доверенным поставщиком идентификации OpenId, и быть одним и тем же пользователем на нескольких веб-сайтах, без необходимости предоставлять какому-либо веб-сайту пароль, кроме поставщика идентификации OpenId.

Благодаря своей простоте и защите паролей OpenId получил широкое распространение. Некоторые известные поставщики идентификации для OpenId — это Stack Exchange, Google, Facebook и Yahoo!

Для не корпоративных сред OpenId считается безопасным и зачастую лучшим выбором, если поставщик идентификации заслуживает доверия.

### SAML

Язык разметки для утверждений безопасности (Security Assertion Markup Language, SAML) часто рассматривается как конкурент OpenId. Наиболее рекомендуемой версией является 2.0, так как она обладает всеми необходимыми функциями и обеспечивает высокую безопасность. Как и OpenId, SAML использует поставщиков идентификации, но в отличие от OpenId, он основан на XML и предоставляет больше гибкости. SAML основан на перенаправлениях браузера, которые отправляют данные в формате XML. Кроме того, инициатором SAML может быть не только поставщик услуг, но и поставщик идентификации. Это позволяет пользователю перемещаться по различным порталам, оставаясь при этом аутентифицированным, не предпринимая никаких действий, что делает процесс прозрачным.

Хотя OpenId захватил большую часть потребительского рынка, SAML часто выбирается для корпоративных приложений, так как существует мало поставщиков идентификации OpenId, которые считаются корпоративного уровня (то есть способ, которым они проверяют личность пользователя, не соответствует высоким стандартам, необходимым для корпоративной идентификации). Чаще можно увидеть использование SAML на внутренних сайтах компании, иногда даже с использованием сервера внутри корпоративной сети в качестве поставщика идентификации.

В последние несколько лет такие приложения, как SAP ERP и SharePoint (SharePoint с использованием Active Directory Federation Services 2.0), решили использовать аутентификацию SAML 2.0 как часто предпочтительный метод для реализации единого входа всякий раз, когда требуется корпоративная федерация для веб-сервисов и веб-приложений.

**См. также: [Шпаргалка по безопасности SAML](SAML_Security_Cheat_Sheet.md)**

### FIDO

Альянс Fast Identity Online (FIDO) разработал два протокола для облегчения онлайн-аутентификации: протокол Universal Authentication Framework (UAF) и протокол Universal Second Factor (U2F). В то время как UAF ориентирован на аутентификацию без использования пароля, U2F позволяет добавить второй фактор к уже существующей аутентификации, основанной на пароле. Оба протокола основаны на модели аутентификации "вызов-ответ" с использованием криптографии с открытым ключом.

UAF использует существующие на устройствах технологии безопасности для аутентификации, включая датчики отпечатков пальцев, камеры (биометрия лица), микрофоны (биометрия голоса), Trusted Execution Environments (TEEs), Secure Elements (SEs) и другие. Протокол предназначен для интеграции этих возможностей устройств в общую структуру аутентификации. UAF работает как с нативными приложениями, так и с веб-приложениями.

U2F дополняет аутентификацию, основанную на пароле, с помощью аппаратного токена (обычно USB), который хранит криптографические ключи аутентификации и использует их для подписания. Пользователь может использовать один и тот же токен в качестве второго фактора для нескольких приложений. U2F работает с веб-приложениями и обеспечивает **защиту от фишинга** путем использования URL-адреса веб-сайта для поиска сохраненного ключа аутентификации.

## Менеджеры паролей

Менеджеры паролей — это программы, плагины для браузеров или веб-сервисы, которые автоматизируют управление большим количеством различных учетных данных. Большинство менеджеров паролей позволяют пользователям легко использовать их на веб-сайтах:
(a) вставляя пароли в форму входа
-- or --
(b) имитируя ввод паролей пользователем.

Веб-приложения не должны усложнять работу менеджеров паролей больше, чем это необходимо, соблюдая следующие рекомендации:

- Используйте стандартные HTML-формы для ввода имени пользователя и пароля с соответствующими атрибутами `type`.
- Избегайте использования плагинов для страниц входа (например, Flash или Silverlight).
- Реализуйте разумную максимальную длину пароля, не менее 64 символов, как обсуждалось в разделе [Реализуйте надлежащие требования к сложности паролей.](#реализуйте-надлежащие-требования-к-сложности-паролей).
- Разрешайте использование любых символов в паролях.
- Разрешайте пользователям вставлять текст в поля для имени пользователя, пароля и MFA.
- Разрешайте пользователям переходить между полями имени пользователя и пароля одним нажатием клавиши `Tab`.

## Изменение зарегистрированного адреса электронной почты пользователя

Адреса электронной почты пользователей часто меняются. Для обработки таких ситуаций в системе рекомендуется следующий процесс:

*Note: Примечание: Процесс менее строгий при наличии [Многофакторной аутентификации](https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html), поскольку доказательство личности в этом случае сильнее, чем при опоре только на пароль.*

### Рекомендуемый процесс, если у пользователя ВКЛЮЧЕНА [многофакторная аутентификация](https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html)

1. Подтвердите действительность cookie или токена аутентификации пользователя. Если они недействительны, отобразите экран входа.
2. Опишите пользователю процесс изменения зарегистрированного адреса электронной почты.
3. Попросите пользователя предоставить новый предполагаемый адрес электронной почты, чтобы убедиться, что он соответствует правилам системы.
4. Запросите использование [Многофакторной аутентификации](https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html) для проверки личности.
5. Сохраните новый предполагаемый адрес электронной почты как ожидаемое изменение.
6. Создайте и сохраните **два** временных одноразовых токена (nonces) для (a) уведомления системных администраторов и (b) подтверждения пользователя.
7. Отправьте два сообщения электронной почты с ссылками, содержащими эти токены:

    - **Уведомление по электронной почте** на текущий адрес, предупреждающее пользователя о предстоящем изменении и содержащее ссылку для действий в случае неожиданной ситуации.

    - **Подтверждение по электронной почте** на предполагаемый новый адрес с инструкциями по подтверждению изменения и ссылкой для действий в случае неожиданной ситуации.

8. Обрабатывайте ответы по ссылкам соответственно.

### Рекомендуемый процесс, если у пользователя НЕ включена многофакторная аутентификация

1. Подтвердите действительность cookie или токена аутентификации пользователя. Если они недействительны, отобразите экран входа.
2. Опишите пользователю процесс изменения зарегистрированного адреса электронной почты.
3. Попросите пользователя предоставить новый предполагаемый адрес электронной почты, чтобы убедиться, что он соответствует правилам системы.
4. Запросите текущий пароль пользователя для подтверждения личности.
5. Сохраните новый предполагаемый адрес электронной почты как ожидаемое изменение.
6. Создайте и сохраните три временных одноразовых токена для уведомления системных администраторов, подтверждения пользователя и дополнительного шага, зависящего от пароля.
7. Отправьте два сообщения электронной почты с ссылками, содержащими эти токены:

    - **Сообщение с подтверждением по электронной почте** на текущий адрес с инструкциями по подтверждению изменения и ссылкой для действий в случае неожиданной ситуации.

    - **Отдельное сообщение с подтверждением по электронной почте** на предполагаемый новый адрес с инструкциями по подтверждению изменения и ссылкой для действий в случае неожиданной ситуации.

8. Обрабатывайте ответы по ссылкам соответственно.

### Примечания к указанным процессам

- Стоит отметить, что Google использует другой подход для учетных записей, защищенных только паролем — [где на текущий адрес электронной почты отправляется только уведомление](https://support.google.com/accounts/answer/55393?hl=en). Этот метод несет риски и требует бдительности со стороны пользователя.

- Регулярное обучение по предотвращению социальной инженерии имеет решающее значение. Администраторы системы и сотрудники службы поддержки должны быть обучены следовать предписанному процессу, а также распознавать и реагировать на атаки социальной инженерии. Ознакомьтесь с руководством [CISA по предотвращению атак социальной инженерии и фишинга](https://www.cisa.gov/news-events/news/avoiding-social-engineering-and-phishing-attacks)
