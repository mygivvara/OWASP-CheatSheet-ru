# Шпаргалка по управлению секретами

## 1 Вступление

В настоящее время секреты используются повсеместно, особенно в связи с ростом популярности DevOps. Ключи интерфейса прикладного программирования (API), учетные данные базы данных, разрешения для идентификации и управления доступом (IAM), ключи Secure Shell (SSH), сертификаты и т.д. Во многих организациях они жестко прописаны в исходном коде в виде открытого текста и разбросаны по файлам конфигурации и инструментам управления конфигурацией.

В организациях растет потребность в централизации хранения, подготовки, аудита, ротации и управления секретами, чтобы контролировать доступ к секретам и предотвращать их утечку и компрометацию организации. Часто службы используют одни и те же секреты, что затрудняет выявление источника компрометации или утечки.

В этой шпаргалке представлены лучшие практики и рекомендации, которые помогут правильно реализовать управление секретами.

## 2 Управление общими секретами

В следующих разделах рассматриваются основные концепции, относящиеся к управлению секретами.

### 2.1 Высокая доступность

Очень важно выбрать технологию, которая была бы достаточно надежной для надежного обслуживания трафика:

- Пользователей (например, SSH-ключи, пароли учетных записей root). В сценарии реагирования на инциденты пользователи ожидают, что им будут быстро предоставлены учетные данные, чтобы они могли восстановить отключенные службы. Ожидание получения учетных данных может повлиять на оперативность реагирования оперативной группы.
- Приложений (например, учетные данные базы данных и ключи API). Если служба не работает должным образом, это может привести к снижению доступности зависимых приложений или увеличению времени запуска приложений.

Такая служба могла бы получать значительный объем запросов в рамках крупной организации.

### 2.2 Централизовать и стандартизировать

Секреты, используемые вашими командами разработчиков для ваших приложений, могут использоваться иначе, чем секреты, хранящиеся вашими маркетологами или командой SRE. Вы часто сталкиваетесь с тем, что секреты плохо хранятся, когда потребности тайных потребителей или производителей не совпадают. Поэтому необходимо тщательно стандартизировать и централизовать решение для управления секретами. Стандартизация и централизация могут означать, что вы используете несколько решений для управления секретами. Например, ваши облачные команды разработчиков предпочитают использовать решение, предоставляемое поставщиком облачных услуг, в то время как ваше частное облако использует стороннее решение, и у каждого есть учетная запись для выбранного менеджера паролей.
Благодаря тому, что команды стандартизируют взаимодействие с этими различными решениями, они остаются удобными в обслуживании и могут быть использованы в случае возникновения инцидента.
Даже если компания централизует управление своими секретами только в одном решении, вам часто приходится сохранять основной секрет этого решения для управления секретами во вторичном решении для управления секретами. Например, вы можете использовать возможности облачного провайдера для хранения секретов, но учетные данные root/management этого облачного провайдера должны храниться где-то в другом месте.

Стандартизация должна включать управление жизненным циклом секретов, аутентификацию, авторизацию и учет решения для управления секретами, а также управление жизненным циклом. Обратите внимание, что организации должно быть сразу понятно, для чего используется секрет и где его можно найти. Чем больше решений для управления секретами вы используете, тем больше документации вам требуется.

### 2.3 Контроль доступа

Когда пользователи могут прочитать секрет в системе управления секретами и/или обновить его, это означает, что теперь секрет может просочиться через этого пользователя и систему, которую он использовал для доступа к секрету.
Следовательно, инженеры не должны иметь доступа ко всем секретам в системе управления секретами, и следует применять принцип наименьших привилегий. Система управления секретами должна обеспечивать возможность тонкой настройки контроля доступа к каждому объекту и компоненту для реализации принципа наименьших привилегий.

### 2.4 Автоматизируйте управление секретами

Ручное обслуживание не только увеличивает риск утечки информации, но и создает риск человеческих ошибок при сохранении секретности. Кроме того, это может привести к расточительству.
Поэтому лучше ограничить или вовсе исключить взаимодействие человека с настоящими секретами. Ограничить взаимодействие человека с секретными данными можно несколькими способами:

- **Конвейер секретов:** Наличие конвейера секретов, который выполняет большую часть работы по управлению секретами (например, создание, ротация и т.д.).
- **Использование динамических секретов:** При запуске приложение может запросить свои учетные данные из базы данных, которые при динамической генерации будут предоставлены с новыми учетными данными для этого сеанса. Динамические секреты следует использовать там, где это возможно, чтобы уменьшить вероятность повторного использования учетных данных. Если учетные данные базы данных приложения будут украдены, после перезагрузки срок их действия истечет.
- **Автоматическая ротация статических ключей:** Ротация ключей - сложный процесс, если ее выполнять вручную, и может привести к ошибкам. Поэтому лучше автоматизировать ротацию ключей или, по крайней мере, обеспечить достаточную поддержку этого процесса с помощью ИТ.

Смена определенных ключей, например ключей шифрования, может привести к полному или частичному повторному шифрованию данных. Существуют различные стратегии смены ключей:

- Постепенная ротация
- Ввод новых ключей для операций записи
- Сохранение старых ключей для операций чтения
- Быстрая ротация
- Ротация по расписанию
- и многое другое...

### 2.5 Хранение секретов в памяти

Дополнительный уровень безопасности может быть достигнут за счет минимизации временного интервала, в течение которого секрет находится в памяти, и ограничения доступа к его объему памяти.

В зависимости от конкретных условий вашего приложения это может быть сложно реализовать таким образом, чтобы обеспечить безопасность памяти. Из-за этой потенциальной сложности реализации вам сначала рекомендуется разработать модель угроз, чтобы четко сформулировать ваши неявные предположения как о среде развертывания вашего приложения, так и о возможностях ваших противников.

Часто попытки защитить секреты, хранящиеся в памяти, считаются излишними, поскольку при оценке модели угроз выясняется, что потенциальные участники угроз, которых вы рассматриваете, либо не обладают возможностями для проведения таких атак, либо стоимость защиты намного превышает вероятные последствия компрометации, возникающей в результате раскрытия секретов, хранящихся в памяти. Кроме того, при разработке соответствующей модели угроз следует иметь в виду, что если злоумышленник уже имеет доступ к памяти процесса, обрабатывающего секретную информацию, то к тому времени нарушение безопасности может уже произойти. Кроме того, следует признать, что с появлением атак, подобных [Rowhammer] (https://arxiv.org/pdf/2211.07613.pdf) или [Meltdown и Spectre](https://meltdownattack.com/), важно понимать, что одной операционной системы недостаточно для защиты памяти вашего процесса от атак такого типа. Это становится особенно важным, когда ваше приложение развертывается в облаке. Единственный надежный подход к защите памяти от этих и подобных атак позволяет полностью физически изолировать память вашего процесса от всех других ненадежных процессов.

Несмотря на трудности реализации, в высокочувствительных средах защита секретных данных в памяти может стать ценным дополнительным уровнем безопасности. Например, в сценариях, когда опытный злоумышленник может вызвать сбой системы и получить доступ к дампу памяти, он может извлечь из него секретные данные. Поэтому рекомендуется тщательно хранить секреты в памяти в ненадежных средах или ситуациях, когда строгая безопасность имеет первостепенное значение.

Кроме того, в языках более низкого уровня, таких как C/C++, относительно легко защитить секреты в памяти. Таким образом, возможно, стоит внедрить эту практику, даже если риск того, что злоумышленник получит доступ к памяти, невелик. С другой стороны, для языков программирования, которые полагаются на сборку мусора, защита секретов в памяти, как правило, намного сложнее.

- **Структуры и классы:** В .NET и Java не используйте неизменяемые структуры, такие как строки, для хранения секретов, поскольку невозможно принудительно выполнить сборку мусора для них. Вместо этого используйте примитивные типы, такие как массивы байтов или массивы символов, где память может быть непосредственно перезаписана. Вы также можете использовать Java [GuardedString](https://docs.oracle.com/html/E28160_01/org/identityconnectors/common/security/GuardedString.html) или .NET [SecureString](https://learn.microsoft.com/en-us/dotnet/api/system.security.securestring#string-versus-securestring), которые предназначены именно для решения этой проблемы.

- **Обнуление памяти:** После того, как секрет был использован, занимаемая им память должна быть обнулена, чтобы предотвратить ее сохранение в памяти, где к ней потенциально можно было бы получить доступ.
    - Если используется Java GuardedString, вызовите метод `dispose()`.
    - Если используется .NET SecureString, вызовите метод `Dispose()`.

- **Шифрование памяти:** В некоторых случаях может оказаться возможным использовать аппаратные средства или функции операционной системы для шифрования всего объема памяти процесса, обрабатывающего секретную информацию. Это может обеспечить дополнительный уровень безопасности. Например, GuardedString в Java шифрует значения в памяти, а SecureString в .NET делает это в Windows.

Помните, что цель состоит в том, чтобы максимально сократить промежуток времени, в течение которого секрет хранится в памяти в виде открытого текста.

Более подробную информацию смотрите в разделе [Тестирование памяти на наличие конфиденциальных данных](https://mas.owasp.org/MASTG/tests/android/MASVS-STORAGE/MASTG-TEST-0011) из проекта OWASP MAS.

### 2.6 Аудит

Аудит является важной частью управления секретами в силу специфики приложения. Вы должны обеспечить надежную реализацию аудита, чтобы быть устойчивыми к попыткам вмешательства в журналы аудита или их удаления. Как минимум, вы должны выполнить аудит следующего:

- Кто запрашивал секрет, для какой системы и роли.
- Был ли запрос одобрен или отклонен.
- Когда использовался секрет и кем/чем.
- Когда истек срок действия секретной информации.
- Предпринимались ли какие-либо попытки повторного использования секретной информации с истекшим сроком действия.
- Если были какие-либо ошибки аутентификации или авторизации.
- Когда и кем/чем был обновлен секрет.
- Любые административные действия и возможная активность пользователя в базовом стеке поддерживающей инфраструктуры.

Важно, чтобы во время всего аудита были установлены правильные временные метки. Поэтому в системе secret management должны быть установлены соответствующие протоколы синхронизации времени в поддерживающей инфраструктуре. Вам следует отслеживать стек, на котором работает решение, на предмет возможного смещения часов и ручной корректировки времени.

### 2.7 Секретный жизненный цикл

Секреты имеют определенный жизненный цикл. Жизненный цикл состоит из следующих этапов:

- Создание
- Ротация
- Аннулирование
- Истечение срока действия

#### 2.7.1 Создание

Новые секретные данные должны быть надежно сгенерированы и криптографически достаточно надежны для своей цели. Секретные данные должны иметь минимальные привилегии, назначенные им для обеспечения их требуемого использования/роли.

Вы должны безопасно передавать учетные данные, чтобы в идеале не отправлять пароль вместе с именем пользователя при запросе учетных записей пользователей. Вместо этого вам следует отправить пароль по защищенному каналу (например, через соединение с взаимной аутентификацией) или по стороннему каналу, такому как push-уведомление, SMS, электронная почта. Ознакомьтесь с [Инструкцией по многофакторной аутентификации] (https://cheat инструкция series.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet), чтобы узнать о плюсах и минусах каждого канала.

Наличие нескольких каналов связи может оказаться невыгодным для приложений, поэтому необходимо надежно предоставить учетные данные.

Смотрите [проект Open CRE по поиску секретов](https://www.opencre.org/cre/223-780) для получения дополнительных технических рекомендаций по созданию секретов.

#### 2.7.2 Ротация

Вам следует регулярно менять секретные данные, чтобы любые украденные учетные данные работали только в течение короткого времени. Регулярная ротация также снизит склонность пользователей возвращаться к вредным привычкам, таким как повторное использование учетных данных.

В зависимости от функции secret и того, что он защищает, срок его службы может составлять от нескольких минут (например, сквозные зашифрованные чаты с идеальной прямой секретностью) до нескольких лет (например, аппаратные секреты).

Учетные данные пользователя не подлежат регулярной ротации. Их следует ротировать только в том случае, если есть подозрения или доказательства того, что они были скомпрометированы, в соответствии с [рекомендациями NIST](https://pages.nist.gov/800-63-FAQ/#q-b05).

#### 2.7.3 Отзыв

Когда секретные данные больше не требуются или потенциально скомпрометированы, вы должны надежно отозвать их, чтобы ограничить доступ. В случае сертификатов (TLS) это также влечет за собой отзыв сертификата.

#### 2.7.4 Истечение

По возможности, вы должны создавать секреты, срок действия которых истекает через определенное время. Этот срок может быть либо активным для системы, использующей секрет, либо истечением срока действия, установленного в системе управления секретами, что приводит к запуску вспомогательных процессов, что приводит к ротации секретов.
Вы должны применить политики с помощью решения для управления секретами, чтобы гарантировать, что учетные данные будут доступны только в течение ограниченного времени, соответствующего типу учетных данных. Приложения должны убедиться, что секрет все еще активен, прежде чем доверять ему.

### 2.8 Передавать все через TLS 

Никогда не передавайте секретные данные открытым текстом. В наши дни повсеместному внедрению TLS нет оправдания.

Кроме того, вы можете эффективно использовать решения для управления секретными данными для предоставления сертификатов TLS.

### 2.9 Время простоя, разбитие стекла, резервное копирование и восстановление

Учитывайте возможность того, что служба управления секретами становится недоступной по различным причинам, например, из-за запланированного простоя для обслуживания. Возможно, будет невозможно получить учетные данные, необходимые для восстановления службы, если вы не получили их ранее. Поэтому тщательно выбирайте периоды обслуживания, основываясь на более ранних показателях и журналах аудита.

Далее, процедуры резервного копирования и восстановления системы следует регулярно тестировать и проверять на предмет их безопасности. Несколько требований, касающихся резервного копирования и восстановления. Убедитесь, что:

- Внедрена и периодически выполняется автоматизированная процедура резервного копирования; частота создания резервных копий и моментальных снимков зависит от количества секретных данных и их жизненного цикла.
- Часто тестируйте процедуры восстановления, чтобы гарантировать сохранность резервных копий.
- Шифруйте резервные копии и помещайте их в защищенное хранилище с ограниченными правами доступа. Следите за местоположением резервной копии на предмет (несанкционированного) доступа и административных действий.

Наконец, вам следует внедрить аварийные процедуры (""break-glass") для восстановления работы сервиса, если система становится недоступной по причинам, отличным от регулярного технического обслуживания. Поэтому необходимо регулярно создавать резервные копии учетных данных для аварийного разбей стекло во вторичной системе управления секретами и регулярно проверять их работоспособность.

### 2.10 Политики

Последовательно применяйте политики, определяющие требования к минимальной сложности паролей и утвержденным алгоритмам шифрования, на уровне всей организации. Использование централизованного решения для управления секретами может помочь компаниям внедрить эти политики.

Далее, наличие политики управления секретами в масштабах всей организации может помочь обеспечить применение рекомендаций, описанных в этом руководстве.

### 2.11 Метаданные: подготовьтесь к перемещению секретной информации

Решение для управления секретом должно обеспечивать возможность хранения, по крайней мере, следующих метаданных о секрете:

- Когда он был создан/использован/заархивирован/ротирован/удален
- Кто его создал/использовал/заархивировал/ротировал/удалил (например, как сам производитель, так и инженер, использующий производственный метод)
- Что его создало/использовало/заархивировало/ротировало/удалило
- К кому обращаться в случае возникновения проблем с секретом или вопросов по его поводу
- Для чего используется секрет (например, указаны предполагаемые потребители и цель секрета)
- Какой это тип секрета (например, ключ AES, ключ HMAC, закрытый ключ RSA)
- Когда вам нужно его изменить, если это делается вручную

Примечание: если вы не сохраните метаданные о секрете и не подготовитесь к перемещению, вы увеличите вероятность блокировки поставщика.

## 3 Непрерывная интеграция (CI) и непрерывное развертывание (CD)

Для создания, тестирования и внедрения изменений обычно требуется доступ ко многим системам. Средства непрерывной интеграции (CI) и непрерывного развертывания (CD) обычно хранят секретные данные для обеспечения настройки приложения или во время развертывания. Кроме того, они тесно взаимодействуют с системой управления секретами. Различные рекомендации могут помочь упростить управление секретами в CI/CD; мы рассмотрим некоторые из них в этом разделе.

### 3.1 Упрочнение вашего пайплайна CI/CD

CI/CD tooling регулярно использует учетные данные (с высокими привилегиями). Убедитесь, что пайплан не может быть легко взломан или неправильно использован сотрудниками. Вот несколько рекомендаций, которые могут вам помочь:

- Относитесь к своему инструментарию CI/CD как к рабочей среде: улучшайте его, вносите исправления и улучшайте базовую инфраструктуру и сервисы.
- Обеспечьте мониторинг событий безопасности.
- Внедрить доступ с наименьшими привилегиями: разработчикам не нужно уметь администрировать проекты. Вместо этого им нужно только уметь выполнять необходимые функции, такие как настройка пайплайна, их запуск и работа с кодом. Административные задачи могут быть быстро выполнены с использованием конфигурации в виде кода в отдельном хранилище, используемом системой CI/CD для обновления своей конфигурации. Нет необходимости в привилегированных ролях, которые могли бы иметь доступ к секретам.
- Убедитесь, что выходные данные пайплайна не содержат секретных данных, и вы не сможете прослушивать производственные пайплайны с помощью инструментов отладки.
- Убедитесь, что вы не можете подключаться к каким-либо исполнителям и воркерам для системы CI/CD.
- Обеспечьте надлежащую аутентификацию, авторизацию и учет.
- Убедитесь, что только утвержденный процесс может создавать пайплайны, включая шаги MR/PR, чтобы убедиться, что созданный пайплайн проверен на безопасность.

### 3.2 Где должен быть секрет?

Существуют различные места, где вы можете хранить секрет для выполнения действий CI/CD:

- Как часть вашего инструментария CI/CD: вы можете сохранить секрет в [GitLab](https://docs.gitlab.com/charts/installation/secrets.html)/[GitHub](https://docs.github.com/en/actions/security-guides/encrypted-secrets)/[jenkins](https://www.jenkins.io/doc/developer/security/secrets/). Это не то же самое, что зафиксировать его в коде.
- Как часть вашей системы управления секретами: вы можете сохранить секрет в системе управления секретами, например, с помощью средств, предоставляемых поставщиком облачных услуг ([AWS Secret Manager](https://aws.amazon.com/secrets-manager/), [Azure Key Vault](https://azure.microsoft.com/nl-nl/services/key-vault/), [Google Secret Manager](https://cloud.google.com/secret-manager)) или другие сторонние сервисы ([Хранилище Hashicorp](https://www.vaultproject.io/), [Conjur](https://www.conjur.org/), [Хранитель](https://www.keepersecurity.com/), [Доверенное лицо](https://lyft.github.io/confidant/)). В этом случае инструментарий пайплайна CI/CD требует учетных данных для подключения к этим системам управления секретами, чтобы иметь доступ к секретам. Смотрите [Облачные провайдеры] (#4-облачные провайдеры) для получения более подробной информации об использовании системы управления безопасностью облачного провайдера.

Другой альтернативой здесь является использование пайплайна CI/CD для использования шифрования как сервиса из систем управления секретами для выполнения шифрования секрета. Инструментарий CI/CD может затем передать зашифрованный секрет в git, который может быть извлечен потребляющей службой при развертывании и снова расшифрован. Более подробную информацию смотрите в разделе 3.6.

Примечание: не все секреты должны находиться в пайплайне CI/CD, чтобы перейти к фактическому развертыванию. Вместо этого убедитесь, что развернутые службы выполняют часть управления своими секретами на своем собственном жизненном цикле (например, развертывание, время выполнения и уничтожение).

#### 3.2.1 Как часть вашего инструментария CI/CD

Когда секреты являются частью вашего инструментария CI/CD, это означает, что эти секреты доступны для выполнения ваших заданий CI/CD. Инструменты CI/CD могут включать, например, секреты GitHub, секреты репозитория GitLab, ENV Vars/группы Var в Microsoft Azure DevOps, секреты Kubernetes и т.д.
Эти секреты часто настраиваются / просматриваются людьми, имеющими на это разрешение (например, разработчиком в GitHub, владельцем проекта в GitLab, администратором в Jenkins и т.д.), Что в совокупности соответствует следующим рекомендациям:

- Никаких "больших секретов": убедитесь, что в вашем наборе инструментов CI/CD есть секреты, которые не являются долговременными, не имеют большого радиуса действия и не имеют высокой ценности. Кроме того, ограничьте количество общих секретов (например, никогда не вводите один пароль для всех пользователей с правами администратора).
- Как есть / как будет: у вас есть четкое представление о том, какие пользователи могут просматривать или изменять секреты. Часто разработчики проекта GitLab/GitHub могут просматривать или иным образом извлекать его секреты.
- Сократите количество людей, которые могут выполнять административные задачи в рамках проекта, чтобы ограничить воздействие.
- Ведение журнала и оповещение: Соберите все журналы из инструментария CI/CD и разработайте правила для обнаружения секретного извлечения или неправильного использования, будь то доступ к ним через веб-интерфейс или их сброс при двойном кодировании base64 или шифровании с помощью OpenSSL.
- Ротация: Регулярно меняйте секреты.
- При разветвлении не должно быть утечки: убедитесь, что разветвление хранилища или копия определения задания не копируют секрет.
- Документирование: убедитесь, что вы задокументировали, какие секреты вы храните как часть своего инструментария CI /CD и почему, чтобы при необходимости их можно было легко перенести.

#### 3.2.2 Хранение информации в системе управления секретами

Естественно, вы можете хранить секреты в специальном решении для управления секретами. Например, вы можете воспользоваться решением, предлагаемым вашим поставщиком (облачной) инфраструктуры, таким как [AWS Secrets Manager](https://aws.amazon.com/secrets-manager/), [Google Secrets Manager](https://cloud.google.com/secret-manager) или [Azure KeyVault](https://azure.microsoft.com/nl-nl/services/key-vault/). Вы можете найти более подробную информацию об этом в [разделе 4] (#4 - облачные провайдеры) этой шпаргалки. Другим вариантом является специальная система управления секретами, такая как [Hashicorp Vault](https://www.vaultproject.io/), [Keeper] (https://www.keepersecurity.com/), [Доверенное лицо] (https://lyft.github.io/confidant/), [Conjur](https://www.conjur.org/).
Вот несколько рекомендаций по взаимодействию CI/CD с этими системами. Убедитесь, что соблюдены следующие требования:

- Ротация/временный характер: учетные данные, используемые инструментарием CI/CD для аутентификации в системе управления секретами, часто меняются, и срок их действия истекает после завершения задания.
- Область полномочий: учетные данные, используемые инструментарием CI/CD (например, роли, пользователи и т.д.), позволяют авторизовать только те секреты и службы системы управления секретами, которые необходимы инструментарию CI/CD для выполнения своей работы.
- Идентификация вызывающего абонента: учетные данные, используемые CI/CD tooling, по-прежнему позволяют идентифицировать пользователя, вызывающего решение для управления секретами. Убедитесь, что вы можете отнести любые вызовы, сделанные CI/CD tooling, к лицу или службе, которые запросили действия CI/CD tooling. Если это невозможно с помощью конфигурации secrets manager по умолчанию, убедитесь, что у вас настроена корреляция с точки зрения параметров запроса.
- Все вышеперечисленное: по-прежнему выполняйте действия, перечисленные в разделе 3.2.1: регистрируйте и оповещайте, следите за разветвлениями и т.д.
- Резервное копирование: сохраняйте секретные данные для критически важных операций с продуктом в отдельном хранилище (например, в холодном хранилище), особенно ключи шифрования.

#### 3.2.3 CI/CD не затрагивается вообще

Секреты не обязательно должны передаваться потребителю по каналу CI/CD. Еще лучше, когда потребитель получает секрет сам. В этом случае пайплайну CI/CD по-прежнему необходимо указать системе управления (например, [Kubernetes](https://kubernetes.io/)), что ей необходимо запланировать определенную службу с заданной учетной записью службы, с помощью которой пользователь может затем получить требуемый секрет. В этом случае инструментарий CI/CD по-прежнему имеет учетные данные для платформы управления, но больше не имеет доступа к самим секретам. Что можно и чего нельзя делать в отношении этих типов учетных данных, аналогично описанным в разделе 3.2.2.

### 3.3 Аутентификация и авторизация инструментов CI/CD

Инструментарий CI/CD должен иметь определенные учетные записи служб, которые могут работать только в рамках требуемых секретов или согласования с потребителями секретов. Кроме того, запуск пайплайна CI/CD должен быть легко связан с тем, кто определил задание или запустил его, чтобы обнаружить, кто пытался получить доступ к секретным данным или манипулировать ими. При использовании аутентификации на основе сертификата вызывающий идентификатор пайплайна должен быть частью сертификата. Если вы используете токен для аутентификации в указанных системах, убедитесь, что вы указали участника, запрашивающего эти действия (например пользователь или создатель задания).

Периодически проверяйте, так ли это (по-прежнему) справедливо для вашей системы, чтобы вы могли эффективно вести журнал, устанавливать авторство и оповещать систему безопасности о подозрительных действиях.

### 3.4 Ведение журнала и учет

Злоумышленники могут использовать инструменты CI/CD для извлечения секретов. Они могут, например, использовать административные интерфейсы или создание заданий, которые позволяют получить секрет с помощью шифрования или двойного кодирования base64. Поэтому вам следует регистрировать каждое действие в инструменте CI/CD. Вы должны определить правила оповещения о безопасности при каждой нестандартной манипуляции с инструментом пайплайна и его административным интерфейсом, чтобы отслеживать секретное использование.
Журналы должны быть доступны для запросов в течение как минимум 90 дней и храниться в течение более длительного периода в холодном хранилище. Специалистам по безопасности может потребоваться время, чтобы понять, как злоумышленники могут получить доступ к секретной информации или манипулировать ею с помощью инструментов CI/CD.

### 3.5 Ротация против динамического создания

Вы можете использовать инструмент CI/CD для ротации секретов или дать команду другим компонентам выполнить ротацию секретов. Например, инструмент CI/CD может запросить систему управления секретами или другое приложение для ротации секретов. В качестве альтернативы, инструмент CI/CD или другой компонент может создать динамический секрет, который будет использоваться пользователем до конца его существования. Секрет становится недействительным, когда пользователь перестаёт существовать. Эта процедура уменьшает возможную утечку секретной информации и позволяет легко обнаружить злоупотребление. Если злоумышленник использует secret откуда-либо, кроме IP-адреса пользователя, вы можете легко обнаружить это.

### 3.6 Секреты, созданные пайплайном

Вы можете использовать инструментарий пайплайна для создания секретов и либо предоставлять их непосредственно службе, развернутой с помощью этого инструментария, либо передавать секрет в решение для управления секретами. В качестве альтернативы секрет может храниться в зашифрованном виде в git, чтобы секрет и его метаданные были как можно ближе к месту повседневной работы разработчика. Секрет, сохраненный в git, требует, чтобы разработчики не могли расшифровать его самостоятельно и чтобы у каждого пользователя секрета был свой зашифрованный вариант секрета. Например: секрет должен отличаться для каждой среды DTAP и шифроваться другим ключом. Для каждой среды только назначенный пользователь в этой среде должен иметь возможность расшифровать конкретный секрет. Секрет не передается из одной среды в другую и по-прежнему может быть легко сохранен рядом с кодом.
Пользователи секрета теперь могут расшифровать секрет с помощью коляски, как описано в разделе 5.2. Вместо извлечения секретов пользователь может использовать коляску для расшифровки секрета.

Когда пайплайн сам создает секрет, убедитесь, что используемые сценарии или двоичные файлы соответствуют рекомендациям по созданию секретов. Лучшие практики включают безопасную случайность, надлежащую продолжительность создания секрета и т.д., а также то, что секрет создается на основе четко определенных метаданных, хранящихся где-то в git или где-то еще.

## 4 Облачные провайдеры

Для облачных провайдеров существует, по крайней мере, четыре важных темы, которые следует затронуть:

- Выделенные решения для секретного хранения данных и управления ими. Какие сервисы вы используете?
- Конвертация и шифрование на стороне клиента
- Управление идентификацией и доступом: уменьшение радиуса действия
- Квоты API или ограничения на услуги

### 4.1 Сервисы, которые стоит использовать

В любой среде лучше всего использовать специальное решение для управления секретами. Большинство облачных провайдеров имеют по крайней мере одну услугу, которая предлагает управление секретами. Конечно, также возможно использовать другое решение для управления секретами (например, HashiCorp Vault или Conjure) для вычислительных ресурсов в облаке. В этом разделе мы рассмотрим предложения облачных провайдеров.

Иногда можно автоматически изменить свой секрет, либо с помощью сервиса, предоставляемого вашим облачным провайдером, либо с помощью специальной функции. В целом, вам следует предпочесть решение облачного провайдера, поскольку барьер входа и риск неправильной настройки ниже. Если вы используете пользовательское решение, убедитесь, что функция, выполняющая свою ротацию, может быть взята на себя только указанной функцией.

#### 4.1.1 AWS

Для AWS рекомендуемым решением является [AWS secret manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html).

Разрешения предоставляются на секретном уровне. Ознакомьтесь с [Лучшие практики менеджера секретов](https://docs.aws.amazon.com/secretsmanager/latest/userguide/best-practices.html).

Также можно использовать параметр [Системный менеджер store](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html) , кото-рый мужчина, не замечает совсем ничего:

- вам нужно будет убедиться, что вы сами указали шифрование (по умолчанию это делает secrets manager)
- он предоставляет меньше возможностей автоматической ротации (скорее всего, вам потребуется создать пользовательскую функцию)
- он не поддерживает доступ к разным учетным записям
- он не поддерживает репликацию между регионами
- доступно меньше [security hub controls](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html)

##### 4.1.1.1 AWS Nitro Enclaves

С помощью [AWS Nitro Enclaves](https://aws.amazon.com/ec2/nitro/nitro-enclaves/) вы можете создавать надежные среды выполнения. Таким образом, после запуска приложения доступ со стороны пользователя невозможен. Кроме того, к анклавам не подключено постоянное хранилище. Таким образом, секреты и другие конфиденциальные данные, хранящиеся в анклавах nitro, имеют дополнительный уровень безопасности.

##### 4.1.1.2 AWS CloudHSM

Если секреты используются в приложениях с высокой степенью конфиденциальности, может потребоваться больший контроль над шифрованием и хранением этих ключей. AWS предлагает [CloudHSM](https://aws.amazon.com/cloudhsm/), который позволяет вам использовать свой собственный ключ (BYOK) для сервисов AWS. Таким образом, у вас будет больше контроля над созданием ключей, их жизненным циклом и надежностью. CloudHSM позволяет автоматически масштабировать и создавать резервные копии ваших данных. Поставщик облачных услуг Amazon не будет иметь доступа к материалам ключей, хранящимся в выделенном HSM Azure.

#### 4.1.2 GCP

Для GCP рекомендуемой службой является [Secret Manager](https://cloud.google.com/secret-manager/docs).

Разрешения предоставляются на секретном уровне.

Ознакомьтесь с рекомендациями [Secret Manager](https://cloud.google.com/secret-manager/docs/best-practices).

##### 4.1.2.1 Google Cloud Confidential Computing

[GCP Confidential Computing](https://cloud.google.com/confidential-computing) позволяет шифровать данные во время выполнения. Таким образом, код приложения и данные хранятся в секрете, зашифрованы и недоступны для людей или инструментов.

#### 4.1.3 Azure

Для Azure рекомендуемой службой является [Хранилище ключей](https://docs.microsoft.com/en-us/azure/key-vault/).

В отличие от других облаков, разрешения предоставляются на уровне _**Key Vault**_. Это означает, что секреты для отдельных рабочих нагрузок и отдельных уровней секретности должны храниться в отдельных хранилищах ключей соответственно.

Ознакомьтесь с [Рекомендациями по хранению ключей в хранилище](https://docs.microsoft.com/en-us/azure/key-vault/general/best-practices).

##### 4.1.3.1 Azure Confidential Computing

С помощью [Azure Confidential Computing](https://azure.microsoft.com/en-us/solutions/confidential-computer/#overview) вы можете создавать надежные среды выполнения. Таким образом, каждое приложение будет выполняться в зашифрованном режиме, который защищает данные, а код, используемый приложением, защищен от начала до конца. Кроме того, любое приложение, работающее внутри анклавов, недоступно никакому инструменту или человеку.

##### 4.1.3.2 Azure Dedicated HSM

Для секретных данных, используемых в средах Azure и требующих особых мер безопасности, Azure предлагает [Выделенный HSM-сервер Azure](https://azure.microsoft.com/en-us/services/azure-dedicated-hsm/). Это позволяет вам лучше контролировать хранящиеся в нем секретные данные, включая расширенный административный и криптографический контроль. Поставщик облачных услуг, корпорация Майкрософт, не будет иметь никакого доступа к ключевым материалам, хранящимся в выделенном HSM-сервере Azure.

#### 4.1.4 Другие облака, мультиоблачные и независимые от облаков решения

Если вы используете несколько облачных провайдеров, вам следует рассмотреть возможность использования независимого от облака решения для управления секретами. Это позволит вам использовать одно и то же решение для управления секретами для всех ваших облачных провайдеров (и, возможно, также локально). Еще одним преимуществом является то, что это позволяет избежать привязки поставщика к конкретному облачному провайдеру, поскольку решение может быть использовано любым облачным провайдером.

Доступны решения с открытым исходным кодом и коммерческие решения. Вот несколько примеров:

- [CyberArk Conjur](https://www.conjur.org/)
- [HashiCorp Vault](https://www.vaultproject.io/)

### 4.2 Преобразование и шифрование на стороне клиента

В этом разделе будет описано, как шифруется секретная информация и как вы можете управлять ключами для этого шифрования в облаке.

#### 4.2.1 Шифрование на стороне клиента в сравнении с шифрованием на стороне сервера

Шифрование секретных данных на стороне сервера гарантирует, что облачный провайдер позаботится о шифровании секретных данных в хранилище. В этом случае секретные данные будут защищены от взлома во время их хранения. Шифрование в режиме ожидания часто не требует дополнительной работы, кроме выбора ключа для шифрования (см. раздел 4.2.2). Однако, когда вы передадите секрет другой службе, он больше не будет зашифрован. Он расшифровывается перед передачей предполагаемому сервису или обычному пользователю.

Шифрование секретов на стороне клиента гарантирует, что секрет остается зашифрованным до тех пор, пока вы его активно не расшифруете. Это означает, что он расшифровывается только тогда, когда поступает к пользователю. Для этого вам нужна надлежащая криптографическая система. Подумайте о таких механизмах, как PGP, использующий безопасную конфигурацию, и других более масштабируемых и относительно простых в использовании системах. Шифрование на стороне клиента может обеспечить сквозное шифрование секретной информации: от производителя до потребителя.

#### 4.2.2 Используйте свой собственный ключ в отличие от ключа облачного провайдера

Когда вы шифруете секретную информацию в режиме ожидания, возникает вопрос: какой ключ вы хотите использовать? Чем меньше вы доверяете поставщику облачных услуг, тем больше вам хочется действовать самостоятельно.

Часто вы можете зашифровать секрет с помощью ключа, которым управляет служба управления секретами, или использовать решение для управления ключами от облачного провайдера для шифрования секрета. Ключом, предлагаемым через решение для управления ключами облачного провайдера, может управлять либо поставщик облачных услуг, либо вы сами. В отраслевых стандартах это называется "принесите свой собственный ключ" (BYOK). Вы можете напрямую импортировать или сгенерировать этот ключ в решении для управления ключами или с помощью CloudHSM, поддерживаемого поставщиком облачных услуг.
Затем вы можете использовать свой ключ или основной ключ клиента от поставщика для шифрования ключа данных в решении для управления секретами. Ключ данных, в свою очередь, шифрует секрет. Управляя CMK, вы получаете контроль над ключом данных в решении для управления секретами.

Хотя импорт вашего собственного ключевого материала, как правило, можно выполнить у всех поставщиков ([AWS](https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys.html), [Azure](https://docs.microsoft.com/en-us/azure/key-vault/keys/byok-specification), [GCP](https://cloud.google.com/kms/docs/key-import)), если вы не знаете, что делаете, и этого не требуют ваша модель угроз и политика, это не рекомендуемое решение из-за его сложность и затруднения в использовании.

### 4.3 Управление идентификацией и доступом (IAM)

IAM применим как к локальным, так и к облачным настройкам: для эффективного управления секретами вам необходимо настроить соответствующие политики доступа и роли. Настройка этого параметра выходит за рамки политик, касающихся секретов; она должна включать в себя полную настройку LAMP, поскольку в противном случае это привело бы к атакам с повышением привилегий. Убедитесь, что вы никогда не разрешаете открытые привилегии "передать роль" или неограниченные права на создание I AM, поскольку они могут использовать или создавать учетные данные, которые имеют доступ к секретам. Затем убедитесь, что вы строго контролируете то, что может выдавать себя за учетную запись службы: доступны ли роли ваших компьютеров злоумышленнику, использующему ваш сервер? Могут ли служебные роли из инструментария пайплайна данных легко получить доступ к секретам? Убедитесь, что вы включили AIM для каждого облачного компонента в свою модель угроз (например, спросите себя: как вы можете повысить привилегии с помощью этого компонента?). Смотрите [эту запись в блоге] (https://xebia.com/ten-pitfalls-you-should-look-out-for-in-aws-iam/), чтобы узнать, что можно и чего нельзя делать с примерами.

Эффективно используйте временные возможности участников IAM: например, убедитесь, что только определенные роли и учетные записи служб, которым это требуется, могут получить доступ к секретам. Следите за этими учетными записями, чтобы определить, кто или что использовало их для доступа к секретам.

Затем убедитесь, что у вас есть доступ к вашим секретам: нельзя просто разрешить доступ ко всем секретам. В GCP и AWS вы можете создать детализированные политики доступа, чтобы гарантировать, что участник не сможет получить доступ ко всем секретам сразу. В Azure доступ к хранилищу ключей означает доступ ко всем секретам в этом хранилище ключей. Таким образом, при работе в Azure важно иметь отдельные хранилища ключей для разделения доступа.

### 4.4 Ограничения API

Облачные сервисы, как правило, могут предоставлять ограниченное количество вызовов API в течение определенного периода времени. Если вы столкнетесь с этими ограничениями, вы можете столкнуться с трудностями. Большинство из этих ограничений применимы к учетной записи, проекту или подписке, поэтому распределите нагрузку, чтобы соответствующим образом ограничить радиус доступа. Кроме того, некоторые службы могут поддерживать кэширование ключей данных, что предотвращает нагрузку на API службы управления ключами (см., например, [кэширование ключей данных AWS](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/data-key-caching.html)). Некоторые службы могут использовать встроенное кэширование ключей данных. [S3 - один из таких примеров](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucket-key.html).

## 5 Контейнеры и оркестраторы

Вы можете обогатить контейнеры секретами несколькими способами: во время сборки (не рекомендуется) и во время оркестровки/развертывания.

### 5.1 Внедрение секретов (файловых, в памяти)

Существует три способа получить доступ к секретам приложения внутри контейнера docker.

- Смонтированные тома (файл): С помощью этого метода мы храним наши секреты в определенном конфигурационном/секретном файле и монтируем этот файл в наш экземпляр как смонтированный том. Убедитесь, что эти модули монтируются с помощью оркестратора и никогда не являются встроенными, так как это приведет к утечке информации об определении контейнера. Вместо этого убедитесь, что оркестратор при необходимости монтируется в томе.
- Извлечение из секретного хранилища (в памяти): стороннее приложение / контейнер извлекает необходимые ему секреты непосредственно из службы secret manager, не обращаясь к конфигурации docker. Это решение позволяет вам использовать динамически создаваемые секреты, не беспокоясь о том, что они будут доступны для просмотра из файловой системы или проверки переменных среды контейнера docker.
- Переменные среды: мы можем предоставлять секреты непосредственно как часть конфигурации контейнера docker. Примечание: сами секреты никогда не следует жестко кодировать с помощью команд docker ENV или docker ARG, поскольку они могут легко просочиться вместе с определениями контейнера. Также ознакомьтесь с проблемами Docker в разделе [WrongSecrets](https://github.com/OWASP/wrongsecrets). Вместо этого позвольте орестратору перезаписать переменную среды фактическим значением secret и убедитесь, что это не жестко запрограммировано. Кроме того, переменные среды, как правило, доступны для всех процессов и могут быть включены в журналы или системные дампы. Поэтому использование переменных окружения не рекомендуется, если только другие методы невозможны.

### 5.2 Короткоживущие сторонние контейнеры

Чтобы внедрить секреты, вы могли бы создать короткоживущие сторонние контейнеры, которые извлекают секреты из какой-либо удаленной конечной точки и затем сохраняют их на общем томе, подключенном к исходному контейнеру. Исходный контейнер теперь может использовать секреты из подключенного тома. Преимущество использования этого подхода заключается в том, что нам не нужно интегрировать какой-либо сторонний инструмент или код для получения секретов. Как только сторонний контейнер извлек секреты, он завершает работу. Примерами этого могут служить [Vault Agent Sidecar Injector](https://developer.hashicorp.com/vault/docs/platform/k8s/injector) и [Conjur Secrets Provider](https://github.com/cyberark/secrets-provider-for-k8s). При монтаже secrets на том, который используется совместно с модулем, контейнеры внутри модуля могут использовать secrets без ведома менеджера секретов.

### 5.3 Внутренний и внешний доступ

Вы должны предоставлять секретные данные только механизмам связи между контейнером и представлением развертывания (например, модулю Kubernetes). Никогда не предоставляйте секретные данные с помощью внешних механизмов доступа, которые используются совместно между развертываниями или организаторами (например, общий том).

Когда orchestrator хранит секреты (например, секреты Kubernetes), убедитесь, что серверная часть orchestrator зашифрована и вы правильно управляете ключами. Дополнительную информацию смотрите в [Руководстве по безопасности Kubernetes](Kubernetes_Security_Cheat_Sheet.md).

## 6 Руководство по внедрению

В этом разделе мы обсудим внедрение. Обратите внимание, что при фактическом внедрении всегда лучше обращаться к официальной документации выбранной системы управления секретами, поскольку она будет более актуальной, чем любой дополнительный документ, такой как эта шпаргалка.

### 6.1 Основные принципы управления материальными ресурсами

Управление ключами обсуждается в [Шпаргалке по управлению ключами](Key_Management_Cheat_Sheet.md)

### 6.2 Динамические и статические варианты использования

Среди прочих, мы видим следующие варианты использования динамических секретов:

- короткоживущие секреты (например, учетные данные или ключи API) для вторичной службы, которые выражают намерение подключить основную службу (например, потребителя) к сервису.
- короткоживущие средства управления целостностью и шифрованием для защиты процессов обмена данными в памяти и во время выполнения. Подумайте о ключах шифрования, срок действия которых должен составлять всего один сеанс или один период развертывания.
- это учетные данные с коротким сроком действия для создания стека во время развертывания службы для взаимодействия с разработчиками и поддерживающей инфраструктурой.

Обратите внимание, что эти динамические секреты часто необходимо создавать с помощью службы, к которой нам нужно подключиться. Для создания динамических секретов такого типа нам обычно требуются долгосрочные статические секреты для создания самих динамических секретов. Другие варианты использования статических секретов:

- ключевые материалы, срок службы которых превышает срок одного развертывания из-за характера их использования при взаимодействии с другими экземплярами той же службы (например, ключи шифрования хранилища, ключи TLS PKI).
- ключевые материалы или учетные данные для подключения к службам, которые не поддерживают создание временных ролей или учетных данных.

### 6.3 Убедитесь в наличии ограничений

Секретные данные никогда не должны быть доступны для всех и вся. Всегда следите за тем, чтобы вы устанавливали защитные барьеры:

- Есть ли у вас возможность создавать политики доступа? Убедитесь, что существуют политики, ограничивающие количество объектов, которые могут считывать или записывать секретные данные. В то же время напишите правила таким образом, чтобы вы могли легко их расширять и чтобы они были не слишком сложными для понимания.
- Нет ли способа сократить доступ к определенным секретам в рамках решения для управления секретами? Рассмотрите возможность разделения секретов производства и разработки, используя отдельные решения для управления секретами. Затем сократите доступ к решению для управления секретами производства.

### 6.4 Мониторинг событий безопасности является ключевым фактором

Постоянно отслеживайте, кто/ что, с какого IP и каким способом получает доступ к секретной информации. Существуют различные шаблоны, на которые вам следует обратить внимание, например, но не ограничиваясь ими:

- Отслеживайте, кто получает доступ к секретной информации в системе управления секретной информацией: это нормальное поведение? Если учетные данные CI/CD используются для доступа к решению secret management с другого IP-адреса, отличного от того, на котором запущена система CI/CD, отправьте предупреждение безопасности и предположите, что секрет взломан.
- Отслеживайте службу, для которой требуется секрет (если это возможно), например, приходит ли пользователь с ожидаемого IP-адреса с ожидаемым агентом пользователя. Если нет, предупредите и предположите, что секрет взломан.

### 6.5 Usability

Убедитесь, что ваше решение для управления секретами простое в использовании, поскольку вы не хотите, чтобы люди обходили его или использовали неэффективно из-за сложности. Для удобства использования требуется:

- Простое внедрение новых секретов и удаление недействительных секретов.
- Простая интеграция с существующим программным обеспечением: должно быть легко интегрировать приложения в качестве пользователей системы secret management. Например, для взаимодействия с системой secret management должен быть доступен SDK или простой контейнер с коляской, чтобы существующее программное обеспечение было независимым и не требовало значительных изменений. Вы можете найти примеры этого в пакетах SDK для AWS, Google и Azure. Эти пакеты SDK позволяют приложению взаимодействовать с соответствующими решениями для управления секретами. Вы можете найти похожие примеры в программах интеграции программного обеспечения Vault от HashiCorp и [Vault Agent Sidecar Injector](https://developer.hashicorp.com/vault/docs/platform/k8s/injector), а также в программах интеграции Conjur и [Conjur Secrets Provider](https://github.com/cyberark/secrets-provider-for-k8s).
- Очень важно иметь четкое представление об организации управления секретами и связанных с этим процессах.

## 7 Шифрование

Управление секретами идет рука об руку с шифрованием. В конце концов, секреты должны храниться где-то в зашифрованном виде, чтобы защитить их конфиденциальность и целостность.

### 7.1 Используемые типы шифрования

Вы можете использовать различные типы шифрования для защиты секрета, если они обеспечивают достаточную безопасность, включая достаточную устойчивость к атакам, основанным на квантовых вычислениях. Учитывая, что это динамичная область, лучше всего обратиться к таким источникам, как [keylength.com](https://www.keylength.com/en/4 /), в котором перечислены актуальные рекомендации по использованию типов шифрования и длин ключей для существующих стандартов, а также [Коммерческий пакет алгоритмов национальной безопасности 2.0] от NSA (https://media.defense.gov/2022/Sep/07/2003071834/-1/-1/0/CSA_CNSA_2.0_ALGORITHMS_.PDF), в котором перечислены алгоритмы, устойчивые к квантовой обработке.

Пожалуйста, обратите внимание, что во всех случаях нам желательно выбрать алгоритм, который обеспечивает шифрование и конфиденциальность одновременно, например, AES-256 с использованием GCM [(Режим счетчика Галлуа)].(https://en.wikipedia.org/wiki/Galois/Counter_Mode ), или смесь ChaCha20 и Poly1305 в соответствии с лучшими практиками в данной области.

### 7.2 Конвергентное шифрование

[Конвергентное шифрование] (https://en.wikipedia.org/wiki/Convergent_encryption) гарантирует, что данный открытый текст и его ключ приведут к одному и тому же зашифрованному тексту. Это может помочь обнаружить возможное повторное использование секретных данных, в результате чего будет получен тот же зашифрованный текст.
Проблема, связанная с включением конвергентного шифрования, заключается в том, что оно позволяет злоумышленникам использовать систему для генерации набора криптографических строк, которые могут в конечном итоге оказаться одним и тем же секретом, что позволяет злоумышленнику получить секрет в виде обычного текста. Учитывая алгоритм и ключ, вы можете снизить этот риск, если используемая вами конвергентная криптосистема требует достаточных ресурсов при шифровании. Еще одним фактором, который может помочь снизить риск, является обеспечение достаточной длины секрета, что еще больше сокращает возможное время, необходимое для повторения попыток.

### 7.3 Где хранить ключи шифрования?

Не следует хранить ключи рядом с секретами, которые они зашифровывают, за исключением случаев, когда эти ключи зашифрованы сами по себе (см. раздел "Шифрование преобразования"). Для начала ознакомьтесь с [Шпаргалкой по управлению ключами] (Key_Management_Cheat_Sheet.md) о том, где и как хранить ключи шифрования и возможные ключи HMAC.

### 7.4 Шифрование как услуга (Eaas)

EAAs - это модель, при которой пользователи подписываются на облачную службу шифрования без необходимости устанавливать шифрование в своих собственных системах. Используя EAAs, вы можете получить следующие преимущества:

- Шифрование в режиме ожидания
- Шифрование в процессе передачи (TLS)
- Обработкой ключей и криптографическими реализациями занимается Служба шифрования, а не разработчики
- Поставщик может добавить дополнительные службы для взаимодействия с конфиденциальными данными

## 8 Обнаружение

Существует множество подходов к обнаружению секретов и несколько очень полезных проектов с открытым исходным кодом, которые помогут в этом. Проект [Yelp Detect Secrets](https://github.com/Yelp/detect-secrets) является зрелым и имеет соответствующие подписи примерно для 20 секретов. Для получения дополнительной информации о других инструментах, которые помогут вам в поиске, ознакомьтесь с разделом [Обнаружение секретов](https://github.com/topics/secrets-detection) на GitHub.

### 8.1 Общие подходы к обнаружению

Принципы Shift-left и DevSecOps также применимы к обнаружению секретов. Приведенные ниже общие подходы направлены на то, чтобы учитывать секреты на ранней стадии и развивать практику с течением времени.

- Создайте стандартные тестовые секреты и используйте их повсеместно в организации. Это позволяет снизить количество ложных срабатываний, поскольку для каждого типа секретов требуется отслеживать только один тестовый секрет.
- Рассмотрите возможность включения обнаружения секретов на уровне разработчика, чтобы избежать проверки секретов в коде перед фиксацией/PR либо в среде IDE, либо в рамках разработки на основе тестирования, либо с помощью перехвата перед фиксацией.
- Сделайте обнаружение секретов частью модели угроз. Рассматривайте секреты как часть поверхности атаки во время упражнений по моделированию угроз.
- Часто оценивайте утилиты обнаружения и связанные с ними сигнатуры, чтобы убедиться, что они соответствуют ожиданиям.
- Рассмотрите возможность использования более чем одной утилиты обнаружения и сопоставления результатов для выявления потенциальных слабых мест в системе обнаружения.
- Соблюдайте баланс между энтропией и простотой обнаружения. Секреты с согласованными форматами легче обнаруживать благодаря более низкому проценту ложных срабатываний, но вы также не хотите пропустить созданный человеком пароль просто потому, что он не соответствует вашим правилам обнаружения.

### 8.2 Типы секретов, которые необходимо обнаружить

Существует много типов секретов, и вам следует учитывать подписи для каждого из них, чтобы обеспечить точное обнаружение всех. Среди наиболее распространенных типов:

- Секреты высокой доступности (токены, которые трудно изменить)
- Файлы конфигурации приложения
- Строки подключения
- Ключи API
- Учетные данные
- Пароли
- Ключи 2FA
- Закрытые ключи (например, SSH-ключи)
- Токены сеанса
- Типы секретов, зависящие от платформы (например, Amazon Web Services, Google Cloud)

Чтобы узнать больше о секретах и попрактиковаться в их устранении, ознакомьтесь с проектом [Неправильные секреты](https://owasp.org/www-project-wrongsecrets/).

### 8.3 Жизненный цикл обнаружения

Секреты подобны любому другому токену авторизации. Они должны:

- Существуют только столько, сколько необходимо (часто меняются)
- Есть способ автоматической ротации
- Видны только тем, кто в них нуждается (наименьшие привилегии)
- Могут быть отозваны (включая регистрацию попыток использования отозванного секретного файла)
- Никогда не будут зарегистрированы (необходимо использовать либо шифрование, либо маскировку, чтобы избежать регистрации секретных файлов в виде открытого текста)

Создайте правила обнаружения для каждого из этапов жизненного цикла секретной информации.

### 8.4 Документация о том, как обнаруживать секреты

Создайте документацию и регулярно обновляйте ее, чтобы информировать сообщество разработчиков о процедурах и системах, доступных в вашей организации, а также о том, какие типы управления секретами вы ожидаете, как проверять на наличие секретов и что делать в случае обнаружения секретов.

Документация должна:

- Существовать и часто обновляться, особенно в связи с инцидентами
- Включать следующую информацию:
    - Кто имеет доступ к секретной информации
    - Как происходит ее ротация
    - Какие-либо восходящие или нисходящие зависимости, которые потенциально могут быть нарушены во время ротации секретной информации
    - Кто является контактным лицом во время инцидента
    - Влияние раскрытия информации на безопасность

- Определите, когда с секретами можно обращаться по-разному в зависимости от угрозы, классификации данных и т.д.

## 9 Реагирование на инциденты

Быстрое реагирование в случае раскрытия секретной информации, пожалуй, является одним из наиболее важных факторов при управлении секретами.

### 9.1 Документация

Реагирование на инциденты в случае разглашения секретной информации должно гарантировать, что все в цепочке поставок осведомлены и понимают, как реагировать. Это касается создателей приложений (каждого члена команды разработчиков), информационной безопасности и технологического руководства.

Документация должна включать в себя:

- Как проверять наличие секретов и как обращаться с секретами, особенно при проверке непрерывности бизнеса.
- Кого предупреждать при обнаружении секретов.
- Шаги, которые необходимо предпринять для предотвращения утечки
- Информацию, которую необходимо регистрировать во время мероприятия

### 9.2 Исправление

Основной целью реагирования на инцидент является быстрое реагирование и локализация.

Защита должна осуществляться в соответствии со следующими процедурами:

1. Аннулирование: Ключи, которые были раскрыты, должны быть немедленно аннулированы. Секретная информация должна быть быстро удалена, и должны быть установлены системы для определения статуса аннулирования.
2. Ротация: Новый секрет должен быть доступен для быстрого создания и внедрения, предпочтительно с помощью автоматизированного процесса, чтобы обеспечить повторяемость, низкий уровень ошибок при внедрении и минимальные привилегии (недоступные для непосредственного восприятия человеком).
3. Удаление: Отозванные/измененные данные должны быть немедленно удалены из открытой системы, включая данные, обнаруженные в коде или логах. У секретов в коде может быть история коммитов, доступ к которым был заблокирован до введения секрета, однако это может привести к другим проблемам, поскольку переписывает историю git и приведет к разрыву любых других ссылок на данный коммит. Если вы решите это сделать, знайте о последствиях и планируйте соответствующим образом. Секретные данные в журналах должны иметь процесс удаления секретных данных при сохранении целостности журнала.
4. Ведение журнала: Группы реагирования на инциденты должны иметь доступ к информации о жизненном цикле секретной информации, чтобы помочь в ее сохранении и устранении, в том числе:
    - У кого был доступ?
    - Когда они ее использовали?
    - Когда она была изменена ранее?

### 9.3 Ведение журнала

Дополнительные соображения по ведению журнала использования секретных данных должны включать в себя:

- Ведение журнала для реагирования на инциденты должно осуществляться в одном месте, доступном командам реагирования на инциденты (IR)
- Обеспечение точности записи информации в журнал во время учений команды purple, таких как:
    - Что должно было быть зарегистрировано?
    - Что на самом деле было зарегистрировано?
    - Есть ли у нас адекватные средства оповещения, чтобы обеспечить это?

Рассмотрите возможность использования стандартизированного формата ведения журнала и словаря, такого как [Шпаргалка по ведению журнала](Logging_Vocabulary_Cheat_Sheet.md), чтобы обеспечить регистрацию всей необходимой информации.

## 10 Похожие шпаргалки и дополнительная литература

- [Шпаргалка для управления ключами](Key_Management_Cheat_Sheet.md)
- [Шпаргалка для ведения журнала](Logging_Cheat_Sheet.md)
- [Шпаргалка для хранения паролей](Password_Storage_Cheat_Sheet.md)
- [Шпаргалка для криптографического хранилища](Cryptographic_Storage_Cheat_Sheet.md)
- [Проект OWASP WrongSecrets project](https://github.com/OWASP/wrongsecrets/)
- [Блог: 10 советов по управлению секретами](https://xebia.com/blog/secure-deployment-10-pointers-on-secrets-management/)
- [Блог: От сборки до запуска: советы по безопасному развертыванию](https://xebia.com/from-build-to-run-pointers-on-secure-deployment/)
- [Список инструментов обнаружения секретов на Github](https://github.com/topics/secrets-detection)
- [Рекомендации NIST SP 800-57 по управлению ключами](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)
- [Ссылки на секреты в OpenCRE](https://opencre.org/cre/223-780)