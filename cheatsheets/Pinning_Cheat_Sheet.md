# Шпаргалка по закреплению

## Вступление

Шпаргалка по пиннингу - это техническое руководство по реализации пиннинга сертификатов и открытых ключей, о котором говорил Джеффри Уолтон на презентации отделения в Вирджинии [Securing Wireless Channels in the Mobile Space](https://wiki.owasp.org/images/8/8f/Securing-Wireless-Channels-in-the-Mobile-Space.ppt). Это руководство нацелено на предоставление четких, простых и выполнимых рекомендаций по защите канала во враждебной среде, где участники могут быть злонамеренными, а конференция доверия - это ответственность.

## В чем проблема

Пользователи, разработчики и приложения ожидают, что их каналы связи будут защищены, но некоторые каналы могут не соответствовать этим ожиданиям. Каналы, построенные с использованием хорошо известных протоколов, таких как SSL и TLS, могут быть уязвимы для атак типа "Человек посередине" (MITM), если доверие, основанное на сертификатах, используется не по назначению. Вредоносные атаки бывают двух видов:

1. Злоумышленник может получить поддельный цифровой сертификат от доверенного центра сертификации (CA) от имени сайта-жертвы;
2. Злоумышленник может внедрить опасный CA в хранилище доверенных данных клиента.

В случае последней проблемы злоумышленник, имеющий доступ к обновлению хранилища доверенных данных, получит доступ к изменению работы мобильного приложения, что потенциально может помешать закреплению.

Как видно из [Привязки сертификата и открытого ключа](https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning), эта проблема очень незначительна благодаря многолетним достижениям в области безопасности, достигнутым центром сертификации и сообществом браузеров.

## Что такое Закрепление

Закрепление - это процесс привязки хоста к его *ожидаемому* сертификату X509 или открытому ключу. Как только сертификат или открытый ключ становится известен или просматривается для хоста, сертификат или открытый ключ связывается или "закрепляется" с хостом. Если допустимо использование более чем одного сертификата или открытого ключа, то программа содержит *набор pin-кодов* (взято из [Jon Larimer and Kenny Root Google I/O talk](https://www.youtube.com/watch?v=RPJENzweI-A)). В этом случае объявленные учетные данные должны соответствовать одному из элементов набора pin-кодов.

### Когда следует добавлять пин

Сертификат или открытый ключ хоста или службы может быть добавлен в приложение во время разработки, он может быть добавлен при первом обнаружении сертификата или открытого ключа (подход, широко известный как “Доверие при первом использовании”, или TOFU), или он может добавляться и обновляться в режиме реального времени с помощью открепленный канал. Первый вариант - добавление во время разработки - предпочтительнее, поскольку предварительная загрузка сертификата или открытого ключа вне зоны доступа обычно означает, что злоумышленник не сможет испортить pin.

Имейте в виду, что это "когда" означает, в какой момент времени вы закрепляете. Первый вопрос должен звучать так: “Следует ли мне закрепить?”. Ответ на этот вопрос, вероятно, будет "никогда".

### Когда следует выполняеть закрепление

Практически не существует ситуаций, когда вам следовало бы рассмотреть возможность закрепления. Риск сбоев в работе почти всегда перевешивает любые риски для безопасности, учитывая достижения в области безопасности. Если вы рассматриваете возможность закрепления, вам следует прочитать [Закрепление сертификата и открытого ключа](https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning) и полностью разобраться в модели угроз.

### Когда не следует закреплять?

- Если вы не контролируете подключение на стороне клиента и сервера, не закрепляйте.
- Если вы не можете безопасно обновить набор контактов, не закрепляйте.
- Если обновление набора контактов приводит к сбоям в работе, например, требует повторного развертывания приложения, возможно, не закрепляйте. (Возможным исключением является случай, когда вы контролируете повторное развертывание приложения, например, при принудительном обновлении в рамках корпорации.)
- Если невозможно заранее предсказать пару ключей сертификата до того, как она будет введена в эксплуатацию, не закрепляйте ее.
- Если это не нативное мобильное приложение, не закрепляйте его.

### Когда следует применять исключения

Если вы работаете в организации, которая практикует «фильтрацию на выходе» в рамках стратегии предотвращения потери данных (DLP), вы, скорее всего, столкнетесь с *прокси-перехватчиками*. Нам нравится называть эти вещи **«хорошими» плохими актерами** (в отличие от **«плохих» плохих актеров**), поскольку и те, и другие нарушают сквозную безопасность, и мы не можем их отличить. В этом случае **не** предлагайте внести прокси-перехватчик в список разрешенных, поскольку это противоречит вашим целям безопасности. Добавьте открытый ключ прокси-перехватчика в свой pinset после того, как вас **проинструктируют** сделать это люди из отдела принятия рисков.

### Как закреплять

Идея состоит в том, чтобы повторно использовать существующие протоколы и инфраструктуру, но использовать их более жестким образом. При повторном использовании программа продолжала бы выполнять те же действия, что и при установлении безопасного соединения.

Чтобы упростить работу канала, программа может воспользоваться обратным вызовом `OnConnect`, предлагаемым библиотекой, фреймворком или платформой. При обратном вызове программа проверяет личность удаленного хоста, проверяя его сертификат или открытый ключ. Смотрите [некоторые примеры](#examples-of-pinning) ниже.

### Что должно быть закреплено

Чтобы решить, что именно следует закрепить, выполните следующие действия.

1. Определите, к какому сертификату вы хотите прикрепить корневой ЦС, промежуточный ЦС или листовой сертификат:

- Закрепление **корневого ЦС** обычно не рекомендуется, поскольку это сильно повышает риск, так как подразумевает доверие ко всем промежуточным ЦС.
- Закрепление конкретного **выпускающего или промежуточного ЦС** снижает риск, но приложение будет доверять и другим сертификатам, выпущенным этим ЦС или под-ЦС, а не только тем, которые предназначены для вашего приложения.
- Рекомендуется привязывать **листовой сертификат**, но он должен содержать резервные копии (например, промежуточный ЦС или набор сертификатов, содержащий альтернативы). Это обеспечивает 100-процентную уверенность в том, что приложение доверяет исключительно удаленным узлам, для подключения к которым оно было разработано, и одновременно повышает отказоустойчивость при обходе отказа или ротации сертификатов.

Например, приложение закрепляет конечный сертификат удаленной конечной точки, но включает резервный pin-код для промежуточного центра сертификации. Это увеличивает риск, поскольку доверяет большему количеству центров сертификации, но снижает вероятность блокировки вашего приложения. Если возникнет какая-либо проблема с сертификатом leaf, приложение всегда может обратиться к промежуточному центру сертификации до тех пор, пока вы не выпустите обновление приложения.

2. Выберите, хотите ли вы закрепить **весь сертификат** или только его **открытый ключ**.

3. Если вы выбрали открытый ключ, у вас есть два дополнительных варианта:

- Закрепите `SubjectPublicKeyInfo`.
- Закрепите один из конкретных типов, например `RSAPublicKey` или `DSAPublicKey`.

Ниже более подробно описаны три варианта выбора. Рекомендуется закрепить `SubjectPublicKeyInfo`, поскольку он содержит общедоступные параметры (такие как `{e,n}` для открытого ключа RSA) **и** контекстную информацию, такую как алгоритм и OID. Иногда контекст поможет вам сориентироваться, а на рисунке справа показана доступная дополнительная информация.

#### Сертификат

Закрепить сертификат проще всего с помощью pin-кода. Вы можете получить сертификат на веб-сайте, попросить ИТ-специалистов отправить вам сертификат вашей компании по электронной почте, использовать `openssl s_client` для получения сертификата и т.д. Во время выполнения вы можете получить сертификат веб-сайта или сервера с помощью обратного вызова. В ходе обратного вызова вы сравниваете полученный сертификат с сертификатом, встроенным в программу. Если сравнение завершается неудачно, а затем завершается сбой метода или функции, зарегистрируйте его на стороне клиента и предупредите конечного пользователя. Если ваша модель угроз требует закрепления, имейте в виду, что пользователи будут нажимать на любые предупреждения, поэтому не давайте пользователю возможности продолжить и обойти пин-код.

**Преимущества:**

- Это может быть проще в реализации, чем другие методы, особенно в таких языках, как Cocoa/CocoaTouch и OpenSSL.

**Недостатки:**

- Если сайт регулярно обновляет свой сертификат, то ваше приложение необходимо будет регулярно обновлять. Если вы не будете контролировать, когда этот сертификат будет введен в эксплуатацию, закрепление приведет к сбою в работе.

#### Public Key

Закрепление открытого ключа является более гибким, но немного сложнее из-за дополнительных шагов, необходимых для извлечения открытого ключа из сертификата. Как и в случае с сертификатом, программа сверяет извлеченный открытый ключ со встроенной копией открытого ключа. Учитывая, что большинство современных сертификатов действительны только в течение 90 дней, использование закрепления открытого ключа также может увеличить сроки обновления наборов пин-кодов, поскольку вы можете закрепить ключ, когда сертификат еще даже не был выдан.

**Преимущества:**

- Это позволяет получить доступ к параметрам открытого ключа (таким как `{e,n}` для открытого ключа RSA) и контекстной информации, такой как алгоритм и OID.
- Это более гибко, чем привязка сертификата. PIN-код может быть рассчитан задолго до выдачи сертификата, и, если это позволяет политика, сертификат может быть обновлен с использованием того же ключа, чтобы избежать нарушения процесса закрепления. Последнее является неправильной практикой управления ключами и должно использоваться только в экстренных случаях.

**Недостатки:**

- Работать с ключами может быть сложнее (по сравнению с сертификатами), поскольку вы должны извлекать ключ из сертификата. Извлечение является небольшим неудобством в Java и .Net, но оно неудобно в iOS Cocoa/Cocoa Touch framework и OpenSSL.
- Некоторые поставщики услуг генерируют новые ключи при обновлении, что делает невозможным предварительное кэшированиеe.

#### Хэш

Хотя в трех приведенных выше вариантах использовалась кодировка DER, также допустимо использовать хэширование информации. На самом деле, исходные примеры программ были написаны с использованием обработанных сертификатов и открытых ключей. Образцы были изменены, чтобы позволить программисту проверять объекты с помощью таких инструментов, как `dumpasn1` и других декодеров ASN.1.

**Преимущества:**

- Он удобен в использовании. Обработанный отпечаток сертификата часто доступен в качестве встроенного API для многих библиотек.
- Хэш имеет небольшой размер и фиксированную длину.

**Недостатки:**

- Нет доступа к параметрам открытого ключа или контекстной информации, такой как алгоритм Android, который может потребоваться в определенных случаях использования.
- Если сайт регулярно обновляет свой сертификат, то ваше приложение необходимо будет регулярно обновлять. Если вы не проконтролируете, когда этот сертификат будет введен в эксплуатацию, то закрепление приведет к сбою в работе.

## Примеры закрепления

В этом разделе обсуждается привязка сертификата и открытого ключа в Android, Java, iOS, .Net и OpenSSL. Для краткости код опущен, но выделены ключевые моменты для платформы.

### Android

Начиная с Android N, предпочтительным способом реализации закрепления является использование функции Android [Настройка сетевой безопасности](https://developer.android.com/training/articles/security-config.html), которая позволяет приложениям настраивать параметры сетевой безопасности в безопасном декларативном файле конфигурации без изменения кода приложения.

Чтобы включить закрепление, можно использовать [параметр конфигурации `<pin-set>`](https://developer.android.com/training/articles/security-config.html#CertificatePinning).

В качестве альтернативы вы можете использовать такие методы, как закрепление с помощью OkHttp, чтобы программно установить определенные пин-коды, как описано в [Руководстве по тестированию мобильной безопасности OWASP (MSTG)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05g-Testing-Network-Communication.md#network-libraries-and-webviews) и [документации OkHttp](https://square.github.io/okhttp/3.x/okhttp/okhttp3/CertificatePinner.html).

В документации по Android приведен пример того, как можно настроить проверку SSL в коде приложения (для реализации закрепления) в [Неизвестном документе о внедрении CA](https://developer.android.com/training/articles/security-ssl.html#UnknownCa). Однако следует избегать внедрения проверки с привязкой с нуля, поскольку вероятность ошибок при внедрении чрезвычайно высока и обычно приводит к серьезным уязвимостям.

Наконец, если вы хотите проверить, успешно ли выполнено закрепление, пожалуйста, следуйте инструкциям из глав [введение в сеть тестирования communication](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04f-Testing-Network-Communication.md#testing-network-communication) и [Сеть, специфичная для Android testing](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05g-Testing-Network-Communication.md) Руководства по тестированию мобильной безопасности OWASP (MSTG).

### iOS

Apple предлагает закрепить открытый ключ CA, указав его в файле `Info.plist` в разделе [Безопасность транспорта приложений Settings](https://developer.apple.com/documentation/security/preventing_insecure_network_connections). Подробнее в статье ["Закрепление идентификационных данных: как настроить серверные сертификаты для вашего приложения"](https://developer.apple.com/news/?id=g9ejcf8y).

[Trust Kit](https://github.com/datatheorem/Trust) Доступна библиотека SSL-закрепления с открытым исходным кодом Kit для iOS и macOS. Она предоставляет простой в использовании API для реализации закрепления и была развернута во многих приложениях.

В противном случае, более подробная информация о том, как можно настроить проверку SSL в iOS (для реализации закрепления), доступна в техническом примечании [Оценка доверия к HTTPS-серверу](https://developer.apple.com/library/content/technotes/tn2232/_index.html). Однако следует избегать внедрения проверки с привязкой с нуля, поскольку вероятность ошибок при внедрении чрезвычайно высока и обычно приводит к серьезным уязвимостям.

Наконец, если вы хотите проверить, успешно ли выполнено закрепление, следуйте инструкциям из разделов [Введение в тестирование сетевого взаимодействия] (https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04f-Testing-Network-Communication.md#testing-network-communication) и [Тестирование сети под iOS] (https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06g-Testing-Network-Communication.md) руководства OWASP Mobile Security Testing Guide (MSTG).

### .Net

Закрепление .Net может быть достигнуто с помощью [`ServicePointManager`](https://docs.microsoft.com/en-us/dotnet/api/system.net.servicepointmanager?view=netframework-4.7.2). Пример можно найти на странице [OWASP MSTG](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05g-Testing-Network-Communication.md#xamarin-applications).

Загрузите [Пример программы .Net](../assets/Pinning_Cheat_Sheet_Certificate_DotNetSample.zip).

### OpenSSL

Закрепление может происходить в одном из двух мест с помощью OpenSSL. Во-первых, пользователь вводит `verify_callback`. Во-вторых, после установления соединения через `SSL_get_peer_certificate`. Любой из этих методов позволит вам получить доступ к сертификату однорангового узла.

Несмотря на то, что OpenSSL выполняет проверку на соответствие стандарту X509, вы должны прервать соединение и отключить сокет в случае ошибки. По замыслу, сервер, который не предоставляет сертификат, приведет к `X509_V_OK` с **NULL** сертификатом. Чтобы проверить результат обычной проверки:

1. Вы должны вызвать `SSL_get_verify_result` и убедиться, что возвращаемый код равен `X509_V_OK`;
2. Вы должны вызвать `SSL_get_peer_certificate` и убедиться, что сертификат не является `NOT NULL`.

Скачать: [Пример программы на OpenSSL](../assets/Pinning_Cheat_Sheet_Certificate_OpenSSLSample.zip).

### Electron

[electron-ssl-pinning](https://github.com/dialogs/electron-ssl-pinning) - библиотека SSL-закрепления с открытым исходным кодом для приложений на базе [Electron](https://electronjs.org). Она предоставляет простой в использовании API для реализации закрепления, а также инструмент для выбора конфигурации на основе необходимых хостов.

В противном случае вы можете проверить сертификаты самостоятельно, используя [sets.setCertificateVerifyProc(proc)](https://electronjs.org/docs/api/session#sessetcertificateverifyprocproc).

## Ссылки на литературу

- OWASP [Injection Theory](https://owasp.org/www-community/Injection_Theory)
- OWASP [Data Validation](https://wiki.owasp.org/index.php/Data_Validation)
- OWASP [Transport Layer Security Cheat Sheet](Transport_Layer_Security_Cheat_Sheet.md)
- OWASP [Mobile Security Testing Guide](https://github.com/OWASP/owasp-mstg)
- IETF [RFC 1421 (PEM Encoding)](http://www.ietf.org/rfc/rfc1421.txt)
- IETF [RFC 4648 (Base16, Base32, and Base64 Encodings)](http://www.ietf.org/rfc/rfc4648.txt)
- IETF [RFC 5280 (Internet X.509, PKIX)](http://www.ietf.org/rfc/rfc5280.txt)
- IETF [RFC 3279 (PKI, X509 Algorithms and CRL Profiles)](http://www.ietf.org/rfc/rfc3279.txt)
- IETF [RFC 4055 (PKI, X509 Additional Algorithms and CRL Profiles)](http://www.ietf.org/rfc/rfc4055.txt)
- IETF [RFC 2246 (TLS 1.0)](http://www.ietf.org/rfc/rfc2246.txt)
- IETF [RFC 4346 (TLS 1.1)](http://www.ietf.org/rfc/rfc4346.txt)
- IETF [RFC 5246 (TLS 1.2)](http://www.ietf.org/rfc/rfc5246.txt)
- IETF [PKCS #1: RSA Cryptography Specifications Version 2.2](https://tools.ietf.org/html/rfc8017)
