# Шпаргалка по управлению уязвимыми зависимостями

## Вступление

Цель шпаргалки состоит в том, чтобы предложить подход к обработке уязвимых сторонних зависимостей при их обнаружении, и это в зависимости от конкретной ситуации.

Шпаргалка не ориентирована на инструменты, но содержит раздел [инструменты] (#Tools), информирующий читателя о бесплатных и коммерческих решениях, которые могут быть использованы для обнаружения уязвимых зависимостей, в зависимости от уровня поддержки используемых технологий

**Примечание:**

Предложения, упомянутые в этой шпаргалке, не являются универсальными (рецепты, которые работают во всех ситуациях), но могут быть использованы в качестве основы и адаптированы к вашему контексту.

## Контекст

Большинство проектов используют сторонние зависимости для делегирования обработки различного рода операций, например, генерации документа в определенном формате, обмена HTTP-сообщениями, анализа данных определенного формата и т.д.

Это хороший подход, поскольку он позволяет команде разработчиков сосредоточиться на реальном коде приложения, поддерживающем ожидаемую бизнес-функцию. Зависимость приводит к ожидаемому недостатку, от которого теперь зависит безопасность реального приложения.

Этот аспект рассматривается в следующих проектах:

- [OWASP TOP 10 2017](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/) в соответствии с пунктом *[A9 - Использование компонентов с известными Vulnerabilities](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A9-Using_Components_with_Known_Vulnerabilities.html)*.
- [Стандартный проект проверки безопасности приложений OWASP](https://owasp.org/www-project-application-security-verification-standard/) в соответствии с разделом *V14.2 Dependency*.

Исходя из этого контекста, для проекта важно убедиться, что все реализованные сторонние зависимости не содержат каких-либо проблем с безопасностью, и если они содержат какие-либо проблемы с безопасностью, команда разработчиков должна знать об этом и применять необходимые меры по устранению проблем для защиты уязвимого приложения.

Настоятельно рекомендуется выполнить автоматический анализ зависимостей с момента создания проекта. Действительно, если эта задача добавляется в середине или в конце проекта, это может повлечь за собой огромный объем работы по устранению всех выявленных проблем, что, в свою очередь, ляжет огромной нагрузкой на команду разработчиков и может привести к блокированию продвижения текущего проекта.

**Примечание:**

В остальной части шпаргалки, когда мы ссылаемся на "команду разработчиков", мы предполагаем, что в команде есть сотрудник, обладающий необходимыми навыками в области безопасности приложений, или можем сослаться на кого-то в компании, обладающего такими навыками, чтобы проанализировать уязвимость, влияющую на зависимость.

## Замечание по поводу обнаружения

Важно помнить о различных способах устранения проблемы безопасности после ее обнаружения.

### 1. Ответственное раскрытие информации

Смотрите описание [здесь](https://en.wikipedia.org/wiki/Responsible_disclosure).

Исследователь обнаруживает уязвимость в компоненте, и после совместной работы с поставщиком компонентов он выдает [CVE](https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures) (иногда для поставщика создается конкретный идентификатор уязвимости, но обычно предпочтительнее использовать идентификатор CVE), связанный с проблемой, что позволяет публиковать ссылки на проблему, а также на информацию о уязвимости. доступная фиксация/смягчение последствий.

Если поставщик услуг должным образом не сотрудничает с исследователем, ожидаются следующие результаты:

- CVE принимается поставщиком, но поставщик [отказывается устранять проблему] (https://www.excellium-services.com/cert-xlm-advisory/cve-2019-7161/).
- В большинстве случаев, если исследователь не получает ответа в течение 30 дней, он продолжает работу и делает [полное раскрытие] (#2.полное раскрытие) уязвимости.

Here, the vulnerability is always referenced in the [CVE global database](https://nvd.nist.gov/vuln/data-feeds) used, generally, by the detection tools as one of the several input sources used.

### 2. Полное раскрытие информации

Смотрите описание [здесь](https://en.wikipedia.org/wiki/Full_disclosure) в разделе **Computers**, посвященном **компьютерной безопасности**.

Исследователь принимает решение опубликовать всю информацию, включая код/метод использования, в таких сервисах, как [Список рассылки с полным раскрытием информации](https://seclists.org/fulldisclosure/), [Exploit-DB](https://www.exploit-db.com).

В этом случае CVE создается не всегда, тогда уязвимость не всегда находится в глобальной базе данных CVE, что приводит к потенциальной слепоте средств обнаружения, если только они не используют другие источники входных данных.

## Замечание о решении по решению проблемы безопасности

При обнаружении проблемы с безопасностью можно принять решение о принятии риска, связанного с этой проблемой. Однако это решение должно быть принято [Главным специалистом по рискам](https://en.wikipedia.org/wiki/Chief_risk_officer) (возможен вариант с [Главным специалистом по информационной безопасности](https://en.wikipedia.org/wiki/Chief_information_security_officer)) компании на основе технической обратной связи от команды разработчиков, которая проанализировала проблему (см. раздел *[Случаи](#cases)*), а также оценочные показатели CVEs [CVSS](https://www.first.org/cvss/user-guide).

## Случаи

При обнаружении проблемы с безопасностью команда разработчиков может столкнуться с одной из ситуаций (названных "Случай" в остальной части шпаргалки), представленных в подразделах ниже.

Если уязвимость влияет на [транзитивную зависимость](https://en.wikipedia.org/wiki/Transitive_dependency), то действие будет предпринято в отношении прямой зависимости проекта, поскольку действия в отношении транзитивной зависимости часто влияют на стабильность приложения.

Работа с переходной зависимостью требует от команды разработчиков полного понимания всей взаимосвязи/взаимодействия/использования, начиная с зависимости первого уровня проекта и заканчивая зависимостью, на которую влияет уязвимость в системе безопасности, эта задача требует очень много времени.

### Случай 1

#### Контекст

Поставщик выпустил исправленную версию компонента.

#### Идеальные условия применения подхода

Существует набор автоматизированных модульных, интеграционных, функциональных тестов или тестов безопасности для функций приложения с использованием затронутой зависимости, позволяющих проверить работоспособность функции.

#### Подход

**Шаг 1:**

Обновите версию зависимости в проекте в среде тестирования.

**Шаг 2:**

Перед запуском тестов возможны 2 пути вывода:

- Все тесты завершаются успешно, и, таким образом, обновление может быть запущено в производство.
- Один или несколько тестов завершились неудачей, возможно несколько путей вывода:
    - Сбой происходит из-за изменений в некоторых вызовах функций (например, в сигнатуре, аргументе, пакете и т.д.). Команда разработчиков должна обновить свой код, чтобы он соответствовал новой библиотеке. Как только это будет сделано, повторно запустите тесты.
    - Техническая несовместимость выпущенной зависимости (например, требуется более свежая версия среды выполнения), которая приводит к следующим действиям:
    1. Обратитесь с этим вопросом к поставщику услуг.
    2. Примените [Случай 2] (#Случай-2), ожидая ответа от поставщика.

### Случай 2

#### Контекст

Поставщик сообщает команде, что для устранения проблемы потребуется некоторое время, и поэтому исправленная версия будет доступна не раньше, чем через несколько месяцев.

#### Идеальные условия применения подхода

Поставщик может поделиться любым из приведенных ниже сведений с командой разработчиков:

- Используемый код.
- Список функций, на которые влияет уязвимость.
- Способ предотвращения использования проблемы.

#### Подход

**Шаг 1:**

Если предлагается обходной путь, его следует применить и проверить в среде тестирования, а затем внедрить в рабочую среду.

Если поставщик предоставил команде список затронутых функций, защитный код должен обернуть вызовы этих функций, чтобы гарантировать безопасность входных и выходных данных.

Более того, устройства безопасности, такие как брандмауэр веб-приложений (WAF), могут справиться с такими проблемами, защищая внутренние приложения с помощью проверки параметров и генерируя правила обнаружения для этих конкретных библиотек. Тем не менее, в этой шпаргалке основное внимание уделяется прикладному уровню, чтобы устранить уязвимость как можно ближе к источнику.

*Пример использования java-кода, в котором затронутая функция страдает от проблемы [удаленного выполнения кода (RCE)](https://www.netsparker.com/blog/web-security/remote-code-evaluation-execution/).:*

```java
public void callFunctionWithRCEIssue(String externalInput){
    //Примените проверку ввода к внешнему входу с помощью регулярного выражения
    if(Pattern.matches("[a-zA-Z0-9]{1,50}", externalInput)){
        //Вызов ошибочной функции с использованием безопасного ввода
        functionWithRCEIssue(externalInput);
    }else{
        //Регистрируйте обнаружение эксплуатации
        SecurityLogger.warn("Exploitation of the RCE issue XXXXX detected !");
        //Вызывайте исключение, приводящее к отправке клиенту общей ошибки...
    }
}
```

Если поставщик ничего не сообщил об уязвимости, можно применить [Случай 3](#-случай-3), пропустив *шаг 2* этого случая. Здесь мы предполагаем, что, по крайней мере, [CVE](https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures) был предоставлен.

**Шаг 2:**

Если поставщик предоставил команде эксплуатационный код, и команда создала защитную оболочку для уязвимой библиотеки/кода, выполните эксплуатационный код, чтобы убедиться, что библиотека теперь защищена и не влияет на работу приложения.

Если у вас есть набор автоматизированных модульных, интеграционных, функциональных тестов или тестов безопасности для приложения, запустите их, чтобы убедиться, что добавленный код защиты не влияет на стабильность приложения.

Добавьте комментарий в проект *README*, объясняющий, что проблема (укажите соответствующий [CVE](https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures)) решается во время ожидания исправленной версии, поскольку средство обнаружения будет продолжать выдавать предупреждение об этой зависимости.

**Примечание:** Вы можете добавить зависимость в список игнорируемых, но область игнорирования для этой зависимости должна охватывать только [CVE](https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures), связанную с уязвимостью, поскольку на зависимость может воздействовать несколько уязвимостей, каждая из которых имеет свой собственный [CVE](https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures).

### Случай 3

#### Контекст

Провайдер сообщает команде, что они не могут устранить проблему, поэтому исправленная версия вообще не будет выпущена (применяется также в том случае, если провайдер не хочет устранять проблему или вообще не отвечает).

В этом случае единственной информацией, предоставляемой команде разработчиков, является [CVE](https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures).

**Примечания:**

- Это действительно сложное и трудоемкое дело, к которому обычно прибегают в качестве крайней меры.
- Если затронутая зависимость является библиотекой с открытым исходным кодом, то мы, команда разработчиков, можем создать исправление и создать [Запрос на принятие изменений] (https://help.github.com/en/articles/about-pull-requests) - таким образом, мы можем защитить нашу компанию / приложение от исходного кода, а также помочь другим защитить свои приложения.

#### Идеальные условия применения подхода

Ничего конкретного, потому что здесь мы находимся в состоянии "исправь себя сам".

#### Подход

**Шаг 1:**

Если это связано с одним из следующих условий, рекомендуется провести параллельное исследование, чтобы найти другой компонент, который лучше поддерживается, или, если это коммерческий компонент с поддержкой, **оказать давление** на поставщика с помощью вашего [директора по управлению рисками].(https://en.wikipedia.org/wiki/Chief_risk_officer ) (возможно обращение к [Главному специалисту по информационной безопасности](https://en.wikipedia.org/wiki/Chief_information_security_officer)):

- Провайдер не хочет устранять проблему.
- Провайдер вообще не отвечает.

В любом случае, здесь нам нужно устранить уязвимость прямо сейчас.

**Шаг 2:**

Поскольку мы знаем уязвимую зависимость, мы знаем, где она используется в приложении (если это транзитивная зависимость, то мы можем идентифицировать зависимость первого уровня, используя ее с помощью [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment )) встроенная функция или используемая система управления зависимостями (Maven, Gradle, NuGet, npm, и т.д.). Обратите внимание, что IDE также используется для идентификации вызовов зависимости.

Выявление вызовов этой зависимости - это хорошо, но это первый шаг. Команде по-прежнему не хватает информации о том, какие исправления необходимо выполнить.

Чтобы получить эту информацию, команда использует содержимое CVE, чтобы узнать, какой тип уязвимости влияет на зависимость. Свойство `description` предоставляет ответ: SQL-инъекция, удаленное выполнение кода, межсайтовый скриптинг, подделка межсайтовых запросов и т.д.

После определения вышеуказанных 2 пунктов команда знает, какой тип исправления необходимо выполнить ([Случай 2] (#случай-2) с защитным кодом) и куда его добавить.

*Пример:*

У команды есть приложение, использующее Jackson API в версии, доступной для [CVE-2016-3720](https://nvd.nist.gov/vuln/detail/CVE-2016-3720).

Описание CVE выглядит следующим образом:

```text
XML external entity (XXE) vulnerability in XmlMapper in the Data format extension for Jackson
(aka jackson-dataformat-xml) allows attackers to have unspecified impact via unknown vectors.
(Уязвимость XML external entity (XXE) в Xml Mapper в расширении формата данных для Jackson
(оно же jackson-dataformat-xml) позволяет злоумышленникам оказывать неопределенное воздействие с помощью неизвестных векторов.)
```

Основываясь на этой информации, команда определяет, что необходимым исправлением будет добавление [предварительной проверки любых XML-данных] (XML_External_Entity_Prevention_Cheat_Sheet.md), передаваемых в Jakson API, для предотвращения уязвимости [XML external entity (XXE)](https://www.acunetix.com/blog/articles/xml-external-entity-xxe-vulnerabilities/).

**Шаг 3:**

Если возможно, создайте модульный тест, имитирующий уязвимость, чтобы убедиться в эффективности исправления и иметь возможность постоянно обеспечивать его применение в ходе развития проекта.

Если у вас есть набор автоматизированных модульных, интеграционных, функциональных тестов или тестов безопасности для приложения, запустите их, чтобы убедиться, что исправление не влияет на стабильность приложения.

### Случай 4

#### Контекст

Уязвимая зависимость обнаруживается в одной из следующих ситуаций, когда поставщик услуг не знает об уязвимости:

- Обнаружив в Интернете публикацию с полным раскрытием информации.
- Во время теста на проникновение.

#### Идеальные условия применения подхода

Провайдер сотрудничает с вами после получения уведомления об уязвимости.

#### Подход

**Шаг 1:**

Сообщите поставщику услуг об уязвимости, поделившись с ним этим сообщением.

**Шаг 2:**

Используя информацию из публикации с полным раскрытием информации или отзывов пентестера об эксплуатации, если поставщик сотрудничает, примените [Случай 2] (#случай-2), в противном случае примените [Случай 3] (#случай-3), и вместо анализа информации CVE команде необходимо проанализировать информацию из публикации "полное раскрытие информации" / отзыв пентестера об эксплуатации.

## Инструменты

В этом разделе перечислены несколько инструментов, которые можно использовать для анализа зависимостей, используемых проектом, с целью обнаружения уязвимостей.

В процессе выбора инструмента обнаружения уязвимых зависимостей важно убедиться, что этот инструмент:

- Использует несколько надежных источников входных данных, чтобы справиться с обоими способами обнаружения уязвимостей.
- Возможность помечать проблему, возникшую в компоненте, как [ложноположительную](https://www.whitehatsec.com/glossary/content/false-positive).

- Бесплатные
    - [OWASP Dependency Check](https://owasp.org/www-project-dependency-check/):
        - Полная поддержка: Java, .Net.
        - Поддерживается эксперементально: Python, Ruby, PHP (composer), NodeJS, C, C++.
    - [NPM Audit](https://docs.npmjs.com/cli/audit)
        - Полная поддержка: NodeJS, JavaScript.
        - HTML-отчет доступен с помощью этого [module](https://www.npmjs.com/package/npm-audit-html).
    - [OWASP Dependency Track](https://dependencytrack.org/) может использоваться для управления уязвимыми зависимостями в рамках всей организации.
    - [ThreatMapper](https://github.com/deepfence/ThreatMapper)
        - Полная поддержка: Base OS, Java, NodeJS, JavaScript, Ruby, Python
        - Целевые программы: Kubernetes (узлы и контейнеры), Docker (узлы и контейнеры), Fargate (контейнеры), Bare Metal/VM (хост и приложение)
- Коммерческие
    - [Snyk](https://snyk.io/) (доступен бесплатный вариант с открытым исходным кодом):
        - [Полная поддержка](https://snyk.io/docs/) для многих языков и менеджеров пакетов.
    - [JFrog XRay](https://jfrog.com/xray/):
        - [Полная поддержка](https://jfrog.com/integration/) для многих языков и менеджеров пакетов.
    - [Renovate](https://renovatebot.com) (позволяет обнаруживать старые зависимости):
        - [Полная поддержка](https://renovatebot.com/docs/) для многих языков и менеджеров пакетов.
    - [Requires.io](https://requires.io/) (позволяет обнаруживать старые зависимости - доступен открытый исходный код и бесплатная опция):
        - [Полная поддержка](https://requires.io/features/): только на Python .
