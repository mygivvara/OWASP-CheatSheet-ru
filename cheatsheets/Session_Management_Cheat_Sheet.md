# Шпаргалка по управлению сеансами

## Введение

**Веб-аутентификация, управление сеансами и контроль доступа**:

Веб-сессия - это последовательность сетевых HTTP-запросов и ответов, связанных с одним и тем же пользователем. Современные и сложные веб-приложения требуют сохранения информации или статуса о каждом пользователе в течение нескольких запросов. Таким образом, сеансы предоставляют возможность устанавливать переменные, такие как права доступа и настройки локализации, которые будут применяться к каждому взаимодействию пользователя с веб–приложением в течение всего сеанса.

Веб-приложения могут создавать сеансы для отслеживания анонимных пользователей после первого же запроса пользователя. Примером может служить сохранение языковых предпочтений пользователя. Кроме того, веб-приложения будут использовать сеансы после аутентификации пользователя. Это обеспечивает возможность идентификации пользователя при любых последующих запросах, а также возможность применения мер безопасности, авторизованного доступа к личным данным пользователя и повышения удобства использования приложения. Таким образом, современные веб-приложения могут предоставлять возможности сеанса как до, так и после аутентификации.

Как только аутентифицированный сеанс установлен, идентификатор сеанса (или токен) временно эквивалентен самому надежному методу аутентификации, используемому приложением, такому как имя пользователя и пароль, парольные фразы, одноразовые пароли (OTP), клиентские цифровые сертификаты, смарт-карты или биометрические данные (например, отпечаток пальца или глаз сетчатка). Смотрите OWASP [Шпаргалку по аутентификации](Authentication_Cheat_Sheet.md).

HTTP - это протокол без сохранения состояния ([RFC2616](https://www.ietf.org/rfc/rfc2616.txt) раздел 5), в котором каждая пара запросов и ответов не зависит от других веб-взаимодействий. Следовательно, для внедрения концепции сеанса требуется реализовать возможности управления сеансом, которые связывают модули аутентификации и контроля доступа (или авторизации), обычно доступные в веб-приложениях:

![SessionDiagram](../assets/Session_Management_Cheat_Sheet_Diagram.png)

Идентификатор сеанса или токен привязывает учетные данные для аутентификации пользователя (в форме пользовательского сеанса) к пользовательскому HTTP-трафику и соответствующим элементам управления доступом, применяемым веб-приложением. Сложность этих трех компонентов (аутентификация, управление сеансами и контроль доступа) в современных веб-приложениях, а также тот факт, что их реализация и привязка находятся в руках веб-разработчика (поскольку фреймворки веб-разработки не предусматривают строгих взаимосвязей между этими модулями), делает внедрение модуля безопасного управления сеансами безопасным. очень сложная задача.

Раскрытие, перехват, предсказание, использование грубой силы или фиксация идентификатора сеанса приведут к атакам с перехватом сеанса (или сайдджекингом), когда злоумышленник может полностью выдать себя за пользователя-жертву в веб-приложении. Злоумышленники могут осуществлять два типа атак с перехватом сеанса: целенаправленные или общие. При целенаправленной атаке целью злоумышленника является выдача себя за конкретного (или привилегированного) пользователя веб-приложения-жертвы. При обычных атаках цель злоумышленника состоит в том, чтобы выдать себя за любого действительного пользователя веб-приложения (или получить доступ от его имени).

## Свойства идентификатора сеанса

Чтобы поддерживать состояние аутентификации и отслеживать прогресс пользователей в веб-приложении, приложения предоставляют пользователям **идентификатор сеанса** (ID сеанса или токен), который присваивается во время создания сеанса и используется совместно пользователем и веб-приложением в течение всего сеанса (он отправляется при каждом HTTP-запросе). Идентификатор сеанса представляет собой пару "имя=значение".

С целью реализации защищенных идентификаторов сеанса генерация идентификаторов (IDS или токенов) должна соответствовать следующим свойствам.

### Фингерпринтинг имени индификатора сеанса

Имя, используемое для идентификатора сеанса, не должно быть чрезмерно описательным и не должно содержать ненужных подробностей о назначении и значении идентификатора.

Имена идентификаторов сеансов, используемые наиболее распространенными платформами разработки веб-приложений [могут быть легко идентифицированы по отпечаткам пальцев](https://wiki.owasp.org/index.php/Category:OWASP_Cookies_Database ), такие как `PHPSESSID` (PHP), `JSESSIONID` (J2EE), `CFID` и `CFTOKEN` (ColdFusion), `ASP.NET_SessionId` (ASP.NET), и так далее. Таким образом, идентификатор сеанса может указывать на технологии и языки программирования, используемые веб-приложением.

Рекомендуется изменить имя идентификатора сеанса по умолчанию в платформе веб-разработки на общее имя, например `id`.

### Длина идентификатора сеанса

Идентификатор сеанса должен быть достаточно длинным, чтобы предотвратить атаки методом перебора, когда злоумышленник может просмотреть весь диапазон значений идентификатора и проверить наличие действительных сеансов.

Длина идентификатора сеанса должна составлять не менее `128 бит (16 байт)`.

**ПРИМЕЧАНИЕ**:

- Длина идентификатора сеанса, равная 128 битам, указана в качестве ссылки на основе предположений, сделанных в следующем разделе *Энтропия идентификатора сеанса*. Однако это число не следует рассматривать как абсолютное минимальное значение, поскольку на его надежность могут влиять другие факторы реализации.
- Например, существуют хорошо известные реализации, такие как [Microsoft ASP.NET session IDs](https://docs.microsoft.com/en-us/dotnet/api/system.web.sessionstate.sessionidmanager?redirectedfrom=MSDN&view=netframework-4.7.2): "*Идентификатор сеанса ASP .NET - это случайно сгенерированное число, закодированное в 24-символьную строку, состоящую из строчных символов от a до z и чисел от 0 до 5*".
- Это может обеспечить очень хорошую эффективную энтропию и, как следствие, может рассматриваться достаточно долго, чтобы избежать угадывания или атак методом перебора.

### Энтропия идентификатора сеанса

Идентификатор сеанса должен быть непредсказуемым (достаточно случайным), чтобы предотвратить атаки с угадыванием, когда злоумышленник может угадать или предсказать идентификатор действительного сеанса с помощью методов статистического анализа. Для этой цели необходимо использовать хороший [CSPRNG](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator) (криптографически защищенный генератор псевдослучайных чисел).

Значение идентификатора сеанса должно содержать не менее `64 бит` энтропии (если используется хороший [PRNG](https://en.wikipedia.org/wiki/Pseudorandom_number_generator), это значение, по оценкам, составляет половину длины идентификатора сеанса).

Кроме того, случайного идентификатора сеанса недостаточно; он также должен быть уникальным, чтобы избежать дублирования идентификаторов. Случайный идентификатор сеанса не должен уже существовать в текущем пространстве идентификаторов сеанса.

**ПРИМЕЧАНИЕ**:

- На энтропию идентификатора сеанса действительно влияют другие внешние и трудно поддающиеся измерению факторы, такие как количество одновременных активных сеансов, которые обычно проводит веб-приложение, абсолютное время ожидания истечения сеанса, количество предположений об идентификаторе сеанса в секунду, которые может сделать злоумышленник, и которые может поддерживать целевое веб-приложение и т.д.
- Если используется идентификатор сеанса с энтропией `64 бита`, злоумышленник может ожидать, что ему потребуется более 292 лет, чтобы успешно угадать действительный идентификатор сеанса, предполагая, что злоумышленник может делать 10 000 попыток угадывания в секунду при 100 000 действительных одновременных сеансов, доступных в веб-приложении.
- Более подробная информация [здесь](https://owasp.org/www-community/vulnerabilities/Insufficient_Session-ID_Length).

### Содержимое (или значение) идентификатора сеанса

Содержимое (или значение) идентификатора сеанса должно быть бессмысленным, чтобы предотвратить атаки на раскрытие информации, когда злоумышленник может расшифровать содержимое идентификатора и извлечь сведения о пользователе, сеансе или внутренней работе веб-приложения.

Идентификатор сеанса должен быть просто идентификатором на стороне клиента, и его значение никогда не должно включать конфиденциальную информацию или информацию, позволяющую установить личность (PII). Чтобы узнать больше о PII, обратитесь к [Википедии](https://en.wikipedia.org/wiki/Personally_identifiable_information) или к этому [посту](https://www.idshield.com/blog/identity-theft/what-pii-and-why-should-i-care/).

Значение и бизнес-логика или логика приложения, связанные с идентификатором сеанса, должны храниться на стороне сервера, в частности, в объектах сеанса или в базе данных или репозитории для управления сеансами.

Сохраненная информация может включать IP-адрес клиента, пользовательский агент, адрес электронной почты, имя пользователя, идентификатор пользователя, роль, уровень привилегий, права доступа, языковые настройки, идентификатор учетной записи, текущее состояние, последний вход в систему, тайм-ауты сеанса и другие внутренние данные сеанса. Если объекты и свойства сеанса содержат конфиденциальную информацию, такую как номера кредитных карт, необходимо должным образом зашифровать и защитить хранилище управления сеансами.

Рекомендуется использовать идентификатор сеанса, созданный в вашем языке или фреймворке. Если вам нужно создать свой собственный идентификатор сеанса, используйте криптографически защищенный генератор псевдослучайных чисел (CSPRNG) размером не менее 128 бит и убедитесь, что каждый идентификатор сеанса уникален.

## Внедрение системы управления сессиями

Реализация управления сеансами определяет механизм обмена, который будет использоваться между пользователем и веб-приложением для совместного использования и постоянного обмена идентификатором сеанса. В протоколе HTTP доступно множество механизмов для поддержания состояния сеанса в веб–приложениях, таких как файлы cookie (стандартный HTTP-заголовок), параметры URL (перезапись URL-адреса - [RFC2396](https://www.ietf.org/rfc/rfc2396.txt )), аргументы URL в запросах GET, основные аргументы в запросах POST, такие как скрытые поля форм (HTML-формы), или собственные HTTP-заголовки.

Предпочтительный механизм обмена идентификаторами сеанса должен позволять определять расширенные свойства токена, такие как дата и время истечения срока действия токена или детализированные ограничения на использование. Это одна из причин, по которой файлы cookie (RFC [2109](https://www.ietf.org/rfc/rfc2109.txt) и [2965](https://www.ietf.org/rfc/rfc2965.txt) и [6265](https://www.ietf.org/rfc/rfc6265.txt)) являются одним из наиболее широко используемых механизмов обмена идентификаторами сеанса, предлагая расширенные возможности, недоступные другими способами.

Использование определенных механизмов обмена идентификаторами сеанса, таких как те, в которых идентификатор включен в URL-адрес, может раскрыть идентификатор сеанса (в веб-ссылках и журналах, истории веб-браузера и закладках, заголовке ссылки или поисковых системах), а также способствовать другим атакам, таким как манипулирование веб-сайтом. Идентификатор или [атаки на фиксацию сеанса](http://www.acrossecurity.com/papers/session_fixation.pdf).

### Встроенные реализации управления сеансами

Платформы веб-разработки, такие как J2EE, ASP .NET, PHP и другие, предоставляют свои собственные функции управления сеансами и соответствующую реализацию. Рекомендуется использовать эти встроенные фреймворки, а не создавать самодельные с нуля, поскольку они используются во всем мире в различных веб-средах и со временем были протестированы сообществами по безопасности веб-приложений и разработке веб-приложений.

Однако имейте в виду, что в прошлом в этих платформах также были обнаружены уязвимости, поэтому всегда рекомендуется использовать последнюю доступную версию, которая потенциально устраняет все известные уязвимости, а также пересматривать и изменять конфигурацию по умолчанию для повышения ее безопасности, следуя рекомендациям, описанным в этом документе.

Средства хранения или репозиторий, используемые механизмом управления сеансами для временного сохранения идентификаторов сеансов, должны быть надежными, защищая идентификаторы сеансов от случайного раскрытия локально или удаленно или несанкционированного доступа.

### Используемые и Принятые механизмы обмена идентификаторами сеансов

Веб-приложение должно использовать файлы cookie для управления обменом идентификаторами сеанса. Если пользователь отправляет идентификатор сеанса с помощью другого механизма обмена, такого как параметр URL, веб-приложение не должно принимать его как часть защитной стратегии, чтобы остановить фиксацию сеанса.

**ПРИМЕЧАНИЕ**:

- Даже если веб-приложение использует файлы cookie в качестве механизма обмена идентификаторами сеанса по умолчанию, оно может использовать и другие механизмы обмена.
- Поэтому необходимо подтвердить путем тщательного тестирования все различные механизмы, которые в настоящее время используются веб-приложением при обработке идентификаторов сеансов и управлении ими, и ограничить принятые механизмы отслеживания идентификаторов сеансов только файлами cookie.
- В прошлом некоторые веб-приложения использовали параметры URL или даже переключались с файлов cookie на параметры URL (посредством автоматической перезаписи URL), если выполнялись определенные условия (например, идентификация веб-клиентов без поддержки файлов cookie или отказ от принятия файлов cookie из соображений конфиденциальности пользователей).

### Безопасность транспортного уровня (TLS)

Чтобы защитить обмен идентификаторами сеанса от активного перехвата и пассивного раскрытия в сетевом трафике, важно использовать зашифрованное HTTPS (TLS) соединение для всего веб-сеанса, а не только для процесса аутентификации, при котором происходит обмен учетными данными пользователя. Это может быть устранено с помощью [HTTP Strict Transport Security (HSTS)](HTTP_Strict_Transport_Security_Cheat_Sheet.md) для клиента, который его поддерживает.

Кроме того, необходимо использовать `Secure` [атрибут cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Secure_and_HttpOnly_cookies), чтобы гарантировать, что обмен идентификатором сеанса осуществляется только по зашифрованному каналу. Использование зашифрованного канала связи также защищает сеанс от некоторых атак на фиксацию сеанса, когда злоумышленник может перехватывать веб-трафик и манипулировать им, чтобы ввести (или исправить) идентификатор сеанса в веб-браузере жертвы (см. [здесь](https://media.blackhat.com/bh-eu-11/Raul_Siles/BlackHat_EU_2011_Siles_SAP_Session-Slides.pdf) и [здесь](https://media.blackhat.com/bh-eu-11/Raul_Siles/BlackHat_EU_2011_Siles_SAP_Session-WP.pdf)).

Следующий набор рекомендаций направлен на защиту идентификатора сеанса (особенно при использовании файлов cookie) и упрощение интеграции HTTPS в веб-приложение.:

- Не переключайте данный сеанс с HTTP на HTTPS или наоборот, так как это приведет к раскрытию идентификатора сеанса в открытом доступе по сети.
    - При перенаправлении на HTTPS убедитесь, что файл cookie установлен или восстановлен повторно после того, как произошло перенаправление.
- Не смешивайте зашифрованное и незашифрованное содержимое (HTML-страницы, изображения, CSS, файлы JavaScript и т.д.) на одной странице или из одного домена.
- По возможности избегайте размещения общедоступного незашифрованного содержимого и частного зашифрованного содержимого с одного и того же хостинга. Если требуется небезопасное содержимое, рассмотрите возможность размещения его в отдельном небезопасном домене.
- Внедрите [HTTP Strict Transport Security (HSTS)](HTTP_Strict_Transport_Security_Cheat_Sheet.md) для обеспечения соблюдения HTTPS-соединений.

Смотрите OWASP [Шпаргалку по безопасности транспортного уровня](Transport_Layer_Security_Cheat_Sheet.md) для получения более общих рекомендаций по безопасному внедрению TLS.

Важно подчеркнуть, что протокол TLS не защищает от предсказания идентификатора сеанса, грубой силы, вмешательства или фиксации на стороне клиента; однако он обеспечивает эффективную защиту от перехвата или кражи идентификаторов сеанса злоумышленником с помощью атаки "человек посередине".

## Файлы cookie

Механизм обмена идентификаторами сеанса, основанный на файлах cookie, предоставляет множество функций безопасности в виде атрибутов файлов cookie, которые могут использоваться для защиты обмена идентификаторами сеанса:

### Атрибут Secure

Атрибут `Secure`файла cookie предписывает веб-браузерам отправлять cookie-файлы только через зашифрованное соединение HTTPS (SSL/TLS). Этот механизм защиты сеанса является обязательным для предотвращения раскрытия идентификатора сеанса в результате атак MitM (Man-in-the-Middle). Это гарантирует, что злоумышленник не сможет просто перехватить идентификатор сеанса из трафика веб-браузера.

Принуждение веб-приложения использовать только HTTPS для обмена данными (даже если порт TCP/80, HTTP, закрыт на хосте веб-приложения) не защищает от раскрытия идентификатора сеанса, если не установлен "Безопасный" файл cookie - веб-браузер может быть обманут, чтобы раскрыть идентификатор сеанса по электронной почте. незашифрованное HTTP-соединение. Злоумышленник может перехватывать пользовательский трафик жертвы и манипулировать им, а также вводить незашифрованную ссылку HTTP на веб-приложение, которая заставит веб-браузер отправить идентификатор сеанса в открытом виде.

Смотрите также: [SecureFlag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Secure_and_HttpOnly_cookies)

### Атрибут HttpOnly

Атрибут cookie `HttpOnly` указывает веб-браузерам не разрешать скриптам (например, JavaScript или VBScript) получать доступ к файлам cookie через объект DOM document.cookie. Эта защита идентификатора сеанса обязательна для предотвращения кражи идентификатора сеанса с помощью XSS-атак. Однако, если атака XSS сочетается с атакой CSRF, запросы, отправляемые веб-приложению, будут содержать сессионный файл cookie, поскольку браузер всегда включает файлы cookie при отправке запросов. Файл cookie `HttpOnly` защищает конфиденциальность только файлов cookie; злоумышленник не может использовать его в автономном режиме, вне контекста XSS-атаки.

Смотрите шпаргалку по предотвращению использования XSS (межсайтового скриптинга) в OWASP[Cross_Site_Scripting_Prevention_Cheat_Sheet.md].

Смотрите также: [HttpOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Secure_and_HttpOnly_cookies)

### Атрибут SameSite

Same ite определяет атрибут cookie, предотвращающий отправку браузерами файлов cookie, помеченных как SameSite, с межсайтовыми запросами. Основная цель - снизить риск утечки информации из разных источников и обеспечить некоторую защиту от атак на подделку межсайтовых запросов.

Смотрите также: [Тот же сайт](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#SameSite_cookies)

### Атрибуты Domain и Path 

Атрибут cookie [`Domain`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives) указывает веб-браузерам отправлять cookie-файлы только в указанный домен и все поддомены. Если этот атрибут не задан, по умолчанию cookie-файлы будут отправляться только на исходный сервер. Атрибут cookie [`Path`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives) указывает веб-браузерам отправлять cookie только в указанный каталог или подкаталоги (или пути или ресурсы) в веб-приложении. Если атрибут не задан, то по умолчанию файл cookie будет отправляться только для указания каталога (или пути) запрошенного ресурса и установки файла cookie.

Рекомендуется использовать узкую или ограниченную область применения для этих двух атрибутов. Таким образом, атрибут `Domain` не должен устанавливаться (ограничивая использование файлов cookie только исходным сервером), а атрибут `Path` должен быть установлен как можно более строго для пути к веб-приложению, которое использует идентификатор сеанса.

Установка для атрибута `Domain` слишком разрешающего значения, например `example.com`, позволяет злоумышленнику запускать атаки на идентификаторы сеансов между разными хостами и веб-приложениями, принадлежащими к одному домену, известные как файлы cookie с перекрестными поддоменами. Например, уязвимости в `www.example.com` могут позволить злоумышленнику получить доступ к идентификаторам сеанса из `secure.example.com`.

Кроме того, рекомендуется не смешивать веб-приложения с разными уровнями безопасности в одном домене. Уязвимости в одном из веб-приложений позволили бы злоумышленнику установить идентификатор сеанса для другого веб-приложения в том же домене, используя разрешающий атрибут "Домен" (например, "example.com"), который является методом, который может быть использован в [атаках на фиксацию сеанса](http://www.acrossecurity.com/papers/session_fixation.pdf).

Хотя атрибут `Path` позволяет изолировать идентификаторы сеанса между различными веб-приложениями, использующими разные пути на одном и том же хосте, настоятельно рекомендуется не запускать разные веб-приложения (особенно с разными уровнями безопасности или областями действия) на одном и том же хосте. Эти приложения могут использовать другие методы для доступа к идентификаторам сеанса, например, объект `document.cookie`. Кроме того, любое веб-приложение может установить файлы cookie для любого пути на этом хосте.

Файлы cookie уязвимы для атак с подменой/перехватом/отравлением DNS, когда злоумышленник может манипулировать разрешением DNS, чтобы заставить веб-браузер раскрыть идентификатор сеанса для данного хоста или домена.

### Атрибуты Expire и Max-Age

Механизмы управления сеансами, основанные на файлах cookie, могут использовать два типа файлов cookie: непостоянные (или сессионные) файлы cookie и постоянные файлы cookie. Если файл cookie содержит атрибуты ["Max-Age"](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives) (который предпочтительнее, чем `Expires`) или ["Expires"](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives), он будет считаться постоянным файлом cookie и будет храниться веб-браузером на диске до истечения срока его действия.

Как правило, средства управления сеансами для отслеживания пользователей после аутентификации используют непостоянные файлы cookie. Это приводит к тому, что сеанс исчезает из клиента, если текущий экземпляр веб-браузера закрыт. Поэтому настоятельно рекомендуется использовать непостоянные файлы cookie для целей управления сеансами, чтобы идентификатор сеанса не оставался в кэше веб-клиента в течение длительного времени, откуда злоумышленник может его получить.

- Следите за тем, чтобы конфиденциальная информация не была скомпрометирована, обеспечивая ее непостоянство, шифруя ее и сохраняя только на время необходимости.
- Убедитесь, что несанкционированные действия не могут быть осуществлены с помощью манипулирования файлами cookie
- Убедитесь, что установлен флажок secure для предотвращения случайной передачи данных небезопасным способом
- Определите, все ли переходы состояний в коде приложения должным образом проверяются на наличие файлов cookie и обеспечивают их использование
- Убедитесь, что все файлы cookie должны быть зашифрованы, если в них хранятся конфиденциальные данные
- Укажите все файлы cookie, используемые приложением, их название и зачем они нужны

## API веб-хранилища HTML5

Рабочая группа по технологиям веб-гипертекстовых приложений (WHATWG) описывает API-интерфейсы веб-хранилища HTML5 `localStorage` и `sessionStorage` как механизмы для хранения пар `имя-значение` на стороне клиента.
В отличие от HTTP-файлов cookie, содержимое `localStorage` и `sessionStorage` не передается браузером автоматически в рамках запросов или ответов, а используется для хранения данных на стороне клиента.

### API localStorage

#### Масштаб

Данные, хранящиеся с использованием API `localStorage`, доступны для страниц, загруженных из одного источника, который определяется как схема (`https://`), хост (`example.com`), порт (`443`) и домен/область (`example.com`).
Это обеспечивает аналогичный доступ к этим данным, который был бы достигнут при использовании флага "secure" в файле cookie, что означает, что данные, сохраненные по `https`, не могут быть получены по `http`. Из-за потенциального параллельного доступа из разных окон/потоков данные, хранящиеся с использованием "localStorage", могут быть подвержены проблемам с общим доступом (таким как условия гонки) и должны рассматриваться как неблокируемые ([Спецификация API веб-хранилища](https://html.spec.whatwg.org/multipage/webstorage.html#the-localstorage-attribute)).

#### Продолжительность

Данные, сохраненные с помощью API `localStorage`, сохраняются в течение всех сеансов просмотра, что увеличивает период, в течение которого они могут быть доступны другим пользователям системы.

#### Автономный доступ

Стандарты не требуют, чтобы данные `localStorage` были зашифрованы в состоянии покоя, что означает, что может быть возможен прямой доступ к этим данным с диска.

#### Пример использования

WHATWG предлагает использовать `localStorage` для данных, к которым требуется доступ через окна или вкладки, в нескольких сеансах и где по соображениям производительности может потребоваться хранение больших (многомегабайтных) объемов данных.

### API-интерфейс sessionStorage

#### Масштаб

API `sessionStorage` хранит данные в контексте окна, из которого он был вызван, что означает, что вкладка 1 не может получить доступ к данным, которые были сохранены на вкладке 2.
Также, как и `localStorage` API, данные, хранящиеся с использованием API "sessionStorage", доступны страницам, загруженным из одного источника, который определяется как схема (`https://`), хост (`example.com`), порт (`443`) и домен/область (`example.com `).
Это обеспечивает аналогичный доступ к этим данным, который был бы достигнут при использовании флага "secure" в файле cookie, что означает, что данные, сохраненные по `https`, не могут быть получены по `http`.

#### Продолжительность

API `sessionStorage` хранит данные только в течение текущего сеанса просмотра. Как только вкладка закрыта, эти данные больше не доступны для извлечения. Это не обязательно препятствует доступу, если вкладка браузера будет повторно использована или оставлена открытой. Данные также могут сохраняться в памяти до события сборки мусора.

#### Автономный доступ

Стандарты не требуют, чтобы данные `sessionStorage` были зашифрованы в состоянии покоя, что означает, что может быть возможен прямой доступ к этим данным с диска.

#### Пример использования

WHATWG предлагает использовать `sessionStorage` для данных, которые имеют отношение к одному экземпляру рабочего процесса, например, для сведений о бронировании билетов, но в которых несколько рабочих процессов могут выполняться на других вкладках одновременно. Привязка к окну/вкладке предотвратит утечку данных между рабочими процессами на отдельных вкладках.

### Ссылки на литературу

- [Web Storage APIs](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API)
- [LocalStorage API](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)
- [SessionStorage API](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)
- [WHATWG Web Storage Spec](https://html.spec.whatwg.org/multipage/webstorage.html#webstorage)

## Web Workers

Web Workers запускают JavaScript-код в глобальном контексте, отдельном от контекста текущего окна. Существует канал связи с главным окном выполнения, который называется `MessageChannel`.

### Пример использования

Web Workers - это альтернатива браузерному хранилищу секретов (сеанса), когда сохранение данных при обновлении страницы не требуется. Чтобы Web Workers обеспечивал безопасное хранение в браузере, любой код, для которого требуется секрет, должен существовать в Web Worker, и секрет никогда не должен передаваться в контекст главного окна.

Хранение секретных данных в памяти веб-сервера обеспечивает те же гарантии безопасности, что и HttpOnly cookie: конфиденциальность секретных данных защищена. Тем не менее, XSS-атака может быть использована для отправки сообщений веб-серверу для выполнения операции, для которой требуется секрет. Веб-воркер вернет результат операции в основной поток выполнения.

Преимущество реализации Web Worker по сравнению с файлом cookie HttpOnly заключается в том, что Web Worker позволяет некоторому изолированному JavaScript-коду получить доступ к секрету; файл cookie HttpOnly недоступен для любого JavaScript. Если JavaScript-код внешнего интерфейса требует доступа к секретной информации, реализация Web Worker является единственным вариантом хранения в браузере, который сохраняет конфиденциальность секретной информации.

## Жизненный цикл идентификатора сеанса

### Генерация и проверка идентификатора сеанса: разрешающее и строгое управление сеансом

Существует два типа механизмов управления сеансами для веб-приложений: разрешающее и строгое, которые связаны с уязвимостями, связанными с фиксацией сеанса. Разрешительный механизм позволяет веб-приложению изначально принимать любое значение идентификатора сеанса, установленное пользователем, как действительное, создавая для него новый сеанс, в то время как строгий механизм обеспечивает, чтобы веб-приложение принимало только те значения идентификатора сеанса, которые были ранее сгенерированы веб-приложением.

Токены сеанса должны обрабатываться веб-сервером, если это возможно, или генерироваться с помощью криптографически защищенного генератора случайных чисел.

Хотя наиболее распространенным механизмом, используемым сегодня, является строгий (более безопасный), [по умолчанию в PHP используется разрешающий механизм](https://wiki.php.net/rfc/session-use-strict-mode). Разработчики должны убедиться, что веб-приложение не использует разрешающий механизм при определенных обстоятельствах. Веб-приложения никогда не должны принимать идентификатор сеанса, который они никогда не генерировали, и в случае его получения они должны сгенерировать и предложить пользователю новый действительный идентификатор сеанса. Кроме того, этот сценарий должен быть обнаружен как подозрительная активность и должно быть выдано предупреждение.

### Управляйте идентификатором сеанса так же, как любым другим пользовательским вводом

Идентификаторы сеанса должны считаться ненадежными, как и любой другой пользовательский ввод, обрабатываемый веб-приложением, и они должны быть тщательно проверены. В зависимости от используемого механизма управления сеансом идентификатор сеанса будет получен в виде параметра GET или POST, в URL-адресе или в заголовке HTTP (например, файлы cookie). Если веб-приложения не проверяют и не отфильтровывают недопустимые значения идентификатора сеанса перед их обработкой, они потенциально могут быть использованы для использования других веб-уязвимостей, таких как внедрение SQL, если идентификаторы сеанса хранятся в реляционной базе данных, или постоянный XSS, если идентификаторы сеанса сохраняются и впоследствии отражаются веб-приложением.

### Обновляйте идентификатор Сеанса после любого изменения уровня Привилегий

Идентификатор сеанса должен быть обновлен веб-приложением после любого изменения уровня привилегий в рамках связанного пользовательского сеанса. Наиболее распространенный сценарий, при котором обновление идентификатора сеанса является обязательным, происходит во время процесса аутентификации, поскольку уровень привилегий пользователя меняется с неавторизованного (или анонимного) состояния на состояние, прошедшее проверку подлинности, хотя в некоторых случаях это еще не авторизованное состояние. К числу распространенных сценариев, которые следует учитывать, относятся смена пароля, изменение разрешений или переход от роли обычного пользователя к роли администратора в веб-приложении. Для всех конфиденциальных страниц веб-приложения любые идентификаторы предыдущих сеансов должны игнорироваться, каждому новому запросу, полученному для защищенного ресурса, должен присваиваться только текущий идентификатор сеанса, а старый или предыдущий идентификатор сеанса должен быть уничтожен.

Наиболее распространенные платформы веб-разработки предоставляют функции и методы сеанса для обновления идентификатора сеанса, такие как `request.getSession(true)` и `HttpSession.invalidate()` (J2EE), `Session.Abandon()` и `Response.Cookies.Add(new...)` (ASP .NET) или `session_start()` и `session_regenerate_id(true)` (PHP).

Обновление идентификатора сеанса является обязательным для предотвращения [атак с фиксацией сеанса] (http://www.acrossecurity.com/papers/session_fixation.pdf), когда злоумышленник устанавливает идентификатор сеанса в веб-браузере пользователя-жертвы вместо сбора идентификатора сеанса жертвы, как в большинстве других атак, основанных на сеансе, и независимо от использования HTTP или HTTPS. Эта защита снижает воздействие других веб-уязвимостей, которые также могут быть использованы для запуска атак с фиксацией сеанса, таких как разделение HTTP-ответов или XSS (см. [здесь](https://media.blackhat.com/bh-eu-11/Raul_Siles/BlackHat_EU_2011_Siles_SAP_Session-Slides.pdf) и [здесь](https://media.blackhat.com/bh-eu-11/Raul_Siles/BlackHat_EU_2011_Siles_SAP_Session-WP.pdf)).

Дополнительной рекомендацией является использование другого идентификатора сеанса или имени токена (или набора идентификаторов сеанса) до и после аутентификации, чтобы веб-приложение могло отслеживать анонимных пользователей и прошедших проверку подлинности пользователей без риска раскрытия или привязки сеанса пользователя к обоим состояниям.

### Рекомендации при использовании Нескольких Файлов Cookie

Если веб-приложение использует файлы cookie в качестве механизма обмена идентификаторами сеанса и для данного сеанса установлено несколько файлов cookie, веб-приложение должно проверить все файлы cookie (и установить взаимосвязи между ними), прежде чем разрешить доступ к сеансу пользователя.

Веб-приложения очень часто устанавливают предварительную аутентификацию пользователя с помощью файлов cookie по протоколу HTTP, чтобы отслеживать не прошедших проверку подлинности (или анонимных) пользователей. Как только пользователь проходит аутентификацию в веб-приложении, по протоколу HTTPS устанавливается новый защищенный файл cookie после аутентификации, и устанавливается привязка между обоими файлами cookie и сеансом пользователя. Если веб-приложение не проверяет оба файла cookie для аутентифицированных сеансов, злоумышленник может использовать незащищенный файл cookie для предварительной аутентификации, чтобы получить доступ к аутентифицированному сеансу пользователя (см. [здесь](https://media.blackhat.com/bh-eu-11/Raul_Siles/BlackHat_EU_2011_Siles_SAP_Session-Slides.pdf) и [здесь](https://media.blackhat.com/bh-eu-11/Raul_Siles/BlackHat_EU_2011_Siles_SAP_Session-WP.pdf)).

Веб-приложениям следует избегать использования одного и того же имени файла cookie для разных путей или доменных областей в рамках одного и того же веб-приложения, поскольку это увеличивает сложность решения и потенциально создает проблемы с определением области.

## Истечение срока действия сеанса

Чтобы свести к минимуму период времени, в течение которого злоумышленник может запускать атаки на активные сеансы и перехватывать их, необходимо в обязательном порядке устанавливать тайм-ауты истечения срока действия для каждого сеанса, определяя время, в течение которого сеанс будет оставаться активным. Недостаточный срок действия сеанса веб-приложением увеличивает вероятность других атак, основанных на сеансе, поскольку для того, чтобы злоумышленник мог повторно использовать действительный идентификатор сеанса и перехватить связанный с ним сеанс, он все еще должен быть активен.

Чем короче интервал сеанса, тем меньше времени у злоумышленника остается на использование действительного идентификатора сеанса. Значения тайм-аута истечения сеанса должны быть установлены в соответствии с назначением и характером веб-приложения и обеспечивать баланс между безопасностью и удобством использования, чтобы пользователь мог с комфортом выполнять операции в веб-приложении без частого истечения срока действия его сеанса.

Как значения времени простоя, так и абсолютного времени ожидания сильно зависят от того, насколько критичны веб-приложение и его данные. Общие интервалы времени ожидания составляют 2-5 минут для приложений с высокой стоимостью и 15-30 минут для приложений с низким уровнем риска. Абсолютные тайм-ауты зависят от того, как долго пользователь обычно использует приложение. Если приложение предназначено для использования офисным работником в течение целого дня, допустимый диапазон абсолютных тайм-аутов может составлять от 4 до 8 часов.

По истечении срока действия сеанса веб-приложение должно предпринять активные действия для аннулирования сеанса с обеих сторон, клиента и сервера. Последнее является наиболее актуальным и обязательным с точки зрения безопасности.

Для большинства механизмов обмена сеансами действия на стороне клиента по аннулированию идентификатора сеанса основаны на удалении значения токена. Например, чтобы сделать файл cookie недействительным, рекомендуется указать пустое (или недопустимое) значение для идентификатора сеанса и установить для атрибута `Expires` (или `Max-Age`) значение прошлой даты (в случае, если используется постоянный файл cookie): `Set-Cookie: id=; Истекает=Пятница, 17 мая-03 18:45:00 GMT`

Чтобы закрыть и аннулировать сеанс на стороне сервера, веб-приложению необходимо предпринять активные действия по истечении сеанса или при активном выходе пользователя из системы, используя функции и методы, предлагаемые механизмами управления сеансом, такие как `HttpSession.invalidate()` (J2EE), `Сессия.Abandon()` (ASP .NET) или `session_destroy()/unset()` (PHP).

### Автоматическое истечение срока действия сеанса

#### Тайм-аут простоя

Во всех сеансах должен быть реализован тайм-аут простоя или бездействия. Этот тайм-аут определяет количество времени, в течение которого сеанс будет оставаться активным в случае отсутствия активности в сеансе, закрывая и аннулируя сеанс по истечении определенного периода простоя с момента последнего HTTP-запроса, полученного веб-приложением для данного идентификатора сеанса.

Тайм-аут простоя ограничивает шансы злоумышленника угадать и использовать действительный идентификатор сеанса от другого пользователя. Однако, если злоумышленнику удается перехватить данный сеанс, тайм-аут простоя не ограничивает действия злоумышленника, поскольку он может периодически генерировать активность в сеансе, чтобы поддерживать его активность в течение более длительного периода времени.

Управление тайм-аутом сеанса и истечением срока действия должно осуществляться на стороне сервера. Если клиент используется для принудительного установления тайм-аута сеанса, например, с помощью токена сеанса или других параметров клиента для отслеживания временных привязок (например, количества минут с момента входа в систему), злоумышленник может манипулировать ими для увеличения продолжительности сеанса.

#### Абсолютный тайм-аут

Во всех сеансах должен быть установлен абсолютный тайм-аут, независимо от активности сеанса. Этот тайм-аут определяет максимальное время, в течение которого сеанс может быть активен, закрывая сеанс и делая его недействительным по истечении определенного абсолютного периода с момента первоначального создания данного сеанса веб-приложением. После аннулирования сеанса пользователь вынужден (повторно) проходить аутентификацию в веб-приложении и устанавливать новый сеанс.

Абсолютный сеанс ограничивает время, в течение которого злоумышленник может использовать захваченный сеанс и выдавать себя за пользователя-жертву.

#### Время ожидания обновления

В качестве альтернативы, веб-приложение может ввести дополнительное время ожидания обновления, после которого идентификатор сеанса автоматически обновляется в середине сеанса пользователя и независимо от активности сеанса и, следовательно, времени ожидания простоя.

По истечении определенного промежутка времени с момента первоначального создания сеанса веб-приложение может повторно создать новый идентификатор для сеанса пользователя и попытаться установить его или обновить на клиенте. Предыдущее значение идентификатора сеанса будет оставаться действительным в течение некоторого времени с учетом интервала безопасности, прежде чем клиент узнает о новом идентификаторе и начнет его использовать. В это время, когда клиент переключается на новый идентификатор в текущем сеансе, приложение аннулирует предыдущий идентификатор.

Этот сценарий сводит к минимуму количество времени, в течение которого данное значение идентификатора сеанса, потенциально полученное злоумышленником, может быть повторно использовано для перехвата сеанса пользователя, даже если сеанс пользователя-жертвы все еще активен. Пользовательский сеанс остается активным и открытым на законном клиенте, хотя связанное с ним значение идентификатора сеанса прозрачно обновляется периодически в течение всего сеанса, каждый раз по истечении времени ожидания обновления. Таким образом, тайм-аут обновления дополняет тайм-аут простоя и абсолютный тайм-аут, особенно когда значение абсолютного тайм-аута значительно увеличивается со временем (например, это требование приложения - поддерживать пользовательские сеансы открытыми в течение длительного периода времени).

В зависимости от реализации, потенциально может возникнуть ситуация гонки, когда злоумышленник, у которого все еще действителен предыдущий идентификатор сеанса, отправляет запрос раньше пользователя-жертвы, сразу после истечения времени ожидания обновления, и сначала получает значение для обновленного идентификатора сеанса. По крайней мере, в этом случае пользователь-жертва может быть осведомлен об атаке, поскольку ее сеанс будет внезапно прерван, поскольку связанный с ним идентификатор сеанса больше недействителен.

### Ручное истечение срока действия сеанса

Веб-приложения должны предоставлять механизмы, позволяющие пользователям, осведомленным о безопасности, активно закрывать свой сеанс после завершения использования веб-приложения.

#### Кнопка выхода из системы

Веб-приложения должны предоставлять видимую и легкодоступную кнопку выхода из системы (logoff, exit или close session), которая находится в заголовке веб-приложения или в меню и доступна с любого ресурса и страницы веб-приложения, чтобы пользователь мог вручную закрыть сеанс в любое время. Как описано в разделе *Session_Expiration*, веб-приложение должно аннулировать сеанс, по крайней мере, на стороне сервера.

**ПРИМЕЧАНИЕ**: К сожалению, не все веб-приложения позволяют пользователям закрыть текущую сессию. Таким образом, усовершенствования на стороне клиента позволяют добросовестным пользователям защитить свои сессии, помогая им тщательно закрывать их.

### Кэширование веб-контента

Даже после закрытия сеанса может сохраниться возможность доступа к личным или конфиденциальным данным, которыми обменивались в ходе сеанса, через кэш веб-браузера. Следовательно, веб-приложения должны использовать ограничительные директивы кэширования для всего веб-трафика, передаваемого через HTTP и HTTPS, такие как [`Cache-Control`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) и [`Pragma`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma) HTTP-заголовки и/или эквивалентные МЕТА-теги на всех или (по крайней мере) конфиденциальных веб-сайтах. страницы.

Независимо от политики кэширования, определенной веб-приложением, если кэширование содержимого веб-приложения разрешено, идентификаторы сеансов никогда не должны кэшироваться, поэтому настоятельно рекомендуется использовать директиву `Cache-Control: no-cache="Set-Cookie, Set-Cookie2"`, чтобы разрешить веб-клиентам чтобы кэшировать все, кроме идентификатора сеанса (смотрите [здесь](https://stackoverflow.com/a/41352418)).

## Дополнительные средства защиты на стороне клиента для управления сеансами

Веб-приложения могут дополнять ранее описанные средства защиты от управления сеансами дополнительными контрмерами на стороне клиента. Защита на стороне клиента, обычно в виде проверок на JavaScript, не является пуленепробиваемой и может быть легко преодолена опытным злоумышленником, но может создать еще один уровень защиты, который злоумышленникам придется обходить.

### Время ожидания первоначального входа в систему

Веб-приложения могут использовать JavaScript-код на странице входа в систему для оценки и измерения времени, прошедшего с момента загрузки страницы и присвоения идентификатора сеанса. Если попытка входа в систему будет предпринята по истечении определенного промежутка времени, клиентский код может уведомить пользователя о том, что максимальное время для входа в систему истекло, и перезагрузить страницу входа в систему, в результате чего будет получен новый идентификатор сеанса.

Этот дополнительный механизм защиты пытается принудительно обновить предварительную аутентификацию по идентификатору сеанса, избегая сценариев, когда ранее использованный (или установленный вручную) идентификатор сеанса повторно используется следующей жертвой, использующей тот же компьютер, например, при атаках на фиксацию сеанса.

### Принудительный Выход из Сеанса При Закрытии окна веб-Браузера

Веб-приложения могут использовать JavaScript-код для отслеживания всех событий закрытия (или даже возврата) вкладок или окон веб-браузера и выполнения соответствующих действий для закрытия текущего сеанса перед закрытием веб-браузера, имитируя, что пользователь вручную закрыл сеанс с помощью кнопки выхода из системы.

### Отключить сеансы кросс-табуляции в веб-браузере

Веб-приложения могут использовать код JavaScript после того, как пользователь вошел в систему и был установлен сеанс, чтобы заставить пользователя повторно пройти аутентификацию, если в том же веб-приложении открывается новая вкладка или окно веб-браузера. Веб-приложение не хочет разрешать нескольким вкладкам или окнам веб-браузера совместно использовать один и тот же сеанс. Поэтому приложение пытается заставить веб-браузер не использовать один и тот же идентификатор сеанса одновременно между ними.

**ПРИМЕЧАНИЕ**: Этот механизм не может быть реализован, если обмен идентификатором сеанса осуществляется с помощью файлов cookie, поскольку файлы cookie являются общими для всех вкладок/ окон веб-браузера.

### Автоматический выход клиента из системы

Веб-приложение может использовать JavaScript-код на всех (или критически важных) страницах для автоматического выхода из клиентских сессий по истечении времени ожидания, например, путем перенаправления пользователя на страницу выхода из системы (тот же ресурс, который используется кнопкой выхода, упомянутой ранее).

Преимущество расширения функциональности тайм-аута простоя на стороне сервера с помощью клиентского кода заключается в том, что пользователь может видеть, что сеанс завершен из-за бездействия, или даже может быть заранее уведомлен о том, что сеанс подходит к концу, с помощью таймера обратного отсчета и предупреждающих сообщений. Такой удобный подход помогает избежать сбоев в работе веб-страниц, требующих большого объема вводимых данных, из-за того, что сеансы на стороне сервера автоматически истекают.

## Обнаружение атак на сеансы

### Определение идентификатора сеанса и обнаружение методом перебора

Если злоумышленник попытается угадать действительный идентификатор сеанса или применить грубую силу, ему необходимо запустить несколько последовательных запросов к целевому веб-приложению, используя разные идентификаторы сеанса с одного (или набора) IP-адресов. Кроме того, если злоумышленник пытается проанализировать предсказуемость идентификатора сеанса (например, с помощью статистического анализа), ему необходимо запустить несколько последовательных запросов из одного (или набора) IP-адреса целевого веб-приложения для сбора новых действительных идентификаторов сеанса.

Веб-приложения должны быть способны обнаруживать оба сценария на основе количества попыток собрать (или использовать) разные идентификаторы сеанса и предупреждать и/или блокировать IP-адреса-нарушители.

### Обнаружение аномалий идентификатора сеанса

Веб-приложения должны быть сосредоточены на обнаружении аномалий, связанных с идентификатором сеанса, таких как манипулирование им. OWASP [Проект AppSensor](https://owasp.org/www-project-appsensor/) предоставляет структуру и методологию для реализации встроенных возможностей обнаружения вторжений в веб-приложениях, ориентированных на обнаружение аномалий и неожиданного поведения, в виде точек обнаружения и ответных действий. Вместо использования внешних уровней защиты иногда детали бизнес-логики и расширенная аналитика доступны только изнутри веб-приложения, где можно установить несколько точек обнаружения, связанных с сеансом, например, при изменении или удалении существующего файла cookie, добавлении нового файла cookie, получении идентификатора сеанса от другого пользователя. используется повторно, или когда местоположение пользователя или пользовательский агент меняются в середине сеанса.

### Привязка идентификатора сеанса к другим свойствам пользователя

С целью обнаружения (и, в некоторых случаях, защиты от) неправильного поведения пользователя и перехвата сеанса настоятельно рекомендуется привязать идентификатор сеанса к другим свойствам пользователя или клиента, таким как IP-адрес клиента, пользовательский агент или клиентский цифровой сертификат. Если веб-приложение обнаруживает какие-либо изменения или аномалии между этими различными свойствами в середине установленного сеанса, это является очень хорошим показателем манипулирования сеансом и попыток перехвата, и этот простой факт может быть использован для предупреждения и/или прекращения подозрительного сеанса.

Хотя эти свойства не могут быть использованы веб-приложениями для надежной защиты от сеансовых атак, они значительно расширяют возможности обнаружения (и защиты) веб-приложений. Однако опытный злоумышленник может обойти эти средства управления, повторно используя тот же IP-адрес, назначенный пользователю-жертве, используя ту же сеть (очень распространенную в средах NAT, таких как точки доступа Wi-Fi), или используя тот же исходящий веб-прокси (очень распространенный в корпоративных средах), или вручную изменив своего пользователя-Агент должен выглядеть точно так же, как это делают пользователи-жертвы.

### Ведение журнала жизненного цикла сеансов: Мониторинг создания, использования и уничтожения идентификаторов сеансов

Веб-приложения должны расширить свои возможности ведения журнала, включив в него информацию о полном жизненном цикле сеансов. В частности, рекомендуется записывать события, связанные с сеансом, такие как создание, обновление и уничтожение идентификаторов сеанса, а также сведения о его использовании при входе в систему и выходе из системы, изменении уровня привилегий в сеансе, истечении времени ожидания, недопустимых действиях сеанса (при обнаружении) и критических бизнес-операциях во время сеанса.

Данные журнала могут включать временную метку, IP-адрес источника, запрашиваемый веб-ресурс (задействованный в сеансе), заголовки HTTP (включая User-Agent и Refererer), параметры получения и публикации, коды ошибок и сообщения, имя пользователя (или ID пользователя), а также идентификатор сеанса (файлы cookie, URL, ПОЛУЧИТЬ, ОПУБЛИКОВАТЬ...).

Конфиденциальные данные, такие как идентификатор сеанса, не должны включаться в журналы, чтобы защитить журналы сеансов от локального или удаленного раскрытия идентификатора сеанса или несанкционированного доступа. Однако для сопоставления записей журнала с конкретными сеансами необходимо сохранять некоторую информацию, относящуюся к конкретному сеансу. Рекомендуется регистрировать соленый хэш идентификатора сеанса вместо самого идентификатора сеанса, чтобы обеспечить корреляцию журнала для конкретного сеанса, не раскрывая идентификатор сеанса.

В частности, веб-приложения должны тщательно защищать административные интерфейсы, которые позволяют управлять всеми текущими активными сеансами. Часто они используются персоналом службы поддержки для решения проблем, связанных с сеансами, или даже общих проблем, путем выдачи себя за пользователя и просмотра веб-приложения так, как это делает пользователь.

Журналы сеансов становятся одним из основных источников данных для обнаружения вторжений в веб-приложения, а также могут использоваться системами защиты от вторжений для автоматического завершения сеансов и/или отключения учетных записей пользователей при обнаружении (одной или нескольких) атак. Если реализованы активные средства защиты, эти защитные действия также должны регистрироваться.

### Одновременный вход в систему во время сеанса

При разработке веб-приложения необходимо определить, разрешено ли несколько одновременных входов в систему от одного и того же пользователя с одного и того же или с разных IP-адресов клиента. Если веб-приложение не хочет разрешать одновременный сеансовый вход в систему, оно должно предпринимать эффективные действия после каждого нового события аутентификации, неявно завершая ранее доступный сеанс или запрашивая пользователя (через старый, новый или оба сеанса) о сеансе, который должен оставаться активным.

Веб-приложениям рекомендуется добавить пользовательские возможности, позволяющие в любое время проверять информацию об активных сеансах, отслеживать и оповещать пользователя о одновременных входах в систему, предоставлять пользователю функции для удаленного завершения сеансов вручную и отслеживать историю действий учетной записи (журнал регистрации), записывая множество сведений о клиенте, таких как IP-адрес, имя пользователя и пароль.-Агент, дата и время входа в систему, время простоя и т.д.

## Управление сеансами защиты WAF

Бывают ситуации, когда исходный код веб-приложения недоступен или не может быть изменен, или когда изменения, необходимые для реализации многочисленных рекомендаций по безопасности и наилучших практик, описанных выше, предполагают полную переработку архитектуры веб-приложения и, следовательно, не могут быть легко реализованы в краткосрочной перспективе.

В этих сценариях или в дополнение к средствам защиты веб-приложений, а также с целью обеспечения максимальной безопасности веб-приложения рекомендуется использовать внешние средства защиты, такие как брандмауэры веб-приложений (WAFS), которые могут смягчить уже описанные угрозы управления сеансами.

Брандмауэры веб-приложений предоставляют возможности обнаружения и защиты от атак на основе сеанса. С одной стороны, для WAF нет ничего сложного в том, чтобы принудительно использовать атрибуты безопасности для файлов cookie, такие как флаги `Secure` и `HttpOnly`, применяя базовые правила перезаписи в заголовке `Set-Cookie` для всех ответов веб-приложения, которые устанавливают новый файл cookie.

С другой стороны, могут быть реализованы более продвинутые возможности, позволяющие WAF отслеживать сеансы и соответствующие идентификаторы сеансов, а также применять все виды защиты от фиксации сеанса (путем обновления идентификатора сеанса на стороне клиента при обнаружении изменений привилегий), принудительного выполнения зависающих сеансов (путем проверки связь между идентификатором сеанса и другими свойствами клиента, такими как IP-адрес или пользовательский агент), или управление истечением срока действия сеанса (путем принудительного завершения сеанса как клиентом, так и веб-приложением).

WAF ModSecurity с открытым исходным кодом, а также OWASP [Базовый набор правил] (https://owasp.org/www-project-modsecurity-core-rule-set/) предоставляют возможности для обнаружения и применения атрибутов файлов cookie безопасности, противодействия атакам на фиксацию сеанса и функции отслеживания сеансов для принудительного выполнения зависающих сеансов.
