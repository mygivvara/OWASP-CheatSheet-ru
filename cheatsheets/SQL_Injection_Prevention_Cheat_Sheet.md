# Шпаргалка по предотвращению SQL-инъекций

## Вступление

Эта шпаргалка поможет вам предотвратить ошибки SQL-внедрения в ваших приложениях. В ней будет дано определение того, что такое SQL-внедрение, объяснено, где возникают эти ошибки, и представлены четыре варианта защиты от атак с использованием SQL-внедрения. Атаки [SQL-внедрение](https://owasp.org/www-community/attacks/SQL_Injection) распространены, потому что:

1. Уязвимости, связанные с внедрением SQL, очень распространены, и
2. База данных приложения является частой мишенью для злоумышленников, поскольку обычно содержит интересные/критически важные данные.

## Что такое атака с помощью SQL-инъекции?

Злоумышленники могут использовать SQL-инъекцию в приложении, если в нем есть динамические запросы к базе данных, использующие конкатенацию строк и пользовательский ввод. Чтобы избежать ошибок SQL-инъекции, разработчикам необходимо:

1. Прекратить писать динамические запросы с конкатенацией строк или
2. Предотвратите включение вредоносных данных SQL в выполняемые запросы.

Существуют простые методы предотвращения уязвимостей, связанных с внедрением SQL, и их можно использовать практически с любым языком программирования и базами данных любого типа. Хотя с базами данных XML могут возникать аналогичные проблемы (например, с внедрением XPath и XQuery), эти методы также можно использовать для их защиты.

## Анатомия типичной уязвимости SQL-инъекции

Ниже приведен распространенный недостаток SQL-внедрения в Java. Поскольку к запросу просто добавляется неподтвержденный параметр "CustomerName", злоумышленник может ввести SQL-код в этот запрос, а приложение возьмет код злоумышленника и выполнит его в базе данных.

```java
String query = "SELECT account_balance FROM user_data WHERE user_name = "
             + request.getParameter("customerName");
try {
    Statement statement = connection.createStatement( ... );
    ResultSet results = statement.executeQuery( query );
}

...
```

## Основные средства защиты

- **Вариант 1: Использование подготовленных инструкций (с параметризованными запросами)**
- **Вариант 2: Использование правильно построенных хранимых процедур**
- **Вариант 3: Разрешить проверку ввода списком**
- **Вариант 4: НАСТОЯТЕЛЬНО НЕ РЕКОМЕНДУЕТСЯ: Экранирование всего пользовательского ввода**

### Вариант защиты 1: Подготовленные инструкции (с параметризованными запросами)

Когда разработчиков учат писать запросы к базе данных, им следует посоветовать использовать подготовленные инструкции с привязкой к переменным (они же параметризованные запросы). Подготовленные инструкции просты в написании и более понятны, чем динамические запросы, а параметризованные запросы вынуждают разработчика сначала определять весь SQL-код, а затем передавать каждый параметр в запрос.

Если запросы к базе данных используют этот стиль кодирования, база данных всегда будет различать код и данные, независимо от того, какие данные вводятся пользователем. Кроме того, подготовленные инструкции гарантируют, что злоумышленник не сможет изменить цель запроса, даже если он введет команды SQL.

#### Пример безопасной инструкции, подготовленной на Java

В приведенном ниже примере с безопасной Java, если злоумышленник введет идентификатор пользователя `tom` или `1`=`1`, параметризованный запрос будет искать имя пользователя, которое буквально соответствует всей строке `tom` или `1`=`1`. Таким образом, база данных будет защищена от внедрения вредоносного SQL-кода.

В следующем примере кода используется `PreparedStatement`, Java-реализация параметризованного запроса, для выполнения того же запроса к базе данных.

```java
// Это тоже действительно должно быть валидировано
String custname = request.getParameter("customerName");
// Выполните проверку вводимых данных для обнаружения атак
String query = "SELECT account_balance FROM user_data WHERE user_name = ? ";
PreparedStatement pstmt = connection.prepareStatement( query );
pstmt.setString( 1, custname);
ResultSet results = pstmt.executeQuery( );
```

#### Пример безопасной инструкции, подготовленной на C\# .NET

В .NET процесс создания и выполнения запроса не меняется. Просто передайте параметры запросу, используя вызов `Parameters.Add()`, как показано ниже.

```csharp
String query = "SELECT account_balance FROM user_data WHERE user_name = ?";
try {
  OleDbCommand command = new OleDbCommand(query, connection);
  command.Parameters.Add(new OleDbParameter("customerName", CustomerName Name.Text));
  OleDbDataReader reader = command.ExecuteReader();
  // …
} catch (OleDbException se) {
  // error handling
}
```

Хотя мы показали примеры на Java и .NET, практически все другие языки (включая ColdFusion и классический ASP) поддерживают параметризованные интерфейсы запросов. Даже уровни абстракции SQL, такие как [Hibernate Query Language](http://hibernate.org/) (HQL), с такими же проблемами при внедрении (называемые [HQL Injection](http://cwe.mitre.org/data/definitions/564.html))  также поддерживают параметризованные запросы:

#### Пример подготовленной инструкции (именованные параметры) языка запросов Hibernate Query Language (HQL)

```java
// Это небезопасный оператор HQL
Query unsafeHQLQuery = session.createQuery("from Inventory where productID='"+userSuppliedParameter+"'");
// Вот безопасная версия того же запроса с использованием именованных параметров
Query safeHQLQuery = session.createQuery("from Inventory where productID=:productid");
safeHQLQuery.setParameter("productid", userSuppliedParameter);
```

#### Другие примеры безопасных подготовленных заявлений

Если вам нужны примеры готовых запросов/параметризованных языков, включая Ruby, PHP, Cold Fusion, Perl и Rust, смотрите [Шпаргалку по параметризации запросов](Query_Parameterization_Cheat_Sheet.md) или этот [сайт](http://bobby-tables.com/).

Как правило, разработчикам нравятся подготовленные инструкции, потому что весь SQL-код остается внутри приложения, что делает ваше приложение относительно независимым от базы данных.

### Вариант защиты 2: Хранимые процедуры

Хотя хранимые процедуры не всегда защищены от внедрения SQL, разработчики могут использовать определенные стандартные конструкции программирования хранимых процедур. Этот подход дает тот же эффект, что и использование параметризованных запросов, при условии, что хранимые процедуры реализованы безопасно (что является нормой для большинства языков хранимых процедур).

#### Безопасный подход к хранимым процедурам

Если необходимы хранимые процедуры, то самый безопасный подход к их использованию требует, чтобы разработчик создавал инструкции SQL с параметрами, которые автоматически параметризуются, если только разработчик не делает что-то в значительной степени нестандартное. Разница между подготовленными инструкциями и хранимыми процедурами заключается в том, что SQL-код для хранимой процедуры определяется и хранится в самой базе данных, а затем вызывается из приложения. Поскольку подготовленные инструкции и безопасные хранимые процедуры одинаково эффективны для предотвращения внедрения SQL-запросов, вашей организации следует выбрать наиболее подходящий для вас подход.

#### Когда Хранимые Процедуры Могут Увеличить Риск

Иногда хранимые процедуры могут увеличить риск атаки на систему. Например, в MS SQL Server у вас есть три основные роли по умолчанию: `db_datareader`, `db_datawriter` и `db_owner`. До того, как начали использоваться хранимые процедуры, базы данных предоставляли права `db_datareader` или `db_datawriter` пользователю веб-службы, в зависимости от требований.

Однако для хранимых процедур требуются права на выполнение, роль, которая по умолчанию недоступна. В некоторых установках, где управление пользователями централизовано, но ограничено этими тремя ролями, веб-приложения должны запускаться от имени `db_owner`, чтобы хранимые процедуры могли работать. Естественно, это означает, что в случае взлома сервера злоумышленник получает полные права на базу данных, где ранее у него мог быть доступ только для чтения.

#### Пример безопасной хранимой процедуры Java

В следующем примере кода используется Java-реализация интерфейса хранимой процедуры (`CallableStatement`) для выполнения того же запроса к базе данных. Хранимая процедура `sp_getAccountBalance` должна быть предварительно определена в базе данных и использовать ту же функциональность, что и запрос, приведенный выше.

```java
// Это действительно должно быть валидировано
String custname = request.getParameter("customerName");
try {
  CallableStatement cs = connection.prepareCall("{call sp_getAccountBalance(?)}");
  cs.setString(1, custname);
  ResultSet results = cs.executeQuery();
  // … обработка результирующего набора
} catch (SQLException se) {
  // … ведение журнала и обработка ошибок
}
```

#### Пример безопасной хранимой процедуры VB .NET

В следующем примере кода используется `SqlCommand`, реализация интерфейса хранимой процедуры в .NET, для выполнения того же запроса к базе данных. Хранимая процедура `sp_getAccountBalance` должна быть предварительно определена в базе данных и использовать ту же функциональность, что и запрос, определенный выше.

```vbnet
 Try
   Dim command As SqlCommand = new SqlCommand("sp_getAccountBalance", connection)
   command.CommandType = CommandType.StoredProcedure
   command.Parameters.Add(new SqlParameter("@CustomerName", CustomerName.Text))
   Dim reader As SqlDataReader = command.ExecuteReader()
   '...
 Catch se As SqlException
   'error handling
 End Try
```

### Вариант защиты 3: Разрешить проверку ввода списком

Если вы сталкиваетесь с частями SQL-запросов, которые не могут использовать переменные привязки, такие как имена таблиц или столбцов, а также индикатор порядка сортировки (ASC или DESC), наиболее подходящей защитой является проверка введенных данных или перепроектирование запроса. Когда требуются имена таблиц или столбцов, в идеале эти значения берутся из кода, а не из пользовательских параметров.

#### Пример Проверки Безопасного Имени Таблицы

ПРЕДУПРЕЖДЕНИЕ: Если значения пользовательских параметров используются для определения разных имен таблиц и столбцов, это является признаком плохого дизайна, и, если позволяет время, следует рассмотреть возможность полной перезаписи. Если это невозможно, разработчикам следует сопоставить значения параметров с допустимыми/ожидаемыми именами таблиц или столбцов, чтобы убедиться, что неподтвержденный пользовательский ввод не попадет в запрос.

В приведенном ниже примере, поскольку `tableName` определено как одно из допустимых и ожидаемых значений для имени таблицы в этом запросе, оно может быть непосредственно добавлено к SQL-запросу. Имейте в виду, что общие функции проверки таблиц могут привести к потере данных, поскольку имена таблиц используются в запросах, где они не ожидаются.

```text
String tableName;
switch(PARAM):
  case "Value1": tableName = "fooTable";
                 break;
  case "Value2": tableName = "barTable";
                 break;
  ...
  default      : throw new InputValidationException("unexpected value provided"
                                                  + " for table name");
```

#### Безопасное Использование Динамической Генерации SQL (НЕ РЕКОМЕНДУЕТСЯ)

Когда мы говорим, что хранимая процедура "реализована безопасно", это означает, что она не содержит небезопасной динамической генерации SQL. Разработчики обычно не генерируют динамический SQL внутри хранимых процедур. Однако это возможно, но этого следует избегать.

Если этого невозможно избежать, хранимая процедура должна использовать проверку ввода или надлежащее экранирование, как описано в этой статье, чтобы убедиться, что все введенные пользователем данные хранимой процедуры не могут быть использованы для ввода SQL-кода в динамически сгенерированный запрос. Аудиторам всегда следует обращать внимание на использование `sp_execute`, `execute` или `exec exec` в хранимых процедурах SQL Server. Аналогичные рекомендации по аудиту необходимы для аналогичных функций других поставщиков.

#### Пример более безопасной генерации динамических запросов (НЕ РЕКОМЕНДУЕТСЯ)

Для чего-то простого, например, для порядка сортировки, было бы лучше, если бы введенные пользователем данные преобразовались в логическое значение, а затем это логическое значение использовалось для выбора безопасного значения для добавления в запрос. Это очень стандартная необходимость при создании динамического запроса.

Например:

```java
public String someMethod(boolean sortOrder) {
 String SQLquery = "some SQL ... order by Salary " + (sortOrder ? "ASC" : "DESC");`
 ...
```

В любой момент пользовательский ввод может быть преобразован в нестроковый, например, в дату, числовой, логический, перечислимый тип и т.д., Прежде чем он будет добавлен к запросу или использован для выбора значения для добавления в запрос, это гарантирует безопасность такого действия.

Проверка входных данных также рекомендуется в качестве дополнительной защиты во всех случаях, даже при использовании переменных привязки, как обсуждалось ранее в этой статье. Дополнительные методы реализации надежной проверки входных данных описаны в [Шпаргалке по проверке входных данных](Input_Validation_Cheat_Sheet.md).

### Вариант защиты 4: НАСТОЯТЕЛЬНО НЕ РЕКОМЕНДУЕТСЯ: Экранирование всех вводимых пользователем данных

При таком подходе разработчик будет избегать всех вводимых пользователем данных, прежде чем вводить их в запрос. Реализация этого метода очень специфична для базы данных.  Эта методология является хрупкой по сравнению с другими средствами защиты, и мы НЕ можем гарантировать, что этот параметр предотвратит все SQL-инъекции во всех ситуациях.

Если приложение создается с нуля или требует низкой толерантности к рискам, его следует создать или переписать заново, используя параметризованные запросы, хранимые процедуры или какой-либо объектно-реляционный картограф (ORM), который создает ваши запросы за вас.

## Дополнительные средства защиты

Помимо использования одной из четырех основных средств защиты, мы также рекомендуем использовать все эти дополнительные средства защиты, чтобы обеспечить глубокую оборону. Эти дополнительные средства защиты включают:

- **Наименьшие привилегии**
- **Разрешить проверку ввода списком**

### Наименьшие привилегии

Чтобы свести к минимуму потенциальный ущерб от успешной атаки с использованием SQL-инъекции, вам следует минимизировать привилегии, назначенные каждой учетной записи базы данных в вашей среде. Начните с нуля, чтобы определить, какие права доступа требуются вашим учетным записям приложений, а не пытаться выяснить, какие права доступа вам нужно лишить.

Убедитесь, что учетным записям, которым требуется доступ только на чтение, предоставляется доступ на чтение только к тем таблицам, к которым им нужен доступ. НЕ НАЗНАЧАЙТЕ СВОИМ УЧЕТНЫМ ЗАПИСЯМ В ПРИЛОЖЕНИЯХ ПРАВА АДМИНИСТРАТОРА БАЗЫ ДАННЫХ ИЛИ ДОСТУПА ТИПА ADMIN. Мы понимаем, что это легко, и все просто "работает", когда вы делаете это таким образом, но это очень опасно.

#### Минимизация привилегий приложений и операционной системы

SQL-инъекция - не единственная угроза для вашей базы данных. Злоумышленники могут просто изменить значения параметров с одного из допустимых значений, которые им предоставляются, на неавторизованное для них значение, но доступ к самому приложению может быть разрешен. Таким образом, минимизация привилегий, предоставляемых вашему приложению, снизит вероятность таких попыток несанкционированного доступа, даже если злоумышленник не пытается использовать SQL-инъекцию как часть своего эксплойта.

При этом вам следует минимизировать привилегии учетной записи операционной системы, под которой работает СУБД. Не запускайте свою СУБД от имени root или system! Большинство СУБД "из коробки" запускаются с очень мощной системной учетной записью. Например, MySQL по умолчанию работает как системный в Windows! Измените учетную запись операционной системы СУБД на более подходящую, с ограниченными привилегиями.

#### Детали принципа минимальных привелегий при разработке

Если учетной записи требуется доступ только к части таблицы, рассмотрите возможность создания представления, которое ограничивает доступ к этой части данных, и вместо этого назначьте учетной записи доступ к представлению, а не к базовой таблице. Редко, если вообще когда-либо, предоставляйте учетным записям базы данных доступ для создания или удаления.

Если вы придерживаетесь политики, в соответствии с которой хранимые процедуры используются повсеместно, и не разрешаете учетным записям приложений напрямую выполнять свои запросы, то ограничьте этим учетным записям возможность выполнять только те хранимые процедуры, которые им нужны. Не предоставляйте им никаких прав непосредственно на таблицы в базе данных.

#### Минимальные права Администратора для нескольких баз данных

Разработчикам веб-приложений следует избегать использования одной и той же учетной записи владельца/администратора в веб-приложениях для подключения к базе данных. Для разных веб-приложений следует использовать разных пользователей базы данных.

В общем, каждое отдельное веб-приложение, которому требуется доступ к базе данных, должно иметь определенную учетную запись пользователя базы данных, которую приложение будет использовать для подключения к базе данных. Таким образом, разработчик приложения может обеспечить хорошую степень детализации в управлении доступом, что максимально снизит привилегии. Затем каждый пользователь базы данных получит доступ по выбору только к тому, что ему нужно, и доступ на запись по мере необходимости.

Например, для страницы входа в систему требуется доступ на чтение к полям имени пользователя и пароля в таблице, но нет доступа на запись в любой форме (без вставки, обновления или удаления). Однако страница регистрации, безусловно, требует привилегии insert для этой таблицы; это ограничение может быть применено только в том случае, если эти веб-приложения используют разных пользователей базы данных для подключения к базе данных.

#### Повышение минимальных привилегий с помощью SQL-представлений

Вы можете использовать SQL views для дальнейшего повышения детализации доступа, ограничивая доступ для чтения определенными полями таблицы или объединениями таблиц. Это может иметь дополнительные преимущества.

Например, если системе требуется (возможно, из-за каких-то особых требований законодательства) хранить пароли пользователей, а не пароли с соленым хэшем, разработчик мог бы использовать представления, чтобы компенсировать это ограничение. Они могли бы отозвать весь доступ к таблице (у всех пользователей базы данных, кроме владельца/администратора) и создать представление, которое выводит хэш поля пароля, а не само поле.

Любая атака с использованием SQL-инъекций, которая приведет к успешной краже информации из базы данных, будет ограничена кражей хэша паролей (может быть даже хэша с ключом), поскольку ни один пользователь базы данных ни в одном из веб-приложений не имеет доступа к самой таблице.

### Проверка ввода с помощью разрешенного списка

Помимо того, что проверка ввода является основной защитой, когда ничто другое невозможно (например, когда переменная привязки не является допустимой), она также может быть вторичной защитой, используемой для обнаружения несанкционированного ввода до того, как он будет передан в SQL-запрос. Для получения дополнительной информации, пожалуйста, ознакомьтесь с [Инструкцией по проверке правильности ввода](Input_Validation_Cheat_Sheet.md). Действуйте здесь с осторожностью. Проверенные данные необязательно безопасно вставлять в SQL-запросы с помощью построения строк.

## Статьи по теме

**Шпаргалки по атакам с использованием SQL-инъекций**:

В следующих статьях описывается, как использовать различные виды уязвимостей SQL-инъекций на различных платформах (эта статья была создана для того, чтобы помочь вам избежать их).:

- [SQL Injection Cheat Sheet](https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/)
- Обход того, что происходит с SQLi - [SQL Injection Bypassing WAF](https://owasp.org/www-community/attacks/SQL_Injection_Bypassing_WAF)

**Описание уязвимостей SQL-инъекций**:

- Статья OWASP об уязвимостях [SQL-инъекции](https://owasp.org/www-community/attacks/SQL_Injection)
- Статья OWASP об уязвимостях [Blind_SQL_Injection](https://owasp.org/www-community/attacks/Blind_SQL_Injection)

**Как избежать уязвимостей SQL-инъекций**:

- [Руководство для разработчиков OWASP](https://github.com/OWASP/DevGuide) статья о том, как избежать уязвимостей SQL-инъекций
- Шпаргалка по OWASP, содержащая [многочисленные языковые примеры параметризованных запросов с использованием как подготовленных инструкций, так и хранимых процедур](Query_Parameterization_Cheat_Sheet.md)
- [Сайт Bobby Tables (созданный по мотивам веб-комикса XKCD) содержит множество примеров параметризованных подготовленных инструкций и хранимых процедур на разных языках](http://bobby-tables.com/)

**Как проверить код на наличие уязвимостей SQL-инъекций**:

- [Руководство по проверке кода OWASP](https://wiki.owasp.org/index.php/Category:OWASP_Code_Review_Project) статья о том, как [проверить код для SQL-инъекций](https://wiki.owasp.org/index.php/Reviewing_Code_for_SQL_Injection) Уязвимости

**Как протестировать SQL-инъекцию на наличие уязвимостей**:

- [Руководство по тестированию OWASP](https://owasp.org/www-project-web-security-testing-guide) статья о том, как [тестировать SQL на наличие инъекций](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection.html) уязвимостей
