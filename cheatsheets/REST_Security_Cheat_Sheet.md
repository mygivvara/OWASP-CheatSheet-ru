# Шпаргалка по безопасности REST

## Introduction

[REST](http://en.wikipedia.org/wiki/Representational_state_transfer) (или Передача репрезентативного состояния (**RE**presentational **S**tate **T**ransfer)) - архитектурный стиль, впервые описанный в докторской диссертации [Роя Филдинга] (https://en.wikipedia.org/wiki/Roy_Fielding) на тему [Архитектурные стили и проектирование сетевых программных архитектур] (https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm).

Он развивался по мере того, как Филдинг писал спецификации HTTP/1.1 и URI, и зарекомендовал себя как хорошо подходящий для разработки распределенных гипермедиа-приложений. Хотя REST более широко применим, он чаще всего используется в контексте взаимодействия со службами через HTTP.

Ключевой абстракцией информации в REST является ресурс. Ресурс REST API идентифицируется с помощью URI, обычно это URL-адрес HTTP. Компоненты REST используют соединители для выполнения действий с ресурсом, используя представление для получения текущего или предполагаемого состояния ресурса и передачи этого представления.

Основными типами соединителей являются клиентский и серверный, к дополнительным соединителям относятся кэш, распознаватель и туннель.

REST API не имеют состояния. API с отслеживанием состояния не соответствуют архитектурному стилю REST. Аббревиатура State в REST означает состояние ресурса, к которому обращается API, а не состояние сеанса, в рамках которого вызывается API. Хотя для создания API с отслеживанием состояния могут быть веские причины, важно понимать, что управление сеансами является сложным и его трудно обеспечить безопасно.

Службы с отслеживанием состояния выходят за рамки данной инструкции: * Передача состояния от клиента серверной части, в то время как служба технически не имеет состояния, является анти-шаблоном, которого также следует избегать, поскольку он подвержен атакам воспроизведения и олицетворения.*

Чтобы реализовать потоки с помощью REST API, ресурсы обычно создаются, считываются, обновляются и удаляются. Например, сайт электронной коммерции может предлагать методы создания пустой корзины покупок, добавления товаров в корзину и извлечения из корзины. Каждый из этих вызовов REST не имеет состояния, и конечная точка должна проверить, авторизован ли вызывающий абонент для выполнения запрошенной операции.

Еще одной ключевой особенностью приложений REST является использование стандартных HTTP-команд и кодов ошибок для поиска или устранения ненужных различий между различными службами.

Другой ключевой особенностью приложений REST является использование [HATEOAS или Hypermedia в качестве движка состояния приложения](https://en.wikipedia.org/wiki/HATEOAS). Это придает приложениям REST самодокументирующийся характер, что упрощает разработчикам взаимодействие со службой REST без предварительного знания.

## HTTPS

Службы Secure REST должны предоставлять только конечные точки HTTPS. Это защищает учетные данные для аутентификации при передаче, например пароли, ключи API или веб-токены JSON. Это также позволяет клиентам аутентифицировать службу и гарантирует целостность передаваемых данных.

Дополнительную информацию смотрите в [Руководстве по безопасности транспортного уровня](Transport_Layer_Security_Cheat_Sheet.md).

Рассмотрите возможность использования взаимно аутентифицируемых клиентских сертификатов для обеспечения дополнительной защиты веб-служб с высокими привилегиями.

## Контроль доступа

Непубличные службы REST должны выполнять управление доступом в каждой конечной точке API. Веб-службы в монолитных приложениях реализуют это посредством аутентификации пользователя, логики авторизации и управления сеансами. Это имеет ряд недостатков для современных архитектур, которые объединяют несколько микросервисов в соответствии со стилем RESTful.

- чтобы минимизировать задержку и уменьшить взаимосвязь между службами, решение об управлении доступом должно приниматься локально конечными точками REST
- аутентификация пользователя должна быть централизована поставщиком идентификационных данных (IdP), который выдает токены доступа

## JWT

Похоже, что наблюдается тенденция к использованию [веб-токенов JSON](https://tools.ietf.org/html/rfc7519) (JWT) в качестве формата для токенов безопасности. JWT - это структуры данных в формате JSON, содержащие набор утверждений, которые могут использоваться для принятия решений об управлении доступом. Для защиты целостности JWT можно использовать криптографическую подпись или код аутентификации сообщения (MAC).

- Убедитесь, что целостность JWT защищена либо подписью, либо MAC-адресом. Не разрешайте использовать незащищенный Jwt: `{"alg":"none"}`.
    - Смотрите [здесь](https://tools.ietf.org/html/rfc7519#section-6.1)
- В целом, для защиты целостности JWT следует отдавать предпочтение подписям, а не MAC-адресам.

Если для защиты целостности используются MAC-адреса, каждая служба, способная проверять JWT, может также создавать новые JWT, используя тот же ключ. Это означает, что все службы, использующие один и тот же ключ, должны взаимно доверять друг другу. Другим следствием этого является то, что компрометация любой службы также приводит к компрометации всех других служб, использующих тот же ключ. Дополнительную информацию смотрите [здесь](https://tools.ietf.org/html/rfc 7515#раздел-10.5).

Проверяющая сторона или потребитель токена проверяет JWT, проверяя его целостность и содержащиеся в нем утверждения.

- Проверяющая сторона должна проверить целостность JWT на основе своей собственной конфигурации или жестко запрограммированной логики. Она не должна полагаться на информацию из заголовка JWT для выбора алгоритма проверки. Смотрите [здесь](https://www.chosenplaintext.ca/2015/03/31/jwt-algorithm-confusion.html) и [здесь](https://www.youtube.com/watch?v=bW5pS4e_MX8>).

Некоторые утверждения были стандартизированы и должны присутствовать в JWT, используемом для контроля доступа. Необходимо проверить, по крайней мере, следующие стандартные утверждения:

- `iss` или эмитент - это доверенный эмитент? Является ли он предполагаемым владельцем ключа подписи?
- `aud" или аудитория - входит ли проверяющая сторона в целевую аудиторию этого JWT?
- `exp` или время истечения срока действия - это текущее время до окончания срока действия этого токена?
- `nbf` или не раньше времени - это текущее время после начала срока действия этого токена?

Поскольку JWT содержат сведения о прошедшем проверку подлинности объекте (пользователе и т.д.), может произойти разрыв связи между JWT и текущим состоянием сеанса пользователя, например, если сеанс завершается раньше истечения срока действия из-за явного выхода из системы или тайм-аута ожидания. Когда происходит явное событие завершения сеанса, дайджест или хэш любых связанных JWT должны быть отправлены в denylist API, который сделает этот JWT недействительным для любых запросов до истечения срока действия токена. Смотрите раздел [JSON_Web_Token_for_Java_Cheat_Sheet](JSON_Web_Token_for_Java_Cheat_Sheet.md#token-explicit-revocation-by-the-user) для получения более подробной информации.

## Ключи API

Общедоступные службы REST без контроля доступа рискуют быть перегруженными, что приведет к чрезмерным расходам на пропускную способность или вычислительные циклы. Для снижения этого риска можно использовать ключи API. Они также часто используются организациями для монетизации API-интерфейсов; вместо блокировки высокочастотных вызовов клиентам предоставляется доступ в соответствии с приобретенным тарифным планом доступа.

Ключи API могут снизить риск атак типа "отказ в обслуживании". Однако, когда они выдаются сторонним клиентам, их относительно легко скомпрометировать.

- Требовать ключи API для каждого запроса к защищенной конечной точке.
- Возвращать код HTTP-ответа `429 Слишком много запросов`, если запросы поступают слишком быстро.
- Отзывать ключ API, если клиент нарушает соглашение об использовании.
- Не полагайтесь исключительно на API-ключи для защиты конфиденциальных, критичных или особо ценных ресурсов.

## Ограничьте HTTP-методы

- Примените список разрешенных HTTP-методов, например `GET`, `POST`, `PUT`.
- Отклоняйте все запросы, не соответствующие списку разрешенных, с кодом ответа HTTP `Метод 405 не разрешен`.
- Убедитесь, что вызывающий абонент авторизован для использования входящего HTTP-метода при сборе ресурсов, действии и записи

В частности, в Java EE это может быть сложно реализовать должным образом. Смотрите [Обход веб-аутентификации и авторизации с помощью HTTP Verb Tampering](../assets/REST_Security_Cheat_Sheet_Bypassing_VBAAC_with_HTTP_Verb_Tampering.pdf) для объяснения этой распространенной ошибки настройки.

## Проверка правильности введенных данных

- Не доверяйте входным параметрам/объектам.
- Проверяйте вводимые данные: длину / диапазон / формат и тип.
- Добейтесь неявной проверки ввода, используя строгие типы, такие как числа, логические значения, даты, время или фиксированные диапазоны данных в параметрах API.
- Ограничьте ввод строк регулярными выражениями.
- Отклоняйте неожиданный/ незаконный контент.
- Используйте библиотеки проверки/очистки или фреймворки на вашем конкретном языке.
- Определите соответствующее ограничение по размеру запроса и отклоняйте запросы, превышающие это ограничение, если объект запроса со статусом ответа HTTP 413 Слишком велик.
- Рассмотрите возможность регистрации ошибок проверки ввода. Предположим, что кто-то, кто выполняет сотни неудачных проверок ввода в секунду, не справляется.
- Ознакомьтесь с инструкцией по проверке ввода для получения подробного объяснения.
- Используйте безопасный синтаксический анализатор для анализа входящих сообщений. Если вы используете XML, убедитесь, что вы используете синтаксический анализатор, который не уязвим для [XXE](https://owasp.org/www-community/vulnerabilities/XML_External_Entity_%28XXE%29_Processing) и подобных атак.

## Проверка типов контента

Текст запроса REST или ответа должен соответствовать указанному в заголовке типу контента. В противном случае это может привести к неправильному толкованию на стороне потребителя/производителя и привести к внедрению/выполнению кода.

- Задокументируйте все поддерживаемые типы контента в вашем API.

### Проверка типов содержимого запросов

- Отклонять запросы, содержащие неожиданные или отсутствующие заголовки типов контента, со статусом HTTP-ответа `406 Unacceptable` или `415 Unsupported Media Type`.
- Для типов контента XML необходимо обеспечить надлежащую проверку синтаксического анализа XML, см. [XXE-шпаргалку](XML_External_Entity_Prevention_Cheat_Sheet.md).
- Избегайте случайного раскрытия непреднамеренных типов контента, явно определяя типы контента, например, [Jersey](https://jersey.github.io/) (Java) `@потребляет("приложение/json"); @производит ("приложение/json")`. Это позволяет избежать, например, векторов [XXE-attack](https://owasp.org/www-community/vulnerabilities/XML_External_Entity_%28XXE%29_Processing).

### Типы контента для отправки безопасного ответа

Обычно службы REST разрешают использование нескольких типов ответов (например, `application/xml` или `application/json`), и клиент указывает предпочтительный порядок типов ответов с помощью заголовка Accept в запросе.

- **НЕ** следует просто копировать заголовок `Accept` в заголовок `Content-type` ответа.
- Отклоните запрос (в идеале с ответом `406 Unacceptable`), если заголовок `Accept` не содержит ни одного из допустимых типов.

Службы, включающие в свои ответы скриптовый код (например, JavaScript), должны быть особенно осторожны, чтобы защититься от атаки с использованием заголовков.

- Убедитесь, что отправка заголовков с предполагаемым типом контента в вашем ответе соответствует содержимому основного текста, например, `application/json`, а не `application/javascript`.

## Конечные точки управления

- Избегайте предоставления доступа к конечным точкам управления через Интернет.
- Если конечные точки управления должны быть доступны через Интернет, убедитесь, что пользователи должны использовать надежный механизм аутентификации, например многофакторный.
- Предоставлять доступ к конечным точкам управления через разные HTTP-порты или хосты, предпочтительно в другой сетевой карте и подсети с ограниченным доступом.
- Ограничить доступ к этим конечным точкам с помощью правил брандмауэра или использования списков контроля доступа.

## Обработка ошибок

- Отвечайте общими сообщениями об ошибках. - избегайте излишнего раскрытия деталей сбоя.
- Не сообщайте клиенту технические подробности (например, стеки вызовов или другие внутренние подсказки).

## Журналы аудита

- Записывайте журналы аудита до и после событий, связанных с безопасностью.
- Рассмотрите возможность регистрации ошибок проверки токена для обнаружения атак.
- Позаботьтесь об атаках с внедрением журналов, предварительно очистив данные журнала.

## Заголовки безопасности

Существует ряд [заголовков, связанных с безопасностью](https://owasp.org/www-project-secure-headers/), которые могут быть возвращены в HTTP-ответах, чтобы указать браузерам, как действовать определенным образом. Однако некоторые из этих заголовков предназначены для использования с HTML-ответами и, как таковые, могут практически не обеспечивать безопасность API, который не возвращает HTML.

Следующие заголовки должны быть включены во все ответы API:

| Заголовок | Обоснование |
|--------|-----------|
| `Cache-Control: no-store` | Заголовок, используемый для прямого кэширования, выполняемого браузерами. Указание `no-store` означает, что любые кэши любого типа (частные или общие) не должны сохранять ответ, содержащий заголовок. Браузер должен делать новый запрос каждый раз, когда вызывается API, для получения последнего ответа. Этот заголовок со значением "no-store" предотвращает кэширование или сохранение конфиденциальной информации. |
| `Content-Security-Policy: frame-ancestors 'none'` | Заголовок, используемый для указания того, может ли ответ быть оформлен в виде элемента `<frame>`, `<iframe>`, `<embed>` или `<object>`. Для ответа API не требуется, чтобы он был оформлен каким-либо из этих элементов. Указание `frame-ancestors 'none'` не позволяет ни одному домену создавать фрейм для ответа, возвращаемого вызовом API. Этот заголовок защищает от атак с перехватом кликов в стиле [drag-and-drop](https://www.w3.org/Security/wiki/Clickjacking_Threats#Drag_and_drop_attacks). |
| `Content-Type` | Заголовок для указания типа содержимого ответа. Это должно быть указано в соответствии с типом содержимого, возвращаемого вызовом API. Если не указано или указано неправильно, браузер может попытаться угадать тип содержимого ответа. Это может быть возвращено при атаках перехвата MIME. Одним из распространенных значений типа контента является `application/json`, если ответом API является JSON. |
| `Strict-Transport-Security` | Заголовок, указывающий браузеру, что доступ к домену должен осуществляться только по протоколу HTTPS и что любые будущие попытки доступа к нему по протоколу HTTP должны автоматически преобразовываться в HTTPS. Этот заголовок гарантирует, что вызовы API выполняются по протоколу HTTPS, и защищает от подделки сертификатов. |
| `X-Content-Type-Options: nosniff` | Заголовок, указывающий браузеру всегда использовать тип MIME, который объявлен в заголовке `Content-Type`, вместо того, чтобы пытаться определить тип MIME на основе содержимого файла. Этот заголовок со значением `nosniff` не позволяет браузерам выполнять поиск в формате MIME и неправильно интерпретировать ответы в формате HTML. |
| `X-Frame-Options: DENY` | Заголовок, используемый для указания того, может ли ответ быть оформлен в виде элемента `<frame>`, `<iframe>`, `<embed>` или `<object>`. Для ответа API не требуется, чтобы он был оформлен каким-либо из этих элементов. Указание `DENY` не позволяет ни одному домену формировать ответ, возвращаемый вызовом API. Этот заголовок со значением `DENSITY` защищает от атак в стиле [drag-and-drop](https://www.w3.org/Security/wiki/Clickjacking_Threats#Drag_and_drop_attacks), связанных с перехватом кликов. |

Нижеприведенные заголовки предназначены только для обеспечения дополнительной безопасности при отображении ответов в формате HTML. Таким образом, если API **никогда** не будет возвращать HTML в ответах, то эти заголовки могут и не понадобиться. Однако, если есть какая-либо неопределенность в отношении функции заголовков или типов информации, которую возвращает API (или может вернуть в будущем), рекомендуется включать их в качестве части комплексного подхода к защите.

| Заголовок | Пример | Обоснование |
|--------|-----------|-----------|
| Content-Security-Policy | `Content-Security-Policy: default-src 'none'` | Большинство функций CSP влияют только на страницы, отображаемые в формате HTML. |
| Permissions-Policy | `Permissions-Policy: accelerometer=(), ambient-light-sensor=(), autoplay=(), battery=(), camera=(), cross-origin-isolated=(), display-capture=(), document-domain=(), encrypted-media=(), execution-while-not-rendered=(), execution-while-out-of-viewport=(), fullscreen=(), geolocation=(), gyroscope=(), keyboard-map=(), magnetometer=(), microphone=(), midi=(), navigation-override=(), payment=(), picture-in-picture=(), publickey-credentials-get=(), screen-wake-lock=(), sync-xhr=(), usb=(), web-share=(), xr-spatial-tracking=()` | Этот заголовок раньше назывался Feature-Policy. Когда браузеры учитывают этот заголовок, он используется для управления функциями браузера с помощью директив. В примере отключаются функции с пустым списком разрешений для ряда разрешенных [имен директив](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy#directives). Когда вы будете применять этот заголовок, убедитесь, что директивы актуальны и соответствуют вашим потребностям. Пожалуйста, ознакомьтесь с этой [статьей](https://developer.chrome.com/en/docs/privacy-sandbox/permissions-policy), чтобы получить подробное объяснение того, как управлять функциями браузера. |
| Referrer-Policy | `Referrer-Policy: no-referrer` | Ответы, отличные от HTML, не должны вызывать дополнительных запросов. |

## CORS

Общий доступ к ресурсам разных источников (CORS) - это стандарт W3C, позволяющий гибко определять, какие междоменные запросы разрешены. Предоставляя соответствующие заголовки CORS, ваш REST API сигнализирует браузеру, какие домены, также известные как origins, разрешены для выполнения вызовов JavaScript для службы REST.

- Отключите заголовки CORS, если междоменные вызовы не поддерживаются/ожидаются.
- При настройке источников междоменных вызовов будьте как можно более конкретными и как можно более общими при необходимости.

## Конфиденциальная информация в HTTP-запросах

Веб-службы RESTful должны быть осторожны, чтобы предотвратить утечку учетных данных. Пароли, токены безопасности и API-ключи не должны отображаться в URL-адресе, поскольку это может быть зафиксировано в журналах веб-сервера, что делает их чрезвычайно ценными.

- В запросах `POST`/`PUT` конфиденциальные данные должны передаваться в теле запроса или в заголовках запросов.
- В запросах `GET` конфиденциальные данные должны передаваться в HTTP-заголовке.

**OK:**

`https://example.com/resourceCollection/[ID]/action`

`https://twitter.com/vanderaj/lists`

**НЕ OK:**

`https://example.com/controller/123/action?apiKey=a53f435643de32` потому что ключ API находится в URL-адресе.

## Код возврата HTTP

HTTP определяет [код состояния](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). При разработке REST API не используйте просто `200` для успешного выполнения или `404` для ошибки. Всегда используйте семантически подходящий код состояния для ответа.

Вот неполный список **кодов состояния** REST API, связанных с безопасностью. Используйте его, чтобы убедиться, что вы возвращаете правильный код.

| Код | Сообщение                | Описание                                                                                                                                                                                                          |
|-------------|------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 200         | OK                     |  Ответ на успешное действие REST API. HTTP-метод может быть GET, POST, PUT, PATCH или DELETE.                                                                                                                  |
| 201         | Created                |  Запрос выполнен, и ресурс создан. В заголовке Location возвращается URI для созданного ресурса.                                                                                            |
| 202         | Accepted               | Запрос принят к обработке, но обработка еще не завершена.                                                                                                                                     |
| 301         | Moved Permanently       | Постоянное перенаправление.                                                                                                                                                                                                |
| 304         | Not Modified           | Связанный с кэшированием ответ, который возвращается, когда у клиента есть та же копия ресурса, что и у сервера.                                                                                                                  |
| 307         | Temporary Redirect     | Временное перенаправление ресурса.                                                                                                                                                                                   |
| 400         | Bad Request            | Запрос неправильно сформирован, например, ошибка в формате текста сообщения.                                                                                                                                                          |
| 401         | Unauthorized           | Неверный идентификатор или пароль для аутентификации не указаны.                                                                                                                                                                      |
| 403         | Forbidden              |  Это используется, когда аутентификация прошла успешно, но у прошедшего проверку пользователя нет прав на запрос ресурса.                                                                                                |
| 404         | Not Found              | Когда запрашивается несуществующий ресурс.                                                                                                                                                                            |
| 405         | Method Not Acceptable  |  Ошибка из-за неожиданного HTTP-метода. Например, REST API ожидает HTTP GET, но используется HTTP PUT.                                                                                                    |
| 406         | Unacceptable           | Клиент представил тип контента в заголовке Accept, который не поддерживается серверным API.                                                                                                                    |
| 413         | Payload too large      | Используйте его, чтобы сигнализировать о том, что размер запроса превысил заданный предел, например, в отношении загрузки файлов.                                                                                                                          |
| 415         | Unsupported Media Type | Запрашиваемый тип контента не поддерживается службой REST.                                                                                                                                                      |
| 429         | Too Many Requests      |  Ошибка используется, когда может быть обнаружена DOS-атака или запрос отклонен из-за ограничения скорости.                                                                                                           |
| 500         | Internal Server Error  | Непредвиденные обстоятельства помешали серверу выполнить запрос. Помните, что в ответе не должна содержаться внутренняя информация, которая может помочь злоумышленнику, например подробные сообщения об ошибках или трассировка стека. |
| 501         | Not Implemented        | Служба REST еще не выполнила запрошенную операцию.                                                                                                                                                      |
| 503         | Service Unavailable    |  Служба REST временно не может обработать запрос. Используется для информирования клиента о необходимости повторной попытки позднее.                                                                                         |

Дополнительную информацию об использовании кода возврата HTTP в REST API можно найти [здесь](https://www.restapitutorial.com/httpstatuscodes.html) и [здесь](https://restfulapi.net/http-status-codes).
