# Шпаргалка по безопасности Node JS

## Вступление

В этой инструкции перечислены действия, которые разработчики могут предпринять для разработки безопасных приложений Node.js. Каждый элемент содержит краткое объяснение и решение, специфичное для конкретной среды Node.js.

## Контекст

Число приложений Node.js растет, и они ничем не отличаются от других платформ и языков программирования. Node.js приложения подвержены всевозможным уязвимостям веб-приложений.

## Цель

Данная шпаргалка призвана обеспечить список лучших методик при разработке Node.js приложения.

## Рекомендации

Существует несколько рекомендаций по повышению безопасности вашего Node.js приложения. Они классифицируются как:

- **Безопасность приложений**
- **Обработка ошибок и исключений**
- **Безопасность сервера**
- **Безопасность платформы**

### Безопасность приложений

#### Используйте плоские цепочки обещаний

Асинхронные функции обратного вызова являются одной из самых сильных сторон Node.js. Однако увеличение уровня вложенности функций обратного вызова может стать проблемой. Любой многоступенчатый процесс может быть вложен на 10 и более уровней глубже. Эту проблему называют "Пирамидой гибели" или "адом обратного вызова". В таком коде ошибки и результаты теряются в процессе обратного вызова. Обещания - хороший способ написать асинхронный код, не попадая во вложенные пирамиды. Обещания обеспечивают выполнение "сверху вниз" в асинхронном режиме, передавая ошибки и результаты в следующую функцию `.then`.

Еще одним преимуществом Promises является то, как Promises обрабатывает ошибки. Если в классе Promise возникает ошибка, он пропускает функции `.then` и вызывает первую найденную функцию `.catch`. Таким образом, Promises обеспечивает более высокую степень уверенности в обнаружении и обработке ошибок. В принципе, вы можете заставить весь ваш асинхронный код (кроме отправителей) возвращать обещания. Следует отметить, что вызовы Promise также могут стать пирамидой. Чтобы полностью избежать "Ада обратного вызова(Callback Hell)", следует использовать плоские цепочки обещаний. Если используемый вами модуль не поддерживает Promises, вы можете преобразовать базовый объект в Promise, используя функцию `Promise.promisifyAll()`.

Следующий фрагмент кода является примером "Ада обратного вызова":

```JavaScript
function func1(name, callback) {
  // операции, которые занимают немного времени, а затем вызывают обратный вызов
}
function func2(name, callback) {
  // операции, которые занимают немного времени, а затем вызывают обратный вызов
}
function func3(name, callback) {
  // операции, которые занимают немного времени, а затем вызывают обратный вызов
}
function func4(name, callback) {
  // операции, которые занимают немного времени, а затем вызывают обратный вызов
}

func1("input1", function(err, result1){
   if(err){
      // операции с ошибками
   }
   else {
      //некоторые операции
      func2("input2", function(err, result2){
         if(err){
            //операции с ошибками
         }
         else{
            //некоторые операции
            func3("input3", function(err, result3){
               if(err){
                  //операции с ошибками
               }
               else{
                  // некоторые операции
                  func4("input 4", function(err, result4){
                     if(err){
                        // операции с ошибками
                     }
                     else {
                        // некоторые операции
                     }
                  });
               }
            });
         }
      });
   }
});
```

Приведенный выше код может быть надежно записан следующим образом с использованием плоской цепочки обещаний:

```JavaScript
function func1(name) {
  // операции, которые занимают немного времени, а затем устраняют проблему с обещанием
}
function func2(name) {
  // операции, которые занимают немного времени, а затем устраняют проблему с обещанием
}
function func3(name) {
  // операции, которые занимают немного времени, а затем устраняют проблему с обещанием
}
function func4(name) {
  // операции, которые занимают немного времени, а затем устраняют проблему с обещанием
}

func1("input1")
   .then(function (result){
      return func2("input2");
   })
   .then(function (result){
      return func3("input3");
   })
   .then(function (result){
      return func4("input4");
   })
   .catch(function (error) {
      // операции с ошибками
   });
```

И использование async/await:

```JavaScript
function async func1(name) {
  // операции, которые занимают немного времени, а затем устраняют проблему с обещанием
}
function async func2(name) {
  // операции, которые занимают немного времени, а затем устраняют проблему с обещанием
}
function async func3(name) {
  // операции, которые занимают немного времени, а затем устраняют проблему с обещанием
}
function async func4(name) {
  // операции, которые занимают немного времени, а затем устраняют проблему с обещанием
}

(async() => {
  try {
    let res1 = await func1("input1");
    let res2 = await func2("input2");
    let res3 = await func3("input2");
    let res4 = await func4("input2");
  } catch(err) {
    // операции с ошибками
  }
})();
```

#### Установите ограничения на размер запроса

Буферизация и синтаксический анализ текстов запросов могут быть ресурсоемкой задачей. Если размер запросов не ограничен, злоумышленники могут отправлять запросы с большими текстами запросов, что может привести к истощению памяти сервера и/или заполнению дискового пространства. Вы можете ограничить размер текста запроса для всех запросов, используя [raw-body](https://www.npmjs.com/package/raw-body).

```JavaScript
const contentType = require('content-type')
const express = require('express')
const getRawBody = require('raw-body')

const app = express()

app.use(function (req, res, next) {
  if (!['POST', 'PUT', 'DELETE'].includes(req.method)) {
    next()
    return
  }

  getRawBody(req, {
    length: req.headers['content-length'],
    limit: '1kb',
    encoding: contentType.parse(req).parameters.charset
  }, function (err, string) {
    if (err) return next(err)
    req.text = string
    next()
  })
})
```

Однако установление ограничения на размер запроса для всех запросов может быть неправильным решением, поскольку некоторые запросы могут содержать большую полезную нагрузку в теле запроса, например, при загрузке файла. Кроме того, ввод данных с типом JSON более опасен, чем ввод данных, состоящих из нескольких частей, поскольку синтаксический анализ JSON является блокирующей операцией. Поэтому вам следует установить ограничения на размер запроса для разных типов контента. Вы можете очень легко выполнить это с помощью express middleware следующим образом:

```JavaScript
app.use(express.urlencoded({ extended: true, limit: "1kb" }));
app.use(express.json({ limit: "1kb" }));
```

Следует отметить, что злоумышленники могут изменить заголовок запроса `Content-Type` и обойти ограничения на размер запроса. Поэтому перед обработкой запроса данные, содержащиеся в запросе, должны быть проверены на соответствие типу контента, указанному в заголовках запроса. Если проверка типа контента для каждого запроса серьезно влияет на производительность, вы можете проверять только определенные типы контента или запросы, размер которых превышает заданный.

#### Не блокируйте цикл обработки событий

Node.js сильно отличается от обычных платформ приложений, использующих потоки. Node.js имеет однопоточную архитектуру, управляемую событиями. Благодаря этой архитектуре повышается пропускная способность и упрощается модель программирования. Node.js реализована на основе неблокирующего цикла обработки событий ввода-вывода. Благодаря этому циклу обработки событий не требуется ожидание ввода-вывода или переключения контекста. Цикл обработки событий выполняет поиск событий и отправляет их в функции-обработчики. Из-за этого, когда выполняются операции JavaScript с интенсивной нагрузкой на процессор, цикл обработки событий ожидает их завершения. Вот почему такие операции называются "блокированием". Чтобы преодолеть эту проблему, Node.js позволяет назначать обратные вызовы событиям, заблокированным при вводе-выводе. Таким образом, основное приложение не блокируется, и обратные вызовы выполняются асинхронно. Поэтому, как правило, все операции блокировки должны выполняться асинхронно, чтобы цикл обработки событий не блокировался.

Даже если вы выполняете операции блокировки асинхронно, ваше приложение все равно может работать не так, как ожидалось. Это происходит, если за пределами обратного вызова есть код, который запускается первым, используя код внутри обратного вызова. Например, рассмотрим следующий код:

```JavaScript
const fs = require('fs');
fs.readFile('/file.txt', (err, data) => {
  // выполняются действия с содержимым файла
});
fs.unlinkSync('/file.txt');
```

В приведенном выше примере функция `unlinkSync` может быть запущена перед обратным вызовом, что приведет к удалению файла до того, как будут выполнены требуемые действия с содержимым файла. Такие условия "гонки" также могут повлиять на безопасность вашего приложения. Примером может служить сценарий, в котором аутентификация выполняется при обратном вызове, а аутентифицированные действия выполняются синхронно. Чтобы исключить такие условия гонки, вы можете записать все операции, которые зависят друг от друга, в одну неблокирующую функцию. Поступая таким образом, вы можете гарантировать, что все операции выполняются в правильном порядке. Например, приведенный выше пример кода может быть написан неблокирующим способом следующим образом:

```JavaScript
const fs = require('fs');
fs.readFile('/file.txt', (err, data) => {
  // perform actions on file content
  fs.unlink('/file.txt', (err) => {
    if (err) throw err;
  });
});
```

В приведенном выше коде вызов для разъединения файла и другие операции с файлами выполняются в рамках одного и того же обратного вызова. Это обеспечивает правильный порядок операций.

#### Выполните проверку введенных данных

Проверка вводимых данных является важной частью безопасности приложений. Сбои в проверке вводимых данных могут привести к различным типам атак на приложения. К ним относятся внедрение SQL, межсайтовый скриптинг, внедрение команд, локальное/удаленное включение файлов, отказ в обслуживании, обход каталогов, внедрение LDAP и многие другие атаки с использованием инъекций. Чтобы избежать подобных атак, входные данные в вашем приложении должны быть предварительно обработаны. Лучший способ проверки входных данных - использовать список принятых входных данных. Однако, если это невозможно, входные данные должны быть сначала проверены на соответствие ожидаемой схеме ввода и опасные входные данные должны быть экранированы. Для упрощения проверки вводимых данных в приложениях Node.js существует несколько модулей, таких как [validator](https://www.npmjs.com/package/validator) и [express-mongo-sanitize](https://www.npmjs.com/package/express-mongo-sanitize).
Подробную информацию о проверке вводимых данных см. в [Шпаргалке по проверке вводимых данных](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html).

JavaScript - это динамический язык, и в зависимости от того, как фреймворк анализирует URL, данные, которые видит код приложения, могут принимать различные формы. Вот несколько примеров после анализа строки запроса в express.js:

| URL | Содержание request.query.foo в коде |
| --- | --- |
| `?foo=bar` | `'bar'` (string) |
| `?foo=bar&foo=baz` | `['bar', 'baz']` (array of string) |
| `?foo[]=bar` | `['bar']` (array of string) |
| `?foo[]=bar&foo[]=baz` | `['bar', 'baz']` (array of string) |
| `?foo[bar]=baz` | `{ bar : 'baz' }` (object with a key) |
| `?foo[]baz=bar` | `['bar']` (array of string - postfix is lost) |
| `?foo[][baz]=bar` | `[ { baz: 'bar' } ]` (array of object) |
| `?foo[bar][baz]=bar` | `{ foo: { bar: { baz: 'bar' } } }` (object tree) |
| `?foo[10]=bar&foo[9]=baz` | `[ 'baz', 'bar' ]` (array of string - notice order) |
| `?foo[toString]=bar` | `{}` (object where calling `toString()` will fail) |

#### Выполняйте экранирование выходных данных

В дополнение к проверке вводимых данных, вы должны избегать всего содержимого HTML и JavaScript, отображаемого пользователям через приложение, чтобы предотвратить атаки с использованием межсайтовых сценариев (XSS). Вы можете использовать библиотеки [escape-html](https://github.com/component/escape-html) или [node-esapi](https://github.com/ESAPI/node-esapi) для выполнения экранирования выходных данных.

#### Ведение журнала действий приложения

Рекомендуется вести журнал активности приложения. Это упрощает отладку любых ошибок, возникающих во время выполнения приложения. Это также полезно для обеспечения безопасности, поскольку его можно использовать при реагировании на инциденты. Кроме того, эти журналы могут использоваться для обеспечения работы систем обнаружения и предотвращения вторжений (IDS/IPS). В Node.js существуют такие модули, как [Winston](https://www.npmjs.com/package/winston), [Bunyan](https://www.npmjs.com/package/bunyan) или [Pino](https://www.npmjs.com/package/pino) для ведения журнала активности приложений. Эти модули обеспечивают потоковую передачу и запрос журналов, а также предоставляют способ обработки неперехваченных исключений.

С помощью следующего кода вы можете регистрировать действия приложения как в консоли, так и в нужном файле журнала:

```JavaScript
const logger = new (Winston.Logger) ({
    transports: [
        new (winston.transports.Console)(),
        new (winston.transports.File)({ filename: 'application.log' })
    ],
    level: 'verbose'
});
```

Вы можете предоставить различные способы передачи данных, чтобы сохранять ошибки в отдельном файле журнала, а общие журналы приложений - в другом файле журнала. Дополнительную информацию о ведении журнала безопасности можно найти в [Инструкции по ведению журнала](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html).

#### Следите за циклом обработки событий

Когда ваш сервер приложений перегружен сетевым трафиком, он может быть не в состоянии обслуживать своих пользователей. По сути, это тип атаки [Отказ в обслуживании (DoS)](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html). Модуль [toobusy-js](https://www.npmjs.com/package/toobusy-js) позволяет отслеживать цикл обработки событий. Он отслеживает время отклика, и когда оно превышает определенный порог, этот модуль может указывать на то, что ваш сервер слишком занят. В этом случае вы можете прекратить обработку входящих запросов и отправить им сообщение `503 Server Too Busy` , чтобы ваше приложение продолжало реагировать. Здесь показан пример использования модуля [toobusy-js](https://www.npmjs.com/package/toobusy-js):

```JavaScript
const toobusy = require('toobusy-js');
const express = require('express');
const app = express();
app.use(function(req, res, next) {
    if (toobusy()) {
        // log if you see necessary
        res.status(503).send("Server Too Busy");
    } else {
    next();
    }
});
```

#### Примите меры предосторожности против брутфорса

[Brute-forcing](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#protect-against-automated-attacks
) представляет собой общую угрозу для всех веб-приложений. Злоумышленники могут использовать брутфорсинг в качестве атаки с подбором пароля для получения паролей учетных записей. Поэтому разработчикам приложений следует принимать меры предосторожности против атак с использованием брутфорса, особенно на страницах входа в систему.  Node.js для этой цели доступно несколько модулей. [Express-bouncer](https://libraries.io/npm/express-bouncer), [express-brute] (https://libraries.io/npm/express-brute) и [rate-limiter] (https://libraries.io/npm/rate-limiter) - это лишь некоторые примеры. Исходя из ваших потребностей, вы должны выбрать один или несколько из этих модулей и использовать их соответствующим образом. Модули [Express-bouncer](https://libraries.io/npm/express-bouncer) и [express-brute](https://libraries.io/npm/express-brute) работают аналогично. Они увеличивают задержку при каждом неудачном запросе и могут быть настроены для определенного маршрута. Эти модули можно использовать следующим образом:

```JavaScript
const bouncer = require('express-bouncer');
bouncer.whitelist.push('127.0.0.1'); // разрешить использование IP-адреса
// выдает пользовательское сообщение об ошибке
bouncer.blocked = function (req, res, next, remaining) {
    res.status(429).send("Too many requests have been made. Please wait " + remaining/1000 + " seconds.");
};
// путь для защиты
app.post("/login", bouncer.block, function(req, res) {
    if (LoginFailed){  }
    else {
        bouncer.reset( req );
    }
});
```

```JavaScript
const ExpressBrute = require('express-brute');

const store = new ExpressBrute.MemoryStore(); // хранит данные локально, не используйте это в производстве
const bruteforce = new ExpressBrute(store);

app.post('/auth',
    bruteforce.prevent, // ошибка 429, если мы слишком часто выбираем этот маршрут
    function (req, res, next) {
        res.send('Success!');
    }
);
```

Помимо [express-bouncer](https://libraries.io/npm/express-bouncer) и [express-brute] (https://libraries.io/npm/express-brute), модуль [rate-limiter](https://libraries.io/npm/rate-limiter) также может помочь предотвратить атаки методом перебора. Он позволяет указать, сколько запросов может быть отправлено с определенного IP-адреса за указанный период времени.

```JavaScript
const limiter = new RateLimiter();
limiter.addLimit('/login', 'GET', 5, 500); // страница входа в систему может быть запрошена максимум 5 раз в течение 500 секунд
```

[Использование капчи (CAPTCHA)](https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html#captcha) также является еще одним распространенным механизмом, используемым против брутфорса. Существуют модули, разработанные для Node.js Капчи. В приложениях Node.js часто используется модуль [svgcaptcha](https://www.npmjs.com/package/svgcaptcha). Его можно использовать следующим образом:

```JavaScript
const svgCaptcha = require('svg-captcha');
app.get('/captcha', function (req, res) {
    const captcha = svgCaptcha.create();
    req.session.captcha = captcha.text;
    res.type('svg');
    res.status(200).send(captcha.data);
});
```

[Учетная запись lockout](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#account-lockout) - рекомендуемое решение для предотвращения доступа злоумышленников к вашим действительным пользователям. Блокировка учетной записи возможна с помощью многих модулей, таких как [mongoose](https://www.npmjs.com/package/mongoose). Вы можете ознакомиться с [этим сообщением в блоге](http://devsmash.com/blog/implementing-max-login-attempts-with-mongoose), чтобы узнать, как в mongoose реализована блокировка учетной записи.

#### Используйте токены защиты от CSRF

[Подделка межсайтовых запросов (CSRF)](https://owasp.org/www-community/attacks/csrf) направлена на выполнение авторизованных действий от имени пользователя, прошедшего проверку подлинности, в то время как пользователь не знает об этом действии. Атаки CSRF обычно выполняются для запросов, связанных с изменением состояния, таких как смена пароля, добавление пользователей или размещение заказов. [Csurf](https://www.npmjs.com/package/csurf) - это промежуточное программное обеспечение express, которое использовалось для предотвращения атак CSRF. Но недавно была обнаружена брешь в системе безопасности этого пакета. Команда разработчиков пакета не исправила обнаруженную уязвимость и пометила пакет как устаревший, рекомендовав использовать любой другой пакет защиты CSRF.

Подробную информацию об атаках, связанных с подделкой межсайтовых запросов (CSRF), и методах их предотвращения вы можете найти в разделе [Подделка межсайтовых запросов Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html).

#### Удалите ненужные маршруты

Веб-приложение не должно содержать каких-либо страницы, которые не используются пользователями, так как это может увеличить уязвимость приложения. Таким образом, все неиспользованные маршруты API должен быть отключен в Node.js приложения. Это особенно часто происходит в таких фреймворках, как [Sails](https://sailsjs.com) и [Feathers](https://feathersjs.com), поскольку они автоматически генерируют конечные точки REST API. Например, в [Sails](https://sailsjs.com), если URL-адрес не соответствует пользовательскому маршруту, он может соответствовать одному из автоматических маршрутов и все равно генерировать ответ. Такая ситуация может привести к различным последствиям - от утечки информации до выполнения произвольных команд. Поэтому перед использованием таких фреймворков и модулей важно знать маршруты, которые они автоматически генерируют, и удалять или отключать эти маршруты.

#### Предотвращение загрязнения параметров HTTP

[HTTP-параметр Pollution(HPP)](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution.html) - это атака, при которой злоумышленники отправляют несколько HTTP-параметров с одинаковыми именами, что приводит к непредсказуемой интерпретации их вашим приложением. При отправке нескольких значений параметров Express заполняет их массивом. Чтобы решить эту проблему, вы можете использовать модуль [hpp](https://www.npmjs.com/package/hpp). При использовании этот модуль будет игнорировать все значения, представленные для параметра в `req.запросите` и/или `req.body` и просто выберите последнее отправленное значение параметра. Вы можете использовать его следующим образом:

```JavaScript
const hpp = require('hpp');
app.use(hpp());
```

#### Возвращайте только то, что необходимо

Информация о пользователях приложения является одной из наиболее важных сведений о приложении. Таблицы пользователей обычно содержат такие поля, как идентификатор, имя пользователя, полное имя, адрес электронной почты, дата рождения, пароль и, в некоторых случаях, номера социального страхования. Поэтому при запросе и использовании пользовательских объектов вам необходимо возвращать только необходимые поля, поскольку это может привести к раскрытию личной информации. Это также верно для других объектов, хранящихся в базе данных. Если вам нужно только определенное поле объекта, вы должны возвращать только те поля, которые требуются. В качестве примера, вы можете использовать функцию, подобную приведенной ниже, всякий раз, когда вам нужно получить информацию о пользователе. Поступая таким образом, вы можете возвращать только те поля, которые необходимы для вашей конкретной операции. Другими словами, если вам нужно только перечислить имена доступных пользователей, вы не возвращаете их адреса электронной почты или номера кредитных карт в дополнение к их полным именам.

```JavaScript
exports.sanitizeUser = function(user) {
  return {
    id: user.id,
    username: user.username,
    fullName: user.fullName
  };
};
```

#### Используйте дескрипторы свойств объекта

Свойства объекта включают в себя три скрытых атрибута: `writable` (если значение false, значение свойства нельзя изменить), `(enumerable)` (если значение false, свойство нельзя использовать в циклах for) и `configurable` (если значение false, свойство нельзя удалить). При определении свойства объекта посредством присваивания этим трем скрытым атрибутам по умолчанию присваивается значение true. Эти свойства можно задать следующим образом:

```JavaScript
const o = {};
Object.defineProperty(o, "a", {
    writable: true,
    enumerable: true,
    configurable: true,
    value: "A"
});
```

Помимо этого, существуют некоторые специальные функции для атрибутов объекта. `Object.preventExtensions()` предотвращает добавление новых свойств к объекту.

#### Используйте списки контроля доступа

Авторизация не позволяет пользователям действовать за пределами предоставленных им разрешений. Для этого пользователи и их роли должны определяться с учетом принципа наименьших привилегий. Каждая роль пользователя должна иметь доступ только к тем ресурсам, которые они должны использовать. Для ваших приложений Node.js вы можете использовать модуль [acl](https://www.npmjs.com/package/acl), чтобы обеспечить реализацию ACL (списка контроля доступа). С помощью этого модуля вы можете создавать роли и назначать пользователей на эти роли.

### Обработка ошибок и исключений

#### Обрабатывайте uncaughtException

Node.js поведение при неперехваченных исключениях заключается в выводе текущей трассировки стека и последующем завершении потока. Однако Node.js позволяет настраивать это поведение. Он предоставляет глобальный объект с именем process, доступный для всех Node.js приложений. Это объект EventEmitter, и в случае неперехваченного исключения генерируется событие uncaughtException, которое передается в основной цикл обработки событий. Чтобы обеспечить пользовательское поведение для неперехваченных исключений, вы можете привязаться к этому событию. Однако возобновление работы приложения после такого неперехваченного исключения может привести к дальнейшим проблемам. Поэтому, если вы не хотите пропустить ни одного неперехваченного исключения, вам следует привязаться к событию uncaughtException и очистить все выделенные ресурсы, такие как файловые дескрипторы, дескрипторы дескрипторов и т.п., прежде чем завершать процесс. Настоятельно не рекомендуется возобновлять работу приложения, так как оно будет находиться в неизвестном состоянии. Важно отметить, что при отображении сообщений об ошибках пользователю в случае неперехваченного исключения не следует раскрывать подробную информацию, такую как трассировка стека. Вместо этого пользователям следует показывать пользовательские сообщения об ошибках, чтобы не вызвать утечки информации.

```JavaScript
process.on("uncaughtException", function(err) {
    // очистете выделенные ресурсы
    // запишите необходимые сведения об ошибках в файлы журнала
    process.exit(); // завершите процесс, чтобы избежать неизвестного состояния
});
```

#### Прослушивание ошибок при использовании EventEmitter

При использовании EventEmitter ошибки могут возникать в любом месте цепочки событий. Обычно, если ошибка возникает в объекте EventEmitter, вызывается событие error, в качестве аргумента которого используется объект Error. Однако, если к этому событию error не подключены прослушиватели, объект Error, отправленный в качестве аргумента, генерируется и становится неперехваченным исключением. Короче говоря, если вы не обработаете ошибки в объекте EventEmitter должным образом, эти необработанные ошибки могут привести к сбою вашего приложения. Поэтому вы всегда должны прослушивать сообщения об ошибках при использовании объектов EventEmitter.

```JavaScript
const events = require('events');
const myEventEmitter = function(){
    events.EventEmitter.call(this);
}
require('util').inherits(myEventEmitter, events.EventEmitter);
myEventEmitter.prototype.someFunction = function(param1, param2) {
    //в случае возникновения ошибки
    this.emit('error', err);
}
const emitter = new myEventEmitter();
emitter.on('error', function(err){
    //Выполните необходимую обработку ошибок здесь
});
```

#### Обрабатывать ошибки при асинхронных вызовах

Ошибки, возникающие при асинхронных обратных вызовах, легко пропустить. Поэтому, как правило, первым аргументом для асинхронных вызовов должен быть объект Error. Кроме того, экспресс-маршруты сами обрабатывают ошибки, но всегда следует помнить, что ошибки, возникающие при асинхронных вызовах, выполняемых в рамках экспресс-маршрутов, не обрабатываются, если только объект Error не отправляется в качестве первого аргумента.

Ошибки в этих обратных вызовах могут повторяться столько раз, сколько возможно. Каждый обратный вызов, на который была передана ошибка, может игнорировать, обрабатывать или распространять ошибку.

### Безопасность сервера

#### Установите соответствующие флаги для файлов cookie

Как правило, информация о сеансе передается с помощью файлов cookie в веб-приложениях. Однако неправильное использование HTTP-файлов cookie может привести к тому, что приложение будет подвержено нескольким уязвимостям управления сеансами. Для каждого файла cookie можно установить некоторые флаги, чтобы предотвратить подобные атаки. Флаги `HttpOnly`, `Secure` и `SameSite` очень важны для сессионных файлов cookie. Флаг `HttpOnly` предотвращает доступ к файлам cookie с помощью клиентского JavaScript. Это эффективная мера противодействия XSS-атакам. Флаг `Secure` позволяет отправлять файл cookie только в том случае, если связь осуществляется по протоколу HTTPS. Флаг `SameSite` может препятствовать отправке файлов cookie при межсайтовых запросах, что помогает защитить от атак на подделку межсайтовых запросов (CSRF). Помимо этого, существуют другие флаги, такие как domain, path и expires. Рекомендуется устанавливать эти флаги соответствующим образом, но они в основном связаны с областью действия файлов cookie, а не с безопасностью файлов cookie. Пример использования этих флагов приведен в следующем примере:

```JavaScript
const session = require('express-session');
app.use(session({
    secret: 'your-secret-key',
    name: 'cookieName',
    cookie: { secure: true, httpOnly: true, path: '/user', sameSite: true}
}));
```

#### Используйте соответствующие заголовки безопасности

Существует несколько [заголовков безопасности HTTP](https://owasp.org/www-project-secure-headers/), которые могут помочь вам предотвратить некоторые распространенные атаки.
Пакет [helmet](https://www.npmjs.com/package/helmet) может помочь настроить эти заголовки:

```Javascript
const express = require("express");
const helmet = require("helmet");

const app = express();

app.use(helmet()); // Добавление различных HTTP-заголовков
```

Функция `helmet` верхнего уровня является оболочкой для 14 более мелких промежуточных программ.
Ниже приведен список заголовков безопасности HTTP, которые используются в промежуточных программах `helmet`:

- **[Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security)**: [HTTP Strict Transport Security (HSTS)](https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html) указывает браузерам, что доступ к приложению возможен только через HTTPS-соединения. Чтобы использовать его в вашем приложении, добавьте следующие коды:

```JavaScript
app.use(helmet.hsts()); // конфигурация по умолчанию
app.use(
  helmet.hsts({
    maxAge: 123456,
    includeSubDomains: false,
  })
); // пользовательская конфигурация
```

- **[X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options):** определяет, может ли страница быть загружена с помощью элемента `<frame>` или `<iframe>`. Включение страницы в рамку может привести к [перехвату кликов](https://owasp.org/www-community/attacks/Clickjacking) атакам.

```JavaScript
app.use(helmet.frameguard()); // поведение по умолчанию (SAMEORIGIN)
```

- **[X-XSS-защита](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection):** останавливает загрузку страниц при обнаружении отраженных атак с использованием межсайтовых сценариев (XSS). Этот заголовок устарел в современных браузерах, и его использование может привести к дополнительным проблемам безопасности на стороне клиента. Таким образом, рекомендуется установить заголовок как **X-XSS-Protection: 0**, чтобы отключить XSS-аудитор и не позволять ему использовать поведение браузера, обрабатывающего ответ, по умолчанию.

```JavaScript
app.use(helmet.xssFilter()); // устанавливает "X-XSS-Protection: 0"
```

Для современных браузеров рекомендуется применять строгую политику **Content-Security-Policy** , как описано в следующем разделе.

- **[Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)**: Content-Security-Policy разработана для снижения риска таких атак, как [Межсайтовый скриптинг (XSS)](https://owasp.org/www-community/attacks/xss/) и [Перехват кликов](https://owasp.org/www-community/attacks/Clickjacking). Он позволяет загружать контент из списка, который вы выберете сами. В нем есть несколько директив, каждая из которых запрещает загрузку определенного типа контента. Вы можете ознакомиться с [Шпаргалкой по политике безопасности контента](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html) для получения подробного описания каждой директивы и способов ее использования. Вы можете реализовать эти настройки в своем приложении следующим образом:

```JavaScript
app.use(
  helmet.contentSecurityPolicy({
    // следующие директивы будут объединены в политику CSP шлема по умолчанию
    directives: {
      defaultSrc: ["'self'"],  // значение по умолчанию для всех директив, которые отсутствуют
      scriptSrc: ["'self'"],   // помогает предотвратить XSS-атаки
      frameAncestors: ["'none'"],  // помогает предотвратить атаки с перехватом кликов
      imgSrc: ["'self'", "'http://imgexample.com'"],
      styleSrc: ["'none'"]
    }
  })
);
```

Поскольку это промежуточное программное обеспечение выполняет очень мало проверок, рекомендуется вместо этого полагаться на средства проверки CSP, такие как [CSPEvaluator](https://csp-evaluator.withgoogle.com/).

- **[X-Content-Type-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options):** Даже если сервер задает в ответе допустимый заголовок `Content-Type`, браузеры могут попытаться определить MIME-тип запрашиваемого ресурса. Этот заголовок позволяет остановить такое поведение и запретить браузеру изменять типы MIME, указанные в заголовке `Content-Type`. Его можно настроить следующим образом:

```JavaScript
app.use(helmet.noSniff());
```

- **[Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) и [Pragma](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma):** Заголовок Cache-Control может использоваться для предотвращения кэширования браузерами данных ответов. Это следует делать для страниц, содержащих конфиденциальную информацию о пользователе или приложении. Однако отключение кэширования для страниц, не содержащих конфиденциальной информации, может серьезно повлиять на производительность приложения. Поэтому кэширование следует отключать только для страниц, которые возвращают конфиденциальную информацию. Соответствующие элементы управления кэшированием и заголовки можно легко настроить с помощью пакета [nocache](https://www.npmjs.com/package/no кэширование).:

```JavaScript
const nocache = require("nocache");

app.use(nocache());
```

Приведенный выше код устанавливает заголовки Cache-Control, Surrogate-Control, Pragma и Expires соответственно.

- **X-Download-Options:**  Этот заголовок запрещает Internet Explorer запускать загруженные файлы в контексте сайта. Это достигается без использования opendirective. Вы можете сделать это с помощью следующего фрагмента кода:

```JavaScript
app.use(helmet.ieNoOpen());
```

- **[Expect-CT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT):** Прозрачность сертификатов - это новый механизм, разработанный для устранения некоторых структурных проблем, связанных с текущей инфраструктурой SSL. Заголовок Expect-CT может усиливать требования к прозрачности сертификатов. Это может быть реализовано в вашем приложении следующим образом:

```JavaScript
const expectCt = require('expect-ct');
app.use(expectCt({ maxAge: 123 }));
app.use(expectCt({ enforce: true, maxAge: 123 }));
app.use(expectCt({ enforce: true, maxAge: 123, reportUri: 'http://example.com'}));
```

- **X-Powered-By:** Заголовок X-Powered-By используется для информирования о том, какая технология используется на стороне сервера. Это ненужный заголовок, вызывающий утечку информации, поэтому его следует удалить из вашего приложения. Для этого вы можете использовать функцию `hide Powered By` следующим образом:

```JavaScript
app.use(helmet.hidePoweredBy());
```

Кроме того, вы можете солгать о технологиях, используемых в этом заголовке. Например, даже если ваше приложение не использует PHP, вы можете настроить заголовок X-Powered-By таким образом, чтобы он выглядел именно так.

```JavaScript
app.use(helmet.hidePoweredBy({ setTo: 'PHP 4.2.0' }));
```

### Безопасность платформы

#### Поддерживайте актуальность ваших пакетов

Безопасность вашего приложения напрямую зависит от того, насколько безопасны пакеты сторонних производителей, которые вы используете в своем приложении. Поэтому важно постоянно обновлять свои пакеты. Следует отметить, что [Using Components with Known Vulnerabilities](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A9-Using_Components_with_Known_Vulnerabilities) по-прежнему входит в топ-10 OWASP. Вы можете использовать [Проверка зависимостей OWASP](https://jeremylong.github.io/DependencyCheck/analyzers/nodejs.html), чтобы узнать, есть ли в каком-либо из пакетов, используемых в проекте, известная уязвимость. Кроме того, вы можете использовать [Retire.js](https://github.com/retirejs/retire.js/) для проверки библиотек JavaScript на наличие известных уязвимостей.

Начиная с версии 6, `npm` ввел `audit`, который будет предупреждать об уязвимых пакетах:

```bash
npm audit
```

`npm` также представил простой способ обновления уязвимых пакетов:

```bash
npm audit fix
```

Существует несколько других инструментов, которые вы можете использовать для проверки своих зависимостей. Более полный список можно найти в [Управление уязвимыми зависимостями CS](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerable_Dependency_Management_Cheat_Sheet.html#tools).

#### Не используйте опасные функции

Существуют некоторые функции JavaScript, которые опасны и должны использоваться только там, где это необходимо или неизбежно. Первым примером является функция `eval()`. Эта функция принимает строковый аргумент и выполняет его как любой другой исходный код JavaScript. В сочетании с пользовательским вводом такое поведение, по сути, приводит к уязвимости удаленного выполнения кода. Аналогичным образом, вызовы `child_process.exec` также очень опасны. Эта функция действует как интерпретатор bash и отправляет свои аргументы в /bin/sh. Вводя данные в эту функцию, злоумышленники могут выполнять произвольные команды на сервере.

В дополнение к этим функциям, некоторые модули требуют особой осторожности при использовании. Например, модуль `fs` обрабатывает операции с файловой системой. Однако, если в этот модуль будет передан неправильно обработанный пользовательский ввод, ваше приложение может стать уязвимым для уязвимостей, связанных с включением файлов и обходом каталогов. Аналогичным образом, модуль `vm` предоставляет API для компиляции и запуска кода в контекстах виртуальной машины версии 8. Поскольку он по своей природе может совершать опасные действия, его следует использовать в изолированной среде.

Было бы несправедливо утверждать, что эти функции и модули вообще не следует использовать, однако их следует использовать осторожно, особенно когда они используются с пользовательским вводом. Кроме того, существуют [некоторые другие функции](https://github.com/wise/domxsswiki/wiki/Direct-Execution-Sinks), которые могут сделать ваше приложение уязвимым.

#### Держитесь подальше от опасных регулярных выражений

Отказ в обслуживании с помощью регулярных выражений (ReDoS) - это атака типа "Отказ в обслуживании", которая использует тот факт, что большинство реализаций регулярных выражений могут достигать экстремальных ситуаций, из-за которых они работают очень медленно (экспоненциально зависит от размера входных данных). Затем злоумышленник может заставить программу, использующую регулярное выражение, войти в эти экстремальные ситуации, а затем зависнуть на очень долгое время.

[Отказ в обслуживании с помощью регулярных выражений (ReDoS)](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS) - это тип атаки типа "Отказ в обслуживании", в которой используются регулярные выражения. Некоторые реализации регулярных выражений (Regex) приводят к экстремальным ситуациям, из-за которых приложение работает очень медленно. Злоумышленники могут использовать такие реализации регулярных выражений, чтобы заставить приложение попадать в экстремальные ситуации и зависать на долгое время.  Такие регулярные выражения называются вредоносными, если приложение может зависать на обработанных входных данных.  Как правило, эти регулярные выражения используются путем группировки с повторением и чередования с перекрытием. Например, для указания имен классов Java можно использовать следующее регулярное выражение `^(([a-z])+.)+[A-Z]([a-z])+$`. Однако этому регулярному выражению также может соответствовать очень длинная строка (aaaa...aaaaAaaaaa...aaaa). Существуют некоторые инструменты для проверки того, может ли регулярное выражение привести к отказу в обслуживании. Одним из примеров является [vuln-regex-detector](https://github.com/davisjam/vuln-regex-detector).

#### Запуск линтеров безопасности

При разработке кода может быть очень сложно учесть все рекомендации по безопасности. Кроме того, практически невозможно заставить всех членов команды соблюдать эти правила. Вот почему существуют инструменты для тестирования безопасности с помощью статического анализа (SAST). Эти инструменты не выполняют ваш код, а просто ищут шаблоны, которые могут содержать угрозы безопасности. Поскольку JavaScript является динамичным языком со свободной типизацией, инструменты linting действительно необходимы в жизненном цикле разработки программного обеспечения. Правила составления списка должны периодически пересматриваться, а результаты - проверяться. Еще одним преимуществом этих инструментов является то, что вы можете добавлять пользовательские правила для шаблонов, которые могут показаться вам опасными. [ESLint](http://eslint.org/) и [JSHint](http://jshint.com/) - это широко используемые инструменты SAST для редактирования JavaScript.

#### Используйте строгий режим

В JavaScript есть ряд небезопасных и опасных устаревших функций, которые не следует использовать. Чтобы удалить эти функции, в ES5 был включен строгий режим для разработчиков. В этом режиме отображаются ошибки, о которых ранее не сообщалось. Это также помогает движкам JavaScript выполнять оптимизацию. При использовании строгого режима ранее принятый неправильный синтаксис приводит к серьезным ошибкам. Благодаря этим улучшениям вы всегда должны использовать строгий режим в своем приложении. Чтобы включить строгий режим, вам просто нужно написать `"use strict";` поверх вашего кода.

Следующий код сгенерирует сообщение `ReferenceError: Не удается найти переменную: y` на консоли, которое не будет отображаться, если не используется строгий режим:

```JavaScript
"use strict";

func();
function func() {
  y = 3.14;   // Это приведет к ошибке (y не определен)
}
```

#### Придерживайтесь общих принципов безопасности приложений

Этот список в основном посвящен проблемам, которые часто встречаются в приложениях Node.js, с рекомендациями и примерами. В дополнение к этому, существуют общие [принципы обеспечения безопасности при проектировании](https://wiki.owasp.org/index.php/Security_by_Design_Principles), которые применяются к веб-приложениям независимо от технологий, используемых в сервере приложений. Вы также должны учитывать эти принципы при разработке своих приложений. Вы всегда можете обратиться к [Серии шпаргалок по OWASP](https://cheatsheetseries.owasp.org/), чтобы узнать больше об уязвимостях веб-приложений и методах их устранения.

## Дополнительные ресурсы о безопасности Node.js 

[Awesome Node.js Security resources](https://github.com/lirantal/awesome-nodejs-security)
