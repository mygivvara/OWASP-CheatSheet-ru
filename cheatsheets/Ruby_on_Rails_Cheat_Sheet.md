# Шпаргалка для Ruby on Rails

## Введение

Эта *Читшита* предназначена для краткого ознакомления разработчиков с основными советами по безопасности Ruby on Rails. Она дополняет или подчеркивает пункты, приведенные в [Руководстве по безопасности Rails](https://guides.rubyonrails.org/security.html) от rails core.

Платформа Rails освобождает разработчиков от довольно утомительной работы и предоставляет средства для быстрого и простого выполнения сложных задач. Начинающим разработчикам, тем, кто не знаком с внутренним устройством Rails, вероятно, потребуется базовый набор рекомендаций для обеспечения фундаментальных аспектов их приложения. Предполагаемая цель этого документа - стать таким руководством.

## Предметы

### Ввод команды

Ruby предлагает функцию под названием "eval", которая будет динамически создавать новый код Ruby на основе строк. В ней также есть несколько способов вызова системных команд.

``` ruby
eval("ruby code here")
system("os command here")
`ls -al /` # (backticks contain os command)
exec("os command here")
spawn("os command here")
open("| os command here")
Process.exec("os command here")
Process.spawn("os command here")
IO.binread("| os command here")
IO.binwrite("| os command here", "foo")
IO.foreach("| os command here") {}
IO.popen("os command here")
IO.read("| os command here")
IO.readlines("| os command here")
IO.write("| os command here", "foo")
```

Несмотря на то, что возможности этих команд весьма полезны, при их использовании в приложении на базе Rails следует соблюдать крайнюю осторожность. Обычно это просто плохая идея. При необходимости следует использовать список разрешенных значений, а все вводимые данные следует проверять как можно тщательнее.

Руководства из [Rails](https://guides.rubyonrails.org/security.html#command-line-injection) и [OWASP](https://owasp.org/www-community/attacks/Command_Injection) содержат дополнительную информацию о внедрении команд.

### SQL-инъекции

Ruby on Rails часто используется с ORM под названием ActiveRecord, хотя он является гибким и может использоваться с другими источниками данных. Как правило, очень простые приложения Rails используют методы моделей Rails для запроса данных. Во многих случаях защита для SQL-инъекций выполняется "из коробки". Однако можно написать код, который допускает внедрение SQL-кода.

``` ruby
name = params[:name]
@projects = Project.where("name like '" + name + "'");
```

Оператор является вводимым, поскольку параметр name не экранируется.

Вот идиома для создания такого рода операторов:

``` ruby
@projects = Project.where("name like ?", "%#{ActiveRecord::Base.sanitize_sql_like(params[:name])}%")
```

Будьте осторожны, не создавайте инструкции SQL на основе пользовательского ввода. Список более реалистичных и подробных примеров приведен здесь: [rails-sqli.org](https://rails-sqli.org). В OWASP есть обширная информация о [SQL-инъекции](https://owasp.org/www-community/attacks/SQL_Injection).

### Межсайтовый скриптинг (XSS)

По умолчанию используется защита от XSS. Когда строковые данные отображаются в представлениях, они экранируются перед отправкой обратно в браузер. Это требует много времени, но часто разработчики обходят эту защиту - например, чтобы включить редактирование расширенного текста. В том случае, если вы хотите передать переменные во внешний интерфейс с сохраненными тегами, есть соблазн сделать следующее в вашем erb-файле (разметка ruby).

``` ruby
# Неправильно! Не делайте так!
<%= raw @product.name %>

# Неправильно! Не делайте так!
<%== @product.name %>

# Неправильно! Не делайте так!
<%= @product.name.html_safe %>

# Неправильно! Не делайте так!
<%= content_tag @product.name %>
```

К сожалению, любое поле, в котором используются `raw`, `html_safe`, `content_tag` или что-то подобное, будет потенциальной целью XSS. Обратите внимание, что также широко распространены неправильные представления о `html_safe()`.

[В этой статье](https://stackoverflow.com/questions/4251284/raw-vs-html-safe-vsh-to-unescape-html) подробно описывается механизм, лежащий в основе SafeBuffer. Другие теги, которые изменяют способ подготовки строк к выводу, включая content_tag, могут создавать аналогичные проблемы.

``` ruby
content_tag("/><script>alert('hack!');</script>") # Пример XSS
# produces: </><script>alert('hack!');</script>><//><script>alert('hack!');</script>>
```

Название метода `html_safe` в String несколько сбивает с толку. Это означает, что мы точно знаем, что содержимое string безопасно для включения в HTML без экранирования. **Этот метод сам по себе небезопасен!**

Если вам необходимо принимать HTML-контент от пользователей, рассмотрите язык разметки для форматированного текста в приложении (например, Markdown и textile) и запретите HTML-теги. Это помогает гарантировать, что принимаемые входные данные не содержат HTML-контента, который может быть вредоносным.

Если вы не можете запретить своим пользователям вводить HTML, подумайте о внедрении политики безопасности содержимого, запрещающей выполнение любого JavaScript. И, наконец, рассмотрите возможность использования метода `#sanitize`, который позволяет выводить список разрешенных тегов. Будьте осторожны, этот метод неоднократно доказывал свою несостоятельность и никогда не будет полным решением.

Часто упускаемый из виду вектор атаки XSS для старых версий rails - это значение `href` ссылки:

``` ruby
<%= link_to "Personal Website", @user.website %>
```

Если `@user.website` содержит ссылку, которая начинается с `javascript:`, содержимое будет запущено, когда пользователь нажмет на сгенерированную ссылку:

``` html
<a href="javascript:alert('Haxored')">Personal Website</a>
```

Более новые версии Rails лучше обходят такие ссылки стороной.

``` ruby
link_to "Personal Website", 'javascript:alert(1);'.html_safe()
# Будет генерировать:
# "<a href="javascript:alert(1);">Personal Website</a>"
```

Использование [Политики безопасности содержимого](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) - это еще одна мера безопасности, позволяющая запретить выполнение ссылок, начинающихся с `javascript:`.

[Сканер Brakeman](https://github.com/presidentbeef/brakeman) помогает находить проблемы с XSS в приложениях Rails.

OWASP предоставляет более общую информацию о XSS на странице верхнего уровня: [Межсайтовый скриптинг (XSS)](https://owasp.org/www-community/attacks/xss/).

### Сессии

По умолчанию Ruby on Rails использует хранилище сеансов на основе файлов cookie. Это означает, что если вы что-то не измените, срок действия сеанса на сервере не истечет. Это означает, что некоторые приложения по умолчанию могут быть уязвимы для повторных атак. Это также означает, что конфиденциальная информация никогда не должна содержаться в сеансе.

Лучше всего использовать сеанс на основе базы данных, который, к счастью, очень прост в Rails:

``` ruby
Project::Application.config.session_store :active_record_store
```

Существует [Шпаргалка по управлению сеансами](Session_Management_Cheat_Sheet.md).

### Идентификация

Как и в случае со всеми конфиденциальными данными, начните защищать свою аутентификацию, включив TLS в своей конфигурации:

``` ruby
# config/environments/production.rb
# Принудительный доступ к приложению по протоколу SSL, используйте строгую транспортную безопасность,
# и используйте защищенные файлы cookie
config.force_ssl = true
```

Раскомментируйте строку 3, как указано выше, в вашей конфигурации.

Вообще говоря, Rails сам по себе не обеспечивает аутентификацию. Однако большинство разработчиков, использующих Rails, используют библиотеки, такие как Devise или AuthLogic, для обеспечения аутентификации.

Чтобы включить аутентификацию, можно использовать Devise gem.

Установите его с помощью:

```bash
gem 'devise'
```

Затем установите его в пользовательскую модель:

```bash
rails generate devise:install
```

Затем укажите, к каким ресурсам (маршрутам) требуется аутентифицированный доступ в routes:

``` ruby
Rails.application.routes.draw do
  authenticate :user do
    resources :something do  # эти ресурсы требуют проверки подлинности
      ...
    end
  end

  devise_for :users # sign-up/-in/out routes

  root to: 'static#home' # аутентификация не требуется
end
```

Чтобы упростить ввод пароля, можно использовать [zxcvbn gem](https://github.com/bitzesty/device_zxcvbn). Настройте с его помощью свою пользовательскую модель:

``` ruby
class User < ApplicationRecord
  devise :database_authenticatable,
    # другие функции устройства, то
    :zxcvbnable
end
```

И настройте требуемую сложность пароля:

``` ruby
# в config/initializers/devise.rb
Devise.setup do |config|
  # оценка zxcvbn для устройства
  config.min_password_score = 4 # оценка сложности здесь.
  ...
```

Вы можете попробовать [этот PoC](https://github.com/qutorial/revise), чтобы узнать о нем больше.

Далее, [omniauth gem](https://github.com/omniauth/omniauth) позволяет использовать несколько стратегий аутентификации. С его помощью можно настроить безопасную аутентификацию с Facebook, LDAP и многими другими провайдерами. Читайте далее [здесь](https://github.com/omniauth/omniauth#integrating-omniauth-into-your-application).

#### Аутентификация по токену

Устройство обычно использует файлы cookie для аутентификации.

В случае, если вместо этого требуется аутентификация с помощью токена, ее можно реализовать с помощью gem [devise_token_auth](https://github.com/lynndylanhurley/devise_token_auth).

Он поддерживает несколько интерфейсных технологий, например angular2-token.

Этот gem настроен аналогично самому devise gem. Это также требует omniauth в качестве зависимости.

```bash
# аутентификация на основе токенов
gem 'devise_token_auth'
gem 'omniauth'
```

Затем определяется маршрут:

```ruby
mount_devise_token_auth_for 'User', at: 'auth'
```

И пользовательская модель изменяется соответствующим образом.

Эти действия можно выполнить с помощью одной команды:

```bash
rails g devise_token_auth:install [USER_CLASS] [MOUNT_PATH]
```

Возможно, вам потребуется отредактировать сгенерированную миграцию, чтобы избежать ненужных полей и/или дублирования полей в зависимости от вашего варианта использования.

Примечание: если вы используете только аутентификацию по токену, необходимость в защите [CSRF](https://owasp.org/www-community/attacks/csrf) в контроллерах отпадает. Если вы используете оба способа: файлы cookie и токены, пути, по которым файлы cookie используются для аутентификации, все равно должны быть защищены от подделки!

Существует [Шпаргалка по аутентификации](Authentication_Cheat_Sheet.md).

### Небезопасная прямая ссылка на объект или принудительный просмотр

По умолчанию приложения Ruby on Rails используют структуру URI RESTful. Это означает, что пути часто интуитивно понятны и доступны для угадывания. Для защиты от попыток пользователя получить доступ к данным, принадлежащим другому пользователю, или изменить их, важно специально контролировать действия. В приложении vanilla Rails такой встроенной защиты нет. Это можно сделать вручную на уровне контроллера.

Для этого также возможно и, вероятно, рекомендуется использовать библиотеки управления доступом на основе ресурсов, такие как [cancancan](https://github.com/CanCanCommunity/cancancan) (замена cancan) или [pundit](https://github.com/elabs/pundit). Это гарантирует, что все операции с объектом базы данных авторизованы бизнес-логикой приложения.

Более общая информация об этом классе уязвимостей приведена на странице [Топ-10 OWASP](https://wiki.owasp.org/index.php/Top_10_2010-A4-Insecure_Direct_Object_References).

### CSRF (Cross Site Request Forgery) (Подделка межсайтового запроса)

В Ruby on Rails есть специальная встроенная поддержка токенов CSRF. Чтобы включить ее или убедиться, что она включена, найдите базовый 'ApplicationController' и найдите директиву, подобную следующей:

``` ruby
class ApplicationController < ActionController::Base
  protect_from_forgery
```

Обратите внимание, что синтаксис для этого типа элемента управления включает в себя возможность добавления исключений. Исключения могут быть полезны для API или по другим причинам, но их следует пересмотреть и сознательно включить. В приведенном ниже примере контроллер проекта Rails не будет обеспечивать защиту [CSRF](https://owasp.org/www-community/attacks/csrf) для метода show.

``` ruby
class ProjectController < ApplicationController
  protect_from_forgery except: :show
```

Также обратите внимание, что по умолчанию Rails не предоставляет защиту CSRF для любого HTTP-запроса `GET`.

**Примечание:** если вы используете только аутентификацию по токенам, нет необходимости в защите от CSRF в контроллерах, подобных этому. Если для некоторых путей используется аутентификация на основе файлов cookie, то для них все равно требуется защита.

Существует страница верхнего уровня OWASP для [Подделки межсайтовых запросов (CSRF)](https://owasp.org/www-community/attacks/csrf).

### Перенаправления и переадресовывания

Веб-приложениям часто требуется возможность динамического перенаправления пользователей на основе предоставленных клиентом данных. Для уточнения, динамическое перенаправление обычно подразумевает включение клиентом URL-адреса в параметр запроса к приложению. После получения запроса приложением пользователь перенаправляется на URL-адрес, указанный в запросе.

Например:

`http://www.example.com/redirect?url=http://www.example_commerce_site.com/checkout`

Приведенный выше запрос перенаправит пользователя на страницу `http://www.example.com/checkout`. Проблема безопасности, связанная с этой функциональностью, заключается в использовании надежного бренда организации для обмана пользователей и заманивания их на вредоносный сайт, в нашем примере `badhacker.com`.

Пример:

`http://www.example.com/redirect?url=http://badhacker.com`

Самая простая, но ограничительная защита заключается в использовании параметра `:only_path`. Установка значения true для этого параметра, по сути, приведет к удалению любой информации о хосте. Однако параметр `:only_path` должен быть частью первого аргумента. Если первый аргумент не является хэш-таблицей, то этот параметр невозможно передать. В отсутствие пользовательского помощника или списка разрешений это один из подходов, который может сработать:

``` ruby
begin
  if path = URI.parse(params[:url]).path
    redirect_to path
  end
rescue URI::InvalidURIError
  redirect_to '/'
end
```

Если необходимо сопоставить вводимые пользователем данные со списком одобренных сайтов или доменов верхнего уровня с регулярными выражениями, имеет смысл использовать библиотеку, такую как `URI.parse()`, для получения хоста, а затем взять значение хоста и сопоставить его с шаблонами регулярных выражений. Эти регулярные выражения должны, как минимум, иметь привязки, иначе существует большая вероятность того, что злоумышленник обойдет процедуру проверки.

Пример:

``` ruby
require 'uri'
host = URI.parse("#{params[:url]}").host
# это может быть уязвимо для javascript://trusted.com/%0Aalert(0)
# так что проверьте .scheme и .port тоже
validation_routine(host) if host
def validation_routine(host)
  # Процедура проверки, в которой мы используем \A и \z в качестве привязок *not* ^ и $
  # вы также можете проверить значение хоста по списку разрешений
end
```

Также слепое перенаправление на пользовательский параметр ввода может привести к XSS.

Пример кода:

``` ruby
redirect_to params[:to]
```

Выдаст этот URL-адрес:

`http://example.com/redirect?to[status]=200&to[protocol]=javascript:alert(0)//`

Очевидным способом устранения уязвимости такого типа является ограничение доступа к определенным доменам верхнего уровня (TLD), статическое определение конкретных сайтов или привязка ключа к его значению.

Пример кода:

``` ruby
ACCEPTABLE_URLS = {
  'our_app_1' => "https://www.example_commerce_site.com/checkout",
  'our_app_2' => "https://www.example_user_site.com/change_settings"
}
```

Выдаст этот URL-адрес:

`http://www.example.com/redirect?url=our_app_1`

Код обработки перенаправления:

``` ruby
def redirect
  url = ACCEPTABLE_URLS["#{params[:url]}"]
  redirect_to url if url
end
```

Код обработки перенаправления: Существует более общий ресурс OWASP, посвященный [неподтвержденным перенаправлениям и форвардам](Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md).

### Динамические пути рендеринга

В Rails действия контроллера и представления могут динамически определять, какой вид или его часть требуется отобразить, вызывая метод `render`. Если в имени шаблона или вместо него используется пользовательский ввод, злоумышленник может заставить приложение отобразить произвольный вид, например административную страницу.

Следует соблюдать осторожность при использовании пользовательского ввода для определения того, какой вид отображать. По возможности избегайте любого пользовательского ввода имени или пути к виду.

### Совместное использование ресурсов из разных источников

Иногда возникает необходимость в совместном использовании ресурсов с другим доменом. Например, функция загрузки файлов, которая отправляет данные с помощью AJAX-запроса в другой домен. В таких случаях необходимо использовать правила того же источника, которым следуют веб-браузеры. Современные браузеры, соответствующие стандартам HTML5, позволяют это делать, но для этого необходимо принять несколько мер предосторожности.

При использовании нестандартной конструкции HTTP, такой как, например, заголовок с нетипичным типом содержимого, применяется следующее:

Принимающий сайт должен указать только те домены, которым разрешено отправлять такие запросы, а также указать заголовок `Access-Control-Allow-Origin` как в ответе на запрос `OPTIONS`, так и в запросе `POST`. Это связано с тем, что сначала отправляется запрос OPTIONS, чтобы определить, разрешен ли удаленный сайт или принимающий сайт для запрашивающего домена. Затем отправляется второй запрос, запрос `POST`. И снова, чтобы транзакция была показана как успешная, необходимо задать заголовок.

При использовании стандартных HTTP-конструкций:

*Запрос отправляется, и браузер, получив ответ, проверяет заголовки ответа, чтобы определить, может ли и должен ли быть обработан ответ.*

Список разрешений в Rails:

**Gemfile:**

```bash
gem 'rack-cors', :require => 'rack/cors'
```

**config/application.rb:**

```ruby
module Sample
  class Application < Rails::Application
    config.middleware.use Rack::Cors do
      allow do
        origins 'someserver.example.com'
        resource %r{/users/\d+.json},
        :headers => ['Origin', 'Accept', 'Content-Type'],
        :methods => [:post, :get]
      end
    end
  end
end
```

### Заголовки, связанные с безопасностью

Чтобы задать значение заголовка, просто получите доступ к объекту response.headers в виде хэша внутри вашего контроллера (часто в before/after_filter).

```ruby
response.headers['X-header-name'] = 'value'
```

Rails предоставляет функциональность `default_headers`, которая автоматически применяет указанные значения. Это работает для большинства заголовков практически во всех случаях.

```ruby
ActionDispatch::Response.default_headers = {
  'X-Frame-Options' => 'SAMEORIGIN',
  'X-Content-Type-Options' => 'nosniff',
  'X-XSS-Protection' => '0'
}
```

[Строгая транспортная безопасность](https://owasp.org/www-project-secure-headers/#headers-link) - это особый случай, он устанавливается в файле среды (например, `production.rb`).

```ruby
config.force_ssl = true
```

Для тех, кто не в курсе, есть библиотека ([secure_headers](https://github.com/twitter/secureheaders)) для аналогичного поведения с предоставлением абстракции политики безопасности содержимого. Она автоматически применит логику, основанную на пользовательском агенте, для создания краткого набора заголовков.

### Ошибки бизнес-логики

Любое приложение в любой технологии может содержать ошибки бизнес-логики, которые приводят к ошибкам в системе безопасности. Ошибки бизнес-логики трудно или невозможно обнаружить с помощью автоматизированных средств. Лучшие способы предотвращения ошибок в системе безопасности - это проверка кода, сопряжение программ и написание модульных тестов.

### Поверхность для атаки

Вообще говоря, Rails позволяет избежать уязвимостей типа открытого перенаправления и обхода путей благодаря своему файлу /config/routes.rb, который определяет, какие URL-адреса должны быть доступны и какими контроллерами обрабатываться. Файл routes - отличное место для поиска, когда вы думаете о масштабах атаки.

Примером может быть следующее:

```ruby
# это пример того, чего НЕ следует делать
match ':controller(/:action(/:id(.:format)))'
```

В этом случае этот маршрут позволяет вызывать любой общедоступный метод на любом контроллере в качестве действия. Как разработчик, вы хотите убедиться, что пользователи могут обращаться только к методам контроллера, которые предназначены для этого, и только так, как это предусмотрено.

### Конфиденциальные файлы

Многие приложения Ruby on Rails имеют открытый исходный код и размещаются в общедоступных репозиториях исходного кода. Независимо от того, так ли это на самом деле или код находится в корпоративной системе управления версиями, существуют определенные файлы, которые следует либо исключить, либо тщательно обрабатывать.

``text
/config/database.yml                 - Может содержать рабочие учетные данные.
/config/initializers/secret_token.rb -  Содержит секрет, используемый для хэширования файла cookie сеанса.
/db/seeds.rb                         - Может содержать исходные данные, включая пользователя bootstrap admin.
/db/development.sqlite3              - Может содержать реальные данные.
```

### Шифрование

Rails использует шифрование операционной системы. Вообще говоря, это всегда плохая идея - создавать собственное шифрование.

Устройство по умолчанию использует bcrypt для хэширования паролей, что является подходящим решением.

Как правило, следующая конфигурация приводит к созданию 10 фрагментов для производства: `/config/initializers/devise.rb`

```ruby
config.stretches = Rails.env.test? ? 1 : 10
```

## Обновление Rails и наличие процесса обновления зависимостей

В начале 2013 года в платформе Rails был выявлен ряд критических уязвимостей. Организации, которые отстали от текущих версий, сталкивались с большими трудностями при обновлении и принимали более сложные решения, включая внесение исправлений в исходный код самой платформы.

Еще одна проблема, связанная с приложениями на Ruby в целом, заключается в том, что большинство библиотек (gems) не подписаны их авторами. В буквальном смысле невозможно создать проект на основе Rails с библиотеками, полученными из надежных источников. Одной из полезных практик может быть аудит используемых вами gems.

В общем, важно иметь процесс обновления зависимостей. В качестве примера процесса можно привести три механизма для запуска обновления ответа:

- Как правило, зависимости обновляются каждый месяц/квартал.
- Каждую неделю учитываются важные уязвимости в системе безопасности, которые могут привести к обновлению.
- В исключительных случаях может потребоваться экстренное обновление.

## Инструменты

Используйте [brakeman](https://brakemanscanner.org/), инструмент анализа кода с открытым исходным кодом для приложений Rails, чтобы выявить множество потенциальных проблем. Это не обязательно приведет к всесторонним выводам о безопасности, но с его помощью можно легко выявить проблемы. Отличный способ увидеть потенциальные проблемы в Rails - просмотреть документацию brakeman по типам предупреждений.

Более новой альтернативой является [bearer](https://github.com/Bearer/bearer), инструмент для анализа безопасности и конфиденциальности кода с открытым исходным кодом как для Ruby, так и для кода на JavaScript/TypeScript, предназначенный для выявления широкого спектра потенциальных проблем, входящих в топ-10 OWASP. Он предоставляет множество вариантов конфигурации и может быть легко интегрирован в ваш конвейер CI/CD.

Появляются новые инструменты, которые можно использовать для отслеживания проблем безопасности в наборах зависимостей, например, автоматическое сканирование с [GitHub](https://github.blog/2017-11-16-introducing-security-alerts-on-github/) и [GitLab](https://docs.gitlab.com/ee/user/application_security/dependency_scanning/).

Другой областью инструментария является инструмент тестирования безопасности [Gauntlet](http://gauntlet.org), который создан на базе cucumber и использует синтаксис gherkin для определения файлов атак.

Запущенный в мае 2013 года и очень похожий на brakeman scanner, [dawnscanner](https://github.com/thesp0nge/dawnscanner) rubygem - это статический анализатор проблем безопасности, который работает с веб-приложениями Rails, Sinatra и Padrino. Версия 1.6.6 содержит более 235 специальных проверок безопасности CVE для ruby.

## Статьи и ссылки по теме

- [Официальное руководство по безопасности Rails](https://guides.rubyonrails.org/security.html)
- [Руководство по безопасности OWASP для Ruby on Rails](https://owasp.org/www-pdf-archive/Rails_Security_2.pdf)
- [Руководство по проверке безопасности Ruby](http://code.google.com/p/ruby-security/wiki/Guide)
- [Список рассылки по безопасности Ruby on Rails](https://groups.google.com/forum/?fromgroups#!форум/rubyonrails-безопасность)
- [Rails небезопасен по умолчанию](https://codeclimate.com/blog/rails-insecure-defaults/)
